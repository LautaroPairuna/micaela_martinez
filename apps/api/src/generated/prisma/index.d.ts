/**
 * Client
 **/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types; // general types
import $Public = runtime.Types.Public;
import $Utils = runtime.Types.Utils;
import $Extensions = runtime.Types.Extensions;
import $Result = runtime.Types.Result;

export type PrismaPromise<T> = $Public.PrismaPromise<T>;

/**
 * Model Usuario
 *
 */
export type Usuario = $Result.DefaultSelection<Prisma.$UsuarioPayload>;
/**
 * Model Role
 *
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>;
/**
 * Model UsuarioRol
 *
 */
export type UsuarioRol = $Result.DefaultSelection<Prisma.$UsuarioRolPayload>;
/**
 * Model Favorito
 *
 */
export type Favorito = $Result.DefaultSelection<Prisma.$FavoritoPayload>;
/**
 * Model Curso
 *
 */
export type Curso = $Result.DefaultSelection<Prisma.$CursoPayload>;
/**
 * Model Inscripcion
 *
 */
export type Inscripcion = $Result.DefaultSelection<Prisma.$InscripcionPayload>;
/**
 * Model Modulo
 *
 */
export type Modulo = $Result.DefaultSelection<Prisma.$ModuloPayload>;
/**
 * Model Leccion
 *
 */
export type Leccion = $Result.DefaultSelection<Prisma.$LeccionPayload>;
/**
 * Model LeccionTipoConfig
 *
 */
export type LeccionTipoConfig =
  $Result.DefaultSelection<Prisma.$LeccionTipoConfigPayload>;
/**
 * Model Producto
 *
 */
export type Producto = $Result.DefaultSelection<Prisma.$ProductoPayload>;
/**
 * Model ProductoImagen
 *
 */
export type ProductoImagen =
  $Result.DefaultSelection<Prisma.$ProductoImagenPayload>;
/**
 * Model Marca
 *
 */
export type Marca = $Result.DefaultSelection<Prisma.$MarcaPayload>;
/**
 * Model Categoria
 *
 */
export type Categoria = $Result.DefaultSelection<Prisma.$CategoriaPayload>;
/**
 * Model Orden
 *
 */
export type Orden = $Result.DefaultSelection<Prisma.$OrdenPayload>;
/**
 * Model ItemOrden
 *
 */
export type ItemOrden = $Result.DefaultSelection<Prisma.$ItemOrdenPayload>;
/**
 * Model PagoSuscripcion
 *
 */
export type PagoSuscripcion =
  $Result.DefaultSelection<Prisma.$PagoSuscripcionPayload>;
/**
 * Model Direccion
 *
 */
export type Direccion = $Result.DefaultSelection<Prisma.$DireccionPayload>;
/**
 * Model Slider
 *
 */
export type Slider = $Result.DefaultSelection<Prisma.$SliderPayload>;
/**
 * Model Resena
 *
 */
export type Resena = $Result.DefaultSelection<Prisma.$ResenaPayload>;
/**
 * Model ResenaLike
 *
 */
export type ResenaLike = $Result.DefaultSelection<Prisma.$ResenaLikePayload>;
/**
 * Model ResenaRespuesta
 *
 */
export type ResenaRespuesta =
  $Result.DefaultSelection<Prisma.$ResenaRespuestaPayload>;
/**
 * Model Notificacion
 *
 */
export type Notificacion =
  $Result.DefaultSelection<Prisma.$NotificacionPayload>;
/**
 * Model PreferenciasNotificacion
 *
 */
export type PreferenciasNotificacion =
  $Result.DefaultSelection<Prisma.$PreferenciasNotificacionPayload>;
/**
 * Model ResenaBorrador
 *
 */
export type ResenaBorrador =
  $Result.DefaultSelection<Prisma.$ResenaBorradorPayload>;
/**
 * Model AuditLog
 *
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>;
/**
 * Model Carrito
 *
 */
export type Carrito = $Result.DefaultSelection<Prisma.$CarritoPayload>;
/**
 * Model ItemCarrito
 *
 */
export type ItemCarrito = $Result.DefaultSelection<Prisma.$ItemCarritoPayload>;

/**
 * Enums
 */
export namespace $Enums {
  export const TipoItemOrden: {
    CURSO: 'CURSO';
    PRODUCTO: 'PRODUCTO';
  };

  export type TipoItemOrden =
    (typeof TipoItemOrden)[keyof typeof TipoItemOrden];

  export const EstadoOrden: {
    PENDIENTE: 'PENDIENTE';
    PAGADO: 'PAGADO';
    CUMPLIDO: 'CUMPLIDO';
    CANCELADO: 'CANCELADO';
    REEMBOLSADO: 'REEMBOLSADO';
  };

  export type EstadoOrden = (typeof EstadoOrden)[keyof typeof EstadoOrden];

  export const NivelCurso: {
    BASICO: 'BASICO';
    INTERMEDIO: 'INTERMEDIO';
    AVANZADO: 'AVANZADO';
  };

  export type NivelCurso = (typeof NivelCurso)[keyof typeof NivelCurso];

  export const EstadoInscripcion: {
    ACTIVADA: 'ACTIVADA';
    PAUSADA: 'PAUSADA';
    DESACTIVADA: 'DESACTIVADA';
  };

  export type EstadoInscripcion =
    (typeof EstadoInscripcion)[keyof typeof EstadoInscripcion];

  export const TipoLike: {
    LIKE: 'LIKE';
    DISLIKE: 'DISLIKE';
  };

  export type TipoLike = (typeof TipoLike)[keyof typeof TipoLike];

  export const TipoLeccion: {
    VIDEO: 'VIDEO';
    DOCUMENTO: 'DOCUMENTO';
    QUIZ: 'QUIZ';
    TEXTO: 'TEXTO';
  };

  export type TipoLeccion = (typeof TipoLeccion)[keyof typeof TipoLeccion];

  export const TipoNotificacion: {
    RESPUESTA_RESENA: 'RESPUESTA_RESENA';
    LIKE_RESENA: 'LIKE_RESENA';
    MENCION: 'MENCION';
    SISTEMA: 'SISTEMA';
  };

  export type TipoNotificacion =
    (typeof TipoNotificacion)[keyof typeof TipoNotificacion];
}

export type TipoItemOrden = $Enums.TipoItemOrden;

export const TipoItemOrden: typeof $Enums.TipoItemOrden;

export type EstadoOrden = $Enums.EstadoOrden;

export const EstadoOrden: typeof $Enums.EstadoOrden;

export type NivelCurso = $Enums.NivelCurso;

export const NivelCurso: typeof $Enums.NivelCurso;

export type EstadoInscripcion = $Enums.EstadoInscripcion;

export const EstadoInscripcion: typeof $Enums.EstadoInscripcion;

export type TipoLike = $Enums.TipoLike;

export const TipoLike: typeof $Enums.TipoLike;

export type TipoLeccion = $Enums.TipoLeccion;

export const TipoLeccion: typeof $Enums.TipoLeccion;

export type TipoNotificacion = $Enums.TipoNotificacion;

export const TipoNotificacion: typeof $Enums.TipoNotificacion;

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Usuarios
 * const usuarios = await prisma.usuario.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions
    ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition>
      ? Prisma.GetEvents<ClientOptions['log']>
      : never
    : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] };

  /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Usuarios
   * const usuarios = await prisma.usuario.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(
    optionsArg?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>,
  );
  $on<V extends U>(
    eventType: V,
    callback: (
      event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent,
    ) => void,
  ): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(
    query: TemplateStringsArray | Prisma.Sql,
    ...values: any[]
  ): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(
    query: string,
    ...values: any[]
  ): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(
    query: TemplateStringsArray | Prisma.Sql,
    ...values: any[]
  ): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(
    query: string,
    ...values: any[]
  ): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(
    arg: [...P],
    options?: { isolationLevel?: Prisma.TransactionIsolationLevel },
  ): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>;

  $transaction<R>(
    fn: (
      prisma: Omit<PrismaClient, runtime.ITXClientDenyList>,
    ) => $Utils.JsPromise<R>,
    options?: {
      maxWait?: number;
      timeout?: number;
      isolationLevel?: Prisma.TransactionIsolationLevel;
    },
  ): $Utils.JsPromise<R>;

  $extends: $Extensions.ExtendsHook<
    'extends',
    Prisma.TypeMapCb<ClientOptions>,
    ExtArgs,
    $Utils.Call<
      Prisma.TypeMapCb<ClientOptions>,
      {
        extArgs: ExtArgs;
      }
    >
  >;

  /**
   * `prisma.usuario`: Exposes CRUD operations for the **Usuario** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Usuarios
   * const usuarios = await prisma.usuario.findMany()
   * ```
   */
  get usuario(): Prisma.UsuarioDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Roles
   * const roles = await prisma.role.findMany()
   * ```
   */
  get role(): Prisma.RoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.usuarioRol`: Exposes CRUD operations for the **UsuarioRol** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more UsuarioRols
   * const usuarioRols = await prisma.usuarioRol.findMany()
   * ```
   */
  get usuarioRol(): Prisma.UsuarioRolDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.favorito`: Exposes CRUD operations for the **Favorito** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Favoritos
   * const favoritos = await prisma.favorito.findMany()
   * ```
   */
  get favorito(): Prisma.FavoritoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.curso`: Exposes CRUD operations for the **Curso** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Cursos
   * const cursos = await prisma.curso.findMany()
   * ```
   */
  get curso(): Prisma.CursoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inscripcion`: Exposes CRUD operations for the **Inscripcion** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Inscripcions
   * const inscripcions = await prisma.inscripcion.findMany()
   * ```
   */
  get inscripcion(): Prisma.InscripcionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.modulo`: Exposes CRUD operations for the **Modulo** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Modulos
   * const modulos = await prisma.modulo.findMany()
   * ```
   */
  get modulo(): Prisma.ModuloDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.leccion`: Exposes CRUD operations for the **Leccion** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Leccions
   * const leccions = await prisma.leccion.findMany()
   * ```
   */
  get leccion(): Prisma.LeccionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.leccionTipoConfig`: Exposes CRUD operations for the **LeccionTipoConfig** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more LeccionTipoConfigs
   * const leccionTipoConfigs = await prisma.leccionTipoConfig.findMany()
   * ```
   */
  get leccionTipoConfig(): Prisma.LeccionTipoConfigDelegate<
    ExtArgs,
    ClientOptions
  >;

  /**
   * `prisma.producto`: Exposes CRUD operations for the **Producto** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Productos
   * const productos = await prisma.producto.findMany()
   * ```
   */
  get producto(): Prisma.ProductoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productoImagen`: Exposes CRUD operations for the **ProductoImagen** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more ProductoImagens
   * const productoImagens = await prisma.productoImagen.findMany()
   * ```
   */
  get productoImagen(): Prisma.ProductoImagenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.marca`: Exposes CRUD operations for the **Marca** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Marcas
   * const marcas = await prisma.marca.findMany()
   * ```
   */
  get marca(): Prisma.MarcaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.categoria`: Exposes CRUD operations for the **Categoria** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Categorias
   * const categorias = await prisma.categoria.findMany()
   * ```
   */
  get categoria(): Prisma.CategoriaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orden`: Exposes CRUD operations for the **Orden** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Ordens
   * const ordens = await prisma.orden.findMany()
   * ```
   */
  get orden(): Prisma.OrdenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.itemOrden`: Exposes CRUD operations for the **ItemOrden** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more ItemOrdens
   * const itemOrdens = await prisma.itemOrden.findMany()
   * ```
   */
  get itemOrden(): Prisma.ItemOrdenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pagoSuscripcion`: Exposes CRUD operations for the **PagoSuscripcion** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more PagoSuscripcions
   * const pagoSuscripcions = await prisma.pagoSuscripcion.findMany()
   * ```
   */
  get pagoSuscripcion(): Prisma.PagoSuscripcionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.direccion`: Exposes CRUD operations for the **Direccion** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Direccions
   * const direccions = await prisma.direccion.findMany()
   * ```
   */
  get direccion(): Prisma.DireccionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.slider`: Exposes CRUD operations for the **Slider** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Sliders
   * const sliders = await prisma.slider.findMany()
   * ```
   */
  get slider(): Prisma.SliderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.resena`: Exposes CRUD operations for the **Resena** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Resenas
   * const resenas = await prisma.resena.findMany()
   * ```
   */
  get resena(): Prisma.ResenaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.resenaLike`: Exposes CRUD operations for the **ResenaLike** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more ResenaLikes
   * const resenaLikes = await prisma.resenaLike.findMany()
   * ```
   */
  get resenaLike(): Prisma.ResenaLikeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.resenaRespuesta`: Exposes CRUD operations for the **ResenaRespuesta** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more ResenaRespuestas
   * const resenaRespuestas = await prisma.resenaRespuesta.findMany()
   * ```
   */
  get resenaRespuesta(): Prisma.ResenaRespuestaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificacion`: Exposes CRUD operations for the **Notificacion** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Notificacions
   * const notificacions = await prisma.notificacion.findMany()
   * ```
   */
  get notificacion(): Prisma.NotificacionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.preferenciasNotificacion`: Exposes CRUD operations for the **PreferenciasNotificacion** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more PreferenciasNotificacions
   * const preferenciasNotificacions = await prisma.preferenciasNotificacion.findMany()
   * ```
   */
  get preferenciasNotificacion(): Prisma.PreferenciasNotificacionDelegate<
    ExtArgs,
    ClientOptions
  >;

  /**
   * `prisma.resenaBorrador`: Exposes CRUD operations for the **ResenaBorrador** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more ResenaBorradors
   * const resenaBorradors = await prisma.resenaBorrador.findMany()
   * ```
   */
  get resenaBorrador(): Prisma.ResenaBorradorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more AuditLogs
   * const auditLogs = await prisma.auditLog.findMany()
   * ```
   */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.carrito`: Exposes CRUD operations for the **Carrito** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Carritos
   * const carritos = await prisma.carrito.findMany()
   * ```
   */
  get carrito(): Prisma.CarritoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.itemCarrito`: Exposes CRUD operations for the **ItemCarrito** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more ItemCarritos
   * const itemCarritos = await prisma.itemCarrito.findMany()
   * ```
   */
  get itemCarrito(): Prisma.ItemCarritoDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF;

  export type PrismaPromise<T> = $Public.PrismaPromise<T>;

  /**
   * Validator
   */
  export import validator = runtime.Public.validator;

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError;
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError;
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError;
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError;
  export import PrismaClientValidationError = runtime.PrismaClientValidationError;

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag;
  export import empty = runtime.empty;
  export import join = runtime.join;
  export import raw = runtime.raw;
  export import Sql = runtime.Sql;

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal;

  export type DecimalJsLike = runtime.DecimalJsLike;

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics;
  export type Metric<T> = runtime.Metric<T>;
  export type MetricHistogram = runtime.MetricHistogram;
  export type MetricHistogramBucket = runtime.MetricHistogramBucket;

  /**
   * Extensions
   */
  export import Extension = $Extensions.UserArgs;
  export import getExtensionContext = runtime.Extensions.getExtensionContext;
  export import Args = $Public.Args;
  export import Payload = $Public.Payload;
  export import Result = $Public.Result;
  export import Exact = $Public.Exact;

  /**
   * Prisma Client JS version: 6.19.2
   * Query Engine version: c2990dca591cba766e3b7ef5d9e8a84796e47ab7
   */
  export type PrismaVersion = {
    client: string;
  };

  export const prismaVersion: PrismaVersion;

  /**
   * Utility Types
   */

  export import Bytes = runtime.Bytes;
  export import JsonObject = runtime.JsonObject;
  export import JsonArray = runtime.JsonArray;
  export import JsonValue = runtime.JsonValue;
  export import InputJsonObject = runtime.InputJsonObject;
  export import InputJsonArray = runtime.InputJsonArray;
  export import InputJsonValue = runtime.InputJsonValue;

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
     * Type of `Prisma.DbNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class DbNull {
      private DbNull: never;
      private constructor();
    }

    /**
     * Type of `Prisma.JsonNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class JsonNull {
      private JsonNull: never;
      private constructor();
    }

    /**
     * Type of `Prisma.AnyNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class AnyNull {
      private AnyNull: never;
      private constructor();
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull;

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull;

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull;

  type SelectAndInclude = {
    select: any;
    include: any;
  };

  type SelectAndOmit = {
    select: any;
    omit: any;
  };

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> =
    T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<
    T extends (...args: any) => $Utils.JsPromise<any>,
  > = PromiseType<ReturnType<T>>;

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
  };

  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K;
  }[keyof T];

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K;
  };

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>;

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & (T extends SelectAndInclude
    ? 'Please either choose `select` or `include`.'
    : T extends SelectAndOmit
      ? 'Please either choose `select` or `omit`.'
      : {});

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & K;

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = T extends object
    ? U extends object
      ? (Without<T, U> & U) | (Without<U, T> & T)
      : U
    : T;

  /**
   * Is T a Record?
   */
  type IsObject<T extends any> =
    T extends Array<any>
      ? False
      : T extends Date
        ? False
        : T extends Uint8Array
          ? False
          : T extends bigint
            ? False
            : T extends object
              ? True
              : False;

  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T;

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O>; // With K possibilities
    }[K];

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>;

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<
    __Either<O, K>
  >;

  type _Either<O extends object, K extends Key, strict extends Boolean> = {
    1: EitherStrict<O, K>;
    0: EitherLoose<O, K>;
  }[strict];

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1,
  > = O extends unknown ? _Either<O, K, strict> : never;

  export type Union = any;

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K];
  } & {};

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never;

  export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<
    Overwrite<
      U,
      {
        [K in keyof U]-?: At<U, K>;
      }
    >
  >;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O
    ? O[K]
    : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown
    ? AtStrict<O, K>
    : never;
  export type At<
    O extends object,
    K extends Key,
    strict extends Boolean = 1,
  > = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function
    ? A
    : {
        [K in keyof A]: A[K];
      } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
      ?
          | (K extends keyof O ? { [P in K]: O[P] } & O : O)
          | ({ [P in keyof O as P extends K ? P : never]-?: O[P] } & O)
      : never
  >;

  type _Strict<U, _U = U> = U extends unknown
    ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>>
    : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False;

  // /**
  // 1
  // */
  export type True = 1;

  /**
  0
  */
  export type False = 0;

  export type Not<B extends Boolean> = {
    0: 1;
    1: 0;
  }[B];

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
      ? 1
      : 0;

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >;

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0;
      1: 1;
    };
    1: {
      0: 1;
      1: 1;
    };
  }[B1][B2];

  export type Keys<U extends Union> = U extends unknown ? keyof U : never;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object
    ? {
        [P in keyof T]: P extends keyof O ? O[P] : never;
      }
    : never;

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>,
  > = IsObject<T> extends True ? U : T;

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<
            UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never
          >
        : never
      : {} extends FieldPaths<T[K]>
        ? never
        : K;
  }[keyof T];

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never;
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>;
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T;

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<
    T,
    K extends Enumerable<keyof T> | keyof T,
  > = Prisma__Pick<T, MaybeTupleToUnion<K>>;

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}`
    ? never
    : T;

  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>;

  type FieldRefInputType<Model, FieldType> = Model extends never
    ? never
    : FieldRef<Model, FieldType>;

  export const ModelName: {
    Usuario: 'Usuario';
    Role: 'Role';
    UsuarioRol: 'UsuarioRol';
    Favorito: 'Favorito';
    Curso: 'Curso';
    Inscripcion: 'Inscripcion';
    Modulo: 'Modulo';
    Leccion: 'Leccion';
    LeccionTipoConfig: 'LeccionTipoConfig';
    Producto: 'Producto';
    ProductoImagen: 'ProductoImagen';
    Marca: 'Marca';
    Categoria: 'Categoria';
    Orden: 'Orden';
    ItemOrden: 'ItemOrden';
    PagoSuscripcion: 'PagoSuscripcion';
    Direccion: 'Direccion';
    Slider: 'Slider';
    Resena: 'Resena';
    ResenaLike: 'ResenaLike';
    ResenaRespuesta: 'ResenaRespuesta';
    Notificacion: 'Notificacion';
    PreferenciasNotificacion: 'PreferenciasNotificacion';
    ResenaBorrador: 'ResenaBorrador';
    AuditLog: 'AuditLog';
    Carrito: 'Carrito';
    ItemCarrito: 'ItemCarrito';
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName];

  export type Datasources = {
    db?: Datasource;
  };

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<
    { extArgs: $Extensions.InternalArgs },
    $Utils.Record<string, any>
  > {
    returns: Prisma.TypeMap<
      this['params']['extArgs'],
      ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}
    >;
  }

  export type TypeMap<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > = {
    globalOmitOptions: {
      omit: GlobalOmitOptions;
    };
    meta: {
      modelProps:
        | 'usuario'
        | 'role'
        | 'usuarioRol'
        | 'favorito'
        | 'curso'
        | 'inscripcion'
        | 'modulo'
        | 'leccion'
        | 'leccionTipoConfig'
        | 'producto'
        | 'productoImagen'
        | 'marca'
        | 'categoria'
        | 'orden'
        | 'itemOrden'
        | 'pagoSuscripcion'
        | 'direccion'
        | 'slider'
        | 'resena'
        | 'resenaLike'
        | 'resenaRespuesta'
        | 'notificacion'
        | 'preferenciasNotificacion'
        | 'resenaBorrador'
        | 'auditLog'
        | 'carrito'
        | 'itemCarrito';
      txIsolationLevel: Prisma.TransactionIsolationLevel;
    };
    model: {
      Usuario: {
        payload: Prisma.$UsuarioPayload<ExtArgs>;
        fields: Prisma.UsuarioFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.UsuarioFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.UsuarioFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>;
          };
          findFirst: {
            args: Prisma.UsuarioFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.UsuarioFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>;
          };
          findMany: {
            args: Prisma.UsuarioFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[];
          };
          create: {
            args: Prisma.UsuarioCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>;
          };
          createMany: {
            args: Prisma.UsuarioCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.UsuarioDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>;
          };
          update: {
            args: Prisma.UsuarioUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>;
          };
          deleteMany: {
            args: Prisma.UsuarioDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.UsuarioUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.UsuarioUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>;
          };
          aggregate: {
            args: Prisma.UsuarioAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateUsuario>;
          };
          groupBy: {
            args: Prisma.UsuarioGroupByArgs<ExtArgs>;
            result: $Utils.Optional<UsuarioGroupByOutputType>[];
          };
          count: {
            args: Prisma.UsuarioCountArgs<ExtArgs>;
            result: $Utils.Optional<UsuarioCountAggregateOutputType> | number;
          };
        };
      };
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>;
        fields: Prisma.RoleFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload>;
          };
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload>;
          };
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[];
          };
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload>;
          };
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload>;
          };
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload>;
          };
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload>;
          };
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateRole>;
          };
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>;
            result: $Utils.Optional<RoleGroupByOutputType>[];
          };
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>;
            result: $Utils.Optional<RoleCountAggregateOutputType> | number;
          };
        };
      };
      UsuarioRol: {
        payload: Prisma.$UsuarioRolPayload<ExtArgs>;
        fields: Prisma.UsuarioRolFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.UsuarioRolFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UsuarioRolPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.UsuarioRolFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UsuarioRolPayload>;
          };
          findFirst: {
            args: Prisma.UsuarioRolFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UsuarioRolPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.UsuarioRolFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UsuarioRolPayload>;
          };
          findMany: {
            args: Prisma.UsuarioRolFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UsuarioRolPayload>[];
          };
          create: {
            args: Prisma.UsuarioRolCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UsuarioRolPayload>;
          };
          createMany: {
            args: Prisma.UsuarioRolCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.UsuarioRolDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UsuarioRolPayload>;
          };
          update: {
            args: Prisma.UsuarioRolUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UsuarioRolPayload>;
          };
          deleteMany: {
            args: Prisma.UsuarioRolDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.UsuarioRolUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.UsuarioRolUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UsuarioRolPayload>;
          };
          aggregate: {
            args: Prisma.UsuarioRolAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateUsuarioRol>;
          };
          groupBy: {
            args: Prisma.UsuarioRolGroupByArgs<ExtArgs>;
            result: $Utils.Optional<UsuarioRolGroupByOutputType>[];
          };
          count: {
            args: Prisma.UsuarioRolCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<UsuarioRolCountAggregateOutputType>
              | number;
          };
        };
      };
      Favorito: {
        payload: Prisma.$FavoritoPayload<ExtArgs>;
        fields: Prisma.FavoritoFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.FavoritoFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FavoritoPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.FavoritoFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FavoritoPayload>;
          };
          findFirst: {
            args: Prisma.FavoritoFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FavoritoPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.FavoritoFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FavoritoPayload>;
          };
          findMany: {
            args: Prisma.FavoritoFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FavoritoPayload>[];
          };
          create: {
            args: Prisma.FavoritoCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FavoritoPayload>;
          };
          createMany: {
            args: Prisma.FavoritoCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.FavoritoDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FavoritoPayload>;
          };
          update: {
            args: Prisma.FavoritoUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FavoritoPayload>;
          };
          deleteMany: {
            args: Prisma.FavoritoDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.FavoritoUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.FavoritoUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FavoritoPayload>;
          };
          aggregate: {
            args: Prisma.FavoritoAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateFavorito>;
          };
          groupBy: {
            args: Prisma.FavoritoGroupByArgs<ExtArgs>;
            result: $Utils.Optional<FavoritoGroupByOutputType>[];
          };
          count: {
            args: Prisma.FavoritoCountArgs<ExtArgs>;
            result: $Utils.Optional<FavoritoCountAggregateOutputType> | number;
          };
        };
      };
      Curso: {
        payload: Prisma.$CursoPayload<ExtArgs>;
        fields: Prisma.CursoFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.CursoFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CursoPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.CursoFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CursoPayload>;
          };
          findFirst: {
            args: Prisma.CursoFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CursoPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.CursoFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CursoPayload>;
          };
          findMany: {
            args: Prisma.CursoFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CursoPayload>[];
          };
          create: {
            args: Prisma.CursoCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CursoPayload>;
          };
          createMany: {
            args: Prisma.CursoCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.CursoDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CursoPayload>;
          };
          update: {
            args: Prisma.CursoUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CursoPayload>;
          };
          deleteMany: {
            args: Prisma.CursoDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.CursoUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.CursoUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CursoPayload>;
          };
          aggregate: {
            args: Prisma.CursoAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateCurso>;
          };
          groupBy: {
            args: Prisma.CursoGroupByArgs<ExtArgs>;
            result: $Utils.Optional<CursoGroupByOutputType>[];
          };
          count: {
            args: Prisma.CursoCountArgs<ExtArgs>;
            result: $Utils.Optional<CursoCountAggregateOutputType> | number;
          };
        };
      };
      Inscripcion: {
        payload: Prisma.$InscripcionPayload<ExtArgs>;
        fields: Prisma.InscripcionFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.InscripcionFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InscripcionPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.InscripcionFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InscripcionPayload>;
          };
          findFirst: {
            args: Prisma.InscripcionFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InscripcionPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.InscripcionFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InscripcionPayload>;
          };
          findMany: {
            args: Prisma.InscripcionFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InscripcionPayload>[];
          };
          create: {
            args: Prisma.InscripcionCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InscripcionPayload>;
          };
          createMany: {
            args: Prisma.InscripcionCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.InscripcionDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InscripcionPayload>;
          };
          update: {
            args: Prisma.InscripcionUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InscripcionPayload>;
          };
          deleteMany: {
            args: Prisma.InscripcionDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.InscripcionUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.InscripcionUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InscripcionPayload>;
          };
          aggregate: {
            args: Prisma.InscripcionAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateInscripcion>;
          };
          groupBy: {
            args: Prisma.InscripcionGroupByArgs<ExtArgs>;
            result: $Utils.Optional<InscripcionGroupByOutputType>[];
          };
          count: {
            args: Prisma.InscripcionCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<InscripcionCountAggregateOutputType>
              | number;
          };
        };
      };
      Modulo: {
        payload: Prisma.$ModuloPayload<ExtArgs>;
        fields: Prisma.ModuloFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ModuloFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ModuloPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ModuloFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ModuloPayload>;
          };
          findFirst: {
            args: Prisma.ModuloFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ModuloPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ModuloFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ModuloPayload>;
          };
          findMany: {
            args: Prisma.ModuloFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ModuloPayload>[];
          };
          create: {
            args: Prisma.ModuloCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ModuloPayload>;
          };
          createMany: {
            args: Prisma.ModuloCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.ModuloDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ModuloPayload>;
          };
          update: {
            args: Prisma.ModuloUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ModuloPayload>;
          };
          deleteMany: {
            args: Prisma.ModuloDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ModuloUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.ModuloUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ModuloPayload>;
          };
          aggregate: {
            args: Prisma.ModuloAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateModulo>;
          };
          groupBy: {
            args: Prisma.ModuloGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ModuloGroupByOutputType>[];
          };
          count: {
            args: Prisma.ModuloCountArgs<ExtArgs>;
            result: $Utils.Optional<ModuloCountAggregateOutputType> | number;
          };
        };
      };
      Leccion: {
        payload: Prisma.$LeccionPayload<ExtArgs>;
        fields: Prisma.LeccionFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.LeccionFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LeccionPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.LeccionFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LeccionPayload>;
          };
          findFirst: {
            args: Prisma.LeccionFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LeccionPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.LeccionFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LeccionPayload>;
          };
          findMany: {
            args: Prisma.LeccionFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LeccionPayload>[];
          };
          create: {
            args: Prisma.LeccionCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LeccionPayload>;
          };
          createMany: {
            args: Prisma.LeccionCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.LeccionDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LeccionPayload>;
          };
          update: {
            args: Prisma.LeccionUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LeccionPayload>;
          };
          deleteMany: {
            args: Prisma.LeccionDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.LeccionUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.LeccionUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LeccionPayload>;
          };
          aggregate: {
            args: Prisma.LeccionAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateLeccion>;
          };
          groupBy: {
            args: Prisma.LeccionGroupByArgs<ExtArgs>;
            result: $Utils.Optional<LeccionGroupByOutputType>[];
          };
          count: {
            args: Prisma.LeccionCountArgs<ExtArgs>;
            result: $Utils.Optional<LeccionCountAggregateOutputType> | number;
          };
        };
      };
      LeccionTipoConfig: {
        payload: Prisma.$LeccionTipoConfigPayload<ExtArgs>;
        fields: Prisma.LeccionTipoConfigFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.LeccionTipoConfigFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LeccionTipoConfigPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.LeccionTipoConfigFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LeccionTipoConfigPayload>;
          };
          findFirst: {
            args: Prisma.LeccionTipoConfigFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LeccionTipoConfigPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.LeccionTipoConfigFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LeccionTipoConfigPayload>;
          };
          findMany: {
            args: Prisma.LeccionTipoConfigFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LeccionTipoConfigPayload>[];
          };
          create: {
            args: Prisma.LeccionTipoConfigCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LeccionTipoConfigPayload>;
          };
          createMany: {
            args: Prisma.LeccionTipoConfigCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.LeccionTipoConfigDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LeccionTipoConfigPayload>;
          };
          update: {
            args: Prisma.LeccionTipoConfigUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LeccionTipoConfigPayload>;
          };
          deleteMany: {
            args: Prisma.LeccionTipoConfigDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.LeccionTipoConfigUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.LeccionTipoConfigUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LeccionTipoConfigPayload>;
          };
          aggregate: {
            args: Prisma.LeccionTipoConfigAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateLeccionTipoConfig>;
          };
          groupBy: {
            args: Prisma.LeccionTipoConfigGroupByArgs<ExtArgs>;
            result: $Utils.Optional<LeccionTipoConfigGroupByOutputType>[];
          };
          count: {
            args: Prisma.LeccionTipoConfigCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<LeccionTipoConfigCountAggregateOutputType>
              | number;
          };
        };
      };
      Producto: {
        payload: Prisma.$ProductoPayload<ExtArgs>;
        fields: Prisma.ProductoFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ProductoFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductoPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ProductoFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductoPayload>;
          };
          findFirst: {
            args: Prisma.ProductoFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductoPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ProductoFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductoPayload>;
          };
          findMany: {
            args: Prisma.ProductoFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductoPayload>[];
          };
          create: {
            args: Prisma.ProductoCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductoPayload>;
          };
          createMany: {
            args: Prisma.ProductoCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.ProductoDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductoPayload>;
          };
          update: {
            args: Prisma.ProductoUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductoPayload>;
          };
          deleteMany: {
            args: Prisma.ProductoDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ProductoUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.ProductoUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductoPayload>;
          };
          aggregate: {
            args: Prisma.ProductoAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateProducto>;
          };
          groupBy: {
            args: Prisma.ProductoGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ProductoGroupByOutputType>[];
          };
          count: {
            args: Prisma.ProductoCountArgs<ExtArgs>;
            result: $Utils.Optional<ProductoCountAggregateOutputType> | number;
          };
        };
      };
      ProductoImagen: {
        payload: Prisma.$ProductoImagenPayload<ExtArgs>;
        fields: Prisma.ProductoImagenFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ProductoImagenFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductoImagenPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ProductoImagenFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductoImagenPayload>;
          };
          findFirst: {
            args: Prisma.ProductoImagenFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductoImagenPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ProductoImagenFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductoImagenPayload>;
          };
          findMany: {
            args: Prisma.ProductoImagenFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductoImagenPayload>[];
          };
          create: {
            args: Prisma.ProductoImagenCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductoImagenPayload>;
          };
          createMany: {
            args: Prisma.ProductoImagenCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.ProductoImagenDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductoImagenPayload>;
          };
          update: {
            args: Prisma.ProductoImagenUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductoImagenPayload>;
          };
          deleteMany: {
            args: Prisma.ProductoImagenDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ProductoImagenUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.ProductoImagenUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductoImagenPayload>;
          };
          aggregate: {
            args: Prisma.ProductoImagenAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateProductoImagen>;
          };
          groupBy: {
            args: Prisma.ProductoImagenGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ProductoImagenGroupByOutputType>[];
          };
          count: {
            args: Prisma.ProductoImagenCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<ProductoImagenCountAggregateOutputType>
              | number;
          };
        };
      };
      Marca: {
        payload: Prisma.$MarcaPayload<ExtArgs>;
        fields: Prisma.MarcaFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.MarcaFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MarcaPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.MarcaFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MarcaPayload>;
          };
          findFirst: {
            args: Prisma.MarcaFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MarcaPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.MarcaFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MarcaPayload>;
          };
          findMany: {
            args: Prisma.MarcaFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MarcaPayload>[];
          };
          create: {
            args: Prisma.MarcaCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MarcaPayload>;
          };
          createMany: {
            args: Prisma.MarcaCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.MarcaDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MarcaPayload>;
          };
          update: {
            args: Prisma.MarcaUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MarcaPayload>;
          };
          deleteMany: {
            args: Prisma.MarcaDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.MarcaUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.MarcaUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MarcaPayload>;
          };
          aggregate: {
            args: Prisma.MarcaAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateMarca>;
          };
          groupBy: {
            args: Prisma.MarcaGroupByArgs<ExtArgs>;
            result: $Utils.Optional<MarcaGroupByOutputType>[];
          };
          count: {
            args: Prisma.MarcaCountArgs<ExtArgs>;
            result: $Utils.Optional<MarcaCountAggregateOutputType> | number;
          };
        };
      };
      Categoria: {
        payload: Prisma.$CategoriaPayload<ExtArgs>;
        fields: Prisma.CategoriaFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.CategoriaFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.CategoriaFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload>;
          };
          findFirst: {
            args: Prisma.CategoriaFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.CategoriaFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload>;
          };
          findMany: {
            args: Prisma.CategoriaFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload>[];
          };
          create: {
            args: Prisma.CategoriaCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload>;
          };
          createMany: {
            args: Prisma.CategoriaCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.CategoriaDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload>;
          };
          update: {
            args: Prisma.CategoriaUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload>;
          };
          deleteMany: {
            args: Prisma.CategoriaDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.CategoriaUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.CategoriaUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload>;
          };
          aggregate: {
            args: Prisma.CategoriaAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateCategoria>;
          };
          groupBy: {
            args: Prisma.CategoriaGroupByArgs<ExtArgs>;
            result: $Utils.Optional<CategoriaGroupByOutputType>[];
          };
          count: {
            args: Prisma.CategoriaCountArgs<ExtArgs>;
            result: $Utils.Optional<CategoriaCountAggregateOutputType> | number;
          };
        };
      };
      Orden: {
        payload: Prisma.$OrdenPayload<ExtArgs>;
        fields: Prisma.OrdenFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.OrdenFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrdenPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.OrdenFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrdenPayload>;
          };
          findFirst: {
            args: Prisma.OrdenFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrdenPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.OrdenFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrdenPayload>;
          };
          findMany: {
            args: Prisma.OrdenFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrdenPayload>[];
          };
          create: {
            args: Prisma.OrdenCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrdenPayload>;
          };
          createMany: {
            args: Prisma.OrdenCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.OrdenDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrdenPayload>;
          };
          update: {
            args: Prisma.OrdenUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrdenPayload>;
          };
          deleteMany: {
            args: Prisma.OrdenDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.OrdenUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.OrdenUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrdenPayload>;
          };
          aggregate: {
            args: Prisma.OrdenAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateOrden>;
          };
          groupBy: {
            args: Prisma.OrdenGroupByArgs<ExtArgs>;
            result: $Utils.Optional<OrdenGroupByOutputType>[];
          };
          count: {
            args: Prisma.OrdenCountArgs<ExtArgs>;
            result: $Utils.Optional<OrdenCountAggregateOutputType> | number;
          };
        };
      };
      ItemOrden: {
        payload: Prisma.$ItemOrdenPayload<ExtArgs>;
        fields: Prisma.ItemOrdenFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ItemOrdenFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ItemOrdenPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ItemOrdenFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ItemOrdenPayload>;
          };
          findFirst: {
            args: Prisma.ItemOrdenFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ItemOrdenPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ItemOrdenFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ItemOrdenPayload>;
          };
          findMany: {
            args: Prisma.ItemOrdenFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ItemOrdenPayload>[];
          };
          create: {
            args: Prisma.ItemOrdenCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ItemOrdenPayload>;
          };
          createMany: {
            args: Prisma.ItemOrdenCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.ItemOrdenDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ItemOrdenPayload>;
          };
          update: {
            args: Prisma.ItemOrdenUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ItemOrdenPayload>;
          };
          deleteMany: {
            args: Prisma.ItemOrdenDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ItemOrdenUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.ItemOrdenUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ItemOrdenPayload>;
          };
          aggregate: {
            args: Prisma.ItemOrdenAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateItemOrden>;
          };
          groupBy: {
            args: Prisma.ItemOrdenGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ItemOrdenGroupByOutputType>[];
          };
          count: {
            args: Prisma.ItemOrdenCountArgs<ExtArgs>;
            result: $Utils.Optional<ItemOrdenCountAggregateOutputType> | number;
          };
        };
      };
      PagoSuscripcion: {
        payload: Prisma.$PagoSuscripcionPayload<ExtArgs>;
        fields: Prisma.PagoSuscripcionFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.PagoSuscripcionFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PagoSuscripcionPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.PagoSuscripcionFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PagoSuscripcionPayload>;
          };
          findFirst: {
            args: Prisma.PagoSuscripcionFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PagoSuscripcionPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.PagoSuscripcionFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PagoSuscripcionPayload>;
          };
          findMany: {
            args: Prisma.PagoSuscripcionFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PagoSuscripcionPayload>[];
          };
          create: {
            args: Prisma.PagoSuscripcionCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PagoSuscripcionPayload>;
          };
          createMany: {
            args: Prisma.PagoSuscripcionCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.PagoSuscripcionDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PagoSuscripcionPayload>;
          };
          update: {
            args: Prisma.PagoSuscripcionUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PagoSuscripcionPayload>;
          };
          deleteMany: {
            args: Prisma.PagoSuscripcionDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.PagoSuscripcionUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.PagoSuscripcionUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PagoSuscripcionPayload>;
          };
          aggregate: {
            args: Prisma.PagoSuscripcionAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregatePagoSuscripcion>;
          };
          groupBy: {
            args: Prisma.PagoSuscripcionGroupByArgs<ExtArgs>;
            result: $Utils.Optional<PagoSuscripcionGroupByOutputType>[];
          };
          count: {
            args: Prisma.PagoSuscripcionCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<PagoSuscripcionCountAggregateOutputType>
              | number;
          };
        };
      };
      Direccion: {
        payload: Prisma.$DireccionPayload<ExtArgs>;
        fields: Prisma.DireccionFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.DireccionFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DireccionPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.DireccionFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DireccionPayload>;
          };
          findFirst: {
            args: Prisma.DireccionFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DireccionPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.DireccionFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DireccionPayload>;
          };
          findMany: {
            args: Prisma.DireccionFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DireccionPayload>[];
          };
          create: {
            args: Prisma.DireccionCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DireccionPayload>;
          };
          createMany: {
            args: Prisma.DireccionCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.DireccionDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DireccionPayload>;
          };
          update: {
            args: Prisma.DireccionUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DireccionPayload>;
          };
          deleteMany: {
            args: Prisma.DireccionDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.DireccionUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.DireccionUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DireccionPayload>;
          };
          aggregate: {
            args: Prisma.DireccionAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateDireccion>;
          };
          groupBy: {
            args: Prisma.DireccionGroupByArgs<ExtArgs>;
            result: $Utils.Optional<DireccionGroupByOutputType>[];
          };
          count: {
            args: Prisma.DireccionCountArgs<ExtArgs>;
            result: $Utils.Optional<DireccionCountAggregateOutputType> | number;
          };
        };
      };
      Slider: {
        payload: Prisma.$SliderPayload<ExtArgs>;
        fields: Prisma.SliderFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.SliderFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SliderPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.SliderFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SliderPayload>;
          };
          findFirst: {
            args: Prisma.SliderFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SliderPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.SliderFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SliderPayload>;
          };
          findMany: {
            args: Prisma.SliderFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SliderPayload>[];
          };
          create: {
            args: Prisma.SliderCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SliderPayload>;
          };
          createMany: {
            args: Prisma.SliderCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.SliderDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SliderPayload>;
          };
          update: {
            args: Prisma.SliderUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SliderPayload>;
          };
          deleteMany: {
            args: Prisma.SliderDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.SliderUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.SliderUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SliderPayload>;
          };
          aggregate: {
            args: Prisma.SliderAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateSlider>;
          };
          groupBy: {
            args: Prisma.SliderGroupByArgs<ExtArgs>;
            result: $Utils.Optional<SliderGroupByOutputType>[];
          };
          count: {
            args: Prisma.SliderCountArgs<ExtArgs>;
            result: $Utils.Optional<SliderCountAggregateOutputType> | number;
          };
        };
      };
      Resena: {
        payload: Prisma.$ResenaPayload<ExtArgs>;
        fields: Prisma.ResenaFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ResenaFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ResenaPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ResenaFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ResenaPayload>;
          };
          findFirst: {
            args: Prisma.ResenaFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ResenaPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ResenaFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ResenaPayload>;
          };
          findMany: {
            args: Prisma.ResenaFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ResenaPayload>[];
          };
          create: {
            args: Prisma.ResenaCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ResenaPayload>;
          };
          createMany: {
            args: Prisma.ResenaCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.ResenaDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ResenaPayload>;
          };
          update: {
            args: Prisma.ResenaUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ResenaPayload>;
          };
          deleteMany: {
            args: Prisma.ResenaDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ResenaUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.ResenaUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ResenaPayload>;
          };
          aggregate: {
            args: Prisma.ResenaAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateResena>;
          };
          groupBy: {
            args: Prisma.ResenaGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ResenaGroupByOutputType>[];
          };
          count: {
            args: Prisma.ResenaCountArgs<ExtArgs>;
            result: $Utils.Optional<ResenaCountAggregateOutputType> | number;
          };
        };
      };
      ResenaLike: {
        payload: Prisma.$ResenaLikePayload<ExtArgs>;
        fields: Prisma.ResenaLikeFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ResenaLikeFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ResenaLikePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ResenaLikeFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ResenaLikePayload>;
          };
          findFirst: {
            args: Prisma.ResenaLikeFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ResenaLikePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ResenaLikeFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ResenaLikePayload>;
          };
          findMany: {
            args: Prisma.ResenaLikeFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ResenaLikePayload>[];
          };
          create: {
            args: Prisma.ResenaLikeCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ResenaLikePayload>;
          };
          createMany: {
            args: Prisma.ResenaLikeCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.ResenaLikeDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ResenaLikePayload>;
          };
          update: {
            args: Prisma.ResenaLikeUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ResenaLikePayload>;
          };
          deleteMany: {
            args: Prisma.ResenaLikeDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ResenaLikeUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.ResenaLikeUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ResenaLikePayload>;
          };
          aggregate: {
            args: Prisma.ResenaLikeAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateResenaLike>;
          };
          groupBy: {
            args: Prisma.ResenaLikeGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ResenaLikeGroupByOutputType>[];
          };
          count: {
            args: Prisma.ResenaLikeCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<ResenaLikeCountAggregateOutputType>
              | number;
          };
        };
      };
      ResenaRespuesta: {
        payload: Prisma.$ResenaRespuestaPayload<ExtArgs>;
        fields: Prisma.ResenaRespuestaFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ResenaRespuestaFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ResenaRespuestaPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ResenaRespuestaFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ResenaRespuestaPayload>;
          };
          findFirst: {
            args: Prisma.ResenaRespuestaFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ResenaRespuestaPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ResenaRespuestaFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ResenaRespuestaPayload>;
          };
          findMany: {
            args: Prisma.ResenaRespuestaFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ResenaRespuestaPayload>[];
          };
          create: {
            args: Prisma.ResenaRespuestaCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ResenaRespuestaPayload>;
          };
          createMany: {
            args: Prisma.ResenaRespuestaCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.ResenaRespuestaDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ResenaRespuestaPayload>;
          };
          update: {
            args: Prisma.ResenaRespuestaUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ResenaRespuestaPayload>;
          };
          deleteMany: {
            args: Prisma.ResenaRespuestaDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ResenaRespuestaUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.ResenaRespuestaUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ResenaRespuestaPayload>;
          };
          aggregate: {
            args: Prisma.ResenaRespuestaAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateResenaRespuesta>;
          };
          groupBy: {
            args: Prisma.ResenaRespuestaGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ResenaRespuestaGroupByOutputType>[];
          };
          count: {
            args: Prisma.ResenaRespuestaCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<ResenaRespuestaCountAggregateOutputType>
              | number;
          };
        };
      };
      Notificacion: {
        payload: Prisma.$NotificacionPayload<ExtArgs>;
        fields: Prisma.NotificacionFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.NotificacionFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.NotificacionFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload>;
          };
          findFirst: {
            args: Prisma.NotificacionFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.NotificacionFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload>;
          };
          findMany: {
            args: Prisma.NotificacionFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload>[];
          };
          create: {
            args: Prisma.NotificacionCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload>;
          };
          createMany: {
            args: Prisma.NotificacionCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.NotificacionDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload>;
          };
          update: {
            args: Prisma.NotificacionUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload>;
          };
          deleteMany: {
            args: Prisma.NotificacionDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.NotificacionUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.NotificacionUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload>;
          };
          aggregate: {
            args: Prisma.NotificacionAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateNotificacion>;
          };
          groupBy: {
            args: Prisma.NotificacionGroupByArgs<ExtArgs>;
            result: $Utils.Optional<NotificacionGroupByOutputType>[];
          };
          count: {
            args: Prisma.NotificacionCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<NotificacionCountAggregateOutputType>
              | number;
          };
        };
      };
      PreferenciasNotificacion: {
        payload: Prisma.$PreferenciasNotificacionPayload<ExtArgs>;
        fields: Prisma.PreferenciasNotificacionFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.PreferenciasNotificacionFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PreferenciasNotificacionPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.PreferenciasNotificacionFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PreferenciasNotificacionPayload>;
          };
          findFirst: {
            args: Prisma.PreferenciasNotificacionFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PreferenciasNotificacionPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.PreferenciasNotificacionFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PreferenciasNotificacionPayload>;
          };
          findMany: {
            args: Prisma.PreferenciasNotificacionFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PreferenciasNotificacionPayload>[];
          };
          create: {
            args: Prisma.PreferenciasNotificacionCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PreferenciasNotificacionPayload>;
          };
          createMany: {
            args: Prisma.PreferenciasNotificacionCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.PreferenciasNotificacionDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PreferenciasNotificacionPayload>;
          };
          update: {
            args: Prisma.PreferenciasNotificacionUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PreferenciasNotificacionPayload>;
          };
          deleteMany: {
            args: Prisma.PreferenciasNotificacionDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.PreferenciasNotificacionUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.PreferenciasNotificacionUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PreferenciasNotificacionPayload>;
          };
          aggregate: {
            args: Prisma.PreferenciasNotificacionAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregatePreferenciasNotificacion>;
          };
          groupBy: {
            args: Prisma.PreferenciasNotificacionGroupByArgs<ExtArgs>;
            result: $Utils.Optional<PreferenciasNotificacionGroupByOutputType>[];
          };
          count: {
            args: Prisma.PreferenciasNotificacionCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<PreferenciasNotificacionCountAggregateOutputType>
              | number;
          };
        };
      };
      ResenaBorrador: {
        payload: Prisma.$ResenaBorradorPayload<ExtArgs>;
        fields: Prisma.ResenaBorradorFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ResenaBorradorFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ResenaBorradorPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ResenaBorradorFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ResenaBorradorPayload>;
          };
          findFirst: {
            args: Prisma.ResenaBorradorFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ResenaBorradorPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ResenaBorradorFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ResenaBorradorPayload>;
          };
          findMany: {
            args: Prisma.ResenaBorradorFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ResenaBorradorPayload>[];
          };
          create: {
            args: Prisma.ResenaBorradorCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ResenaBorradorPayload>;
          };
          createMany: {
            args: Prisma.ResenaBorradorCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.ResenaBorradorDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ResenaBorradorPayload>;
          };
          update: {
            args: Prisma.ResenaBorradorUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ResenaBorradorPayload>;
          };
          deleteMany: {
            args: Prisma.ResenaBorradorDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ResenaBorradorUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.ResenaBorradorUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ResenaBorradorPayload>;
          };
          aggregate: {
            args: Prisma.ResenaBorradorAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateResenaBorrador>;
          };
          groupBy: {
            args: Prisma.ResenaBorradorGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ResenaBorradorGroupByOutputType>[];
          };
          count: {
            args: Prisma.ResenaBorradorCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<ResenaBorradorCountAggregateOutputType>
              | number;
          };
        };
      };
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>;
        fields: Prisma.AuditLogFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>;
          };
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>;
          };
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[];
          };
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>;
          };
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>;
          };
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>;
          };
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>;
          };
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateAuditLog>;
          };
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>;
            result: $Utils.Optional<AuditLogGroupByOutputType>[];
          };
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>;
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number;
          };
        };
      };
      Carrito: {
        payload: Prisma.$CarritoPayload<ExtArgs>;
        fields: Prisma.CarritoFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.CarritoFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CarritoPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.CarritoFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CarritoPayload>;
          };
          findFirst: {
            args: Prisma.CarritoFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CarritoPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.CarritoFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CarritoPayload>;
          };
          findMany: {
            args: Prisma.CarritoFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CarritoPayload>[];
          };
          create: {
            args: Prisma.CarritoCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CarritoPayload>;
          };
          createMany: {
            args: Prisma.CarritoCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.CarritoDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CarritoPayload>;
          };
          update: {
            args: Prisma.CarritoUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CarritoPayload>;
          };
          deleteMany: {
            args: Prisma.CarritoDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.CarritoUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.CarritoUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CarritoPayload>;
          };
          aggregate: {
            args: Prisma.CarritoAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateCarrito>;
          };
          groupBy: {
            args: Prisma.CarritoGroupByArgs<ExtArgs>;
            result: $Utils.Optional<CarritoGroupByOutputType>[];
          };
          count: {
            args: Prisma.CarritoCountArgs<ExtArgs>;
            result: $Utils.Optional<CarritoCountAggregateOutputType> | number;
          };
        };
      };
      ItemCarrito: {
        payload: Prisma.$ItemCarritoPayload<ExtArgs>;
        fields: Prisma.ItemCarritoFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ItemCarritoFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ItemCarritoPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ItemCarritoFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ItemCarritoPayload>;
          };
          findFirst: {
            args: Prisma.ItemCarritoFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ItemCarritoPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ItemCarritoFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ItemCarritoPayload>;
          };
          findMany: {
            args: Prisma.ItemCarritoFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ItemCarritoPayload>[];
          };
          create: {
            args: Prisma.ItemCarritoCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ItemCarritoPayload>;
          };
          createMany: {
            args: Prisma.ItemCarritoCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.ItemCarritoDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ItemCarritoPayload>;
          };
          update: {
            args: Prisma.ItemCarritoUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ItemCarritoPayload>;
          };
          deleteMany: {
            args: Prisma.ItemCarritoDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ItemCarritoUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.ItemCarritoUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ItemCarritoPayload>;
          };
          aggregate: {
            args: Prisma.ItemCarritoAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateItemCarrito>;
          };
          groupBy: {
            args: Prisma.ItemCarritoGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ItemCarritoGroupByOutputType>[];
          };
          count: {
            args: Prisma.ItemCarritoCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<ItemCarritoCountAggregateOutputType>
              | number;
          };
        };
      };
    };
  } & {
    other: {
      payload: any;
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]];
          result: any;
        };
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]];
          result: any;
        };
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]];
          result: any;
        };
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]];
          result: any;
        };
      };
    };
  };
  export const defineExtension: $Extensions.ExtendsHook<
    'define',
    Prisma.TypeMapCb,
    $Extensions.DefaultArgs
  >;
  export type DefaultPrismaClient = PrismaClient;
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal';
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources;
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string;
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat;
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     *
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     *
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     *
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[];
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number;
      timeout?: number;
      isolationLevel?: Prisma.TransactionIsolationLevel;
    };
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null;
    /**
     * Global configuration for omitting model fields by default.
     *
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig;
  }
  export type GlobalOmitConfig = {
    usuario?: UsuarioOmit;
    role?: RoleOmit;
    usuarioRol?: UsuarioRolOmit;
    favorito?: FavoritoOmit;
    curso?: CursoOmit;
    inscripcion?: InscripcionOmit;
    modulo?: ModuloOmit;
    leccion?: LeccionOmit;
    leccionTipoConfig?: LeccionTipoConfigOmit;
    producto?: ProductoOmit;
    productoImagen?: ProductoImagenOmit;
    marca?: MarcaOmit;
    categoria?: CategoriaOmit;
    orden?: OrdenOmit;
    itemOrden?: ItemOrdenOmit;
    pagoSuscripcion?: PagoSuscripcionOmit;
    direccion?: DireccionOmit;
    slider?: SliderOmit;
    resena?: ResenaOmit;
    resenaLike?: ResenaLikeOmit;
    resenaRespuesta?: ResenaRespuestaOmit;
    notificacion?: NotificacionOmit;
    preferenciasNotificacion?: PreferenciasNotificacionOmit;
    resenaBorrador?: ResenaBorradorOmit;
    auditLog?: AuditLogOmit;
    carrito?: CarritoOmit;
    itemCarrito?: ItemCarritoOmit;
  };

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error';
  export type LogDefinition = {
    level: LogLevel;
    emit: 'stdout' | 'event';
  };

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> =
    T extends Array<LogLevel | LogDefinition> ? GetLogType<T[number]> : never;

  export type QueryEvent = {
    timestamp: Date;
    query: string;
    params: string;
    duration: number;
    target: string;
  };

  export type LogEvent = {
    timestamp: Date;
    message: string;
    target: string;
  };
  /* End Types for Logging */

  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy';

  // tested in getLogLevel.test.ts
  export function getLogLevel(
    log: Array<LogLevel | LogDefinition>,
  ): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<
    Prisma.DefaultPrismaClient,
    runtime.ITXClientDenyList
  >;

  export type Datasource = {
    url?: string;
  };

  /**
   * Count Types
   */

  /**
   * Count Type UsuarioCountOutputType
   */

  export type UsuarioCountOutputType = {
    roles: number;
    cursosImpartidos: number;
    inscripciones: number;
    resenas: number;
    resenaRespuestas: number;
    favoritos: number;
    resenaLikes: number;
    ordenes: number;
    auditLogs: number;
    notificaciones: number;
  };

  export type UsuarioCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    roles?: boolean | UsuarioCountOutputTypeCountRolesArgs;
    cursosImpartidos?:
      | boolean
      | UsuarioCountOutputTypeCountCursosImpartidosArgs;
    inscripciones?: boolean | UsuarioCountOutputTypeCountInscripcionesArgs;
    resenas?: boolean | UsuarioCountOutputTypeCountResenasArgs;
    resenaRespuestas?:
      | boolean
      | UsuarioCountOutputTypeCountResenaRespuestasArgs;
    favoritos?: boolean | UsuarioCountOutputTypeCountFavoritosArgs;
    resenaLikes?: boolean | UsuarioCountOutputTypeCountResenaLikesArgs;
    ordenes?: boolean | UsuarioCountOutputTypeCountOrdenesArgs;
    auditLogs?: boolean | UsuarioCountOutputTypeCountAuditLogsArgs;
    notificaciones?: boolean | UsuarioCountOutputTypeCountNotificacionesArgs;
  };

  // Custom InputTypes
  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UsuarioCountOutputType
     */
    select?: UsuarioCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountRolesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: UsuarioRolWhereInput;
  };

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountCursosImpartidosArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: CursoWhereInput;
  };

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountInscripcionesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: InscripcionWhereInput;
  };

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountResenasArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ResenaWhereInput;
  };

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountResenaRespuestasArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ResenaRespuestaWhereInput;
  };

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountFavoritosArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: FavoritoWhereInput;
  };

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountResenaLikesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ResenaLikeWhereInput;
  };

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountOrdenesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: OrdenWhereInput;
  };

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountAuditLogsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AuditLogWhereInput;
  };

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountNotificacionesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: NotificacionWhereInput;
  };

  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    usuarios: number;
  };

  export type RoleCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    usuarios?: boolean | RoleCountOutputTypeCountUsuariosArgs;
  };

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUsuariosArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: UsuarioRolWhereInput;
  };

  /**
   * Count Type CursoCountOutputType
   */

  export type CursoCountOutputType = {
    modulos: number;
    resenas: number;
    inscripciones: number;
    itemsCarrito: number;
  };

  export type CursoCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    modulos?: boolean | CursoCountOutputTypeCountModulosArgs;
    resenas?: boolean | CursoCountOutputTypeCountResenasArgs;
    inscripciones?: boolean | CursoCountOutputTypeCountInscripcionesArgs;
    itemsCarrito?: boolean | CursoCountOutputTypeCountItemsCarritoArgs;
  };

  // Custom InputTypes
  /**
   * CursoCountOutputType without action
   */
  export type CursoCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CursoCountOutputType
     */
    select?: CursoCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * CursoCountOutputType without action
   */
  export type CursoCountOutputTypeCountModulosArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ModuloWhereInput;
  };

  /**
   * CursoCountOutputType without action
   */
  export type CursoCountOutputTypeCountResenasArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ResenaWhereInput;
  };

  /**
   * CursoCountOutputType without action
   */
  export type CursoCountOutputTypeCountInscripcionesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: InscripcionWhereInput;
  };

  /**
   * CursoCountOutputType without action
   */
  export type CursoCountOutputTypeCountItemsCarritoArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ItemCarritoWhereInput;
  };

  /**
   * Count Type ModuloCountOutputType
   */

  export type ModuloCountOutputType = {
    lecciones: number;
  };

  export type ModuloCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    lecciones?: boolean | ModuloCountOutputTypeCountLeccionesArgs;
  };

  // Custom InputTypes
  /**
   * ModuloCountOutputType without action
   */
  export type ModuloCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ModuloCountOutputType
     */
    select?: ModuloCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * ModuloCountOutputType without action
   */
  export type ModuloCountOutputTypeCountLeccionesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: LeccionWhereInput;
  };

  /**
   * Count Type ProductoCountOutputType
   */

  export type ProductoCountOutputType = {
    imagenes: number;
    resenas: number;
    favoritos: number;
    itemsCarrito: number;
  };

  export type ProductoCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    imagenes?: boolean | ProductoCountOutputTypeCountImagenesArgs;
    resenas?: boolean | ProductoCountOutputTypeCountResenasArgs;
    favoritos?: boolean | ProductoCountOutputTypeCountFavoritosArgs;
    itemsCarrito?: boolean | ProductoCountOutputTypeCountItemsCarritoArgs;
  };

  // Custom InputTypes
  /**
   * ProductoCountOutputType without action
   */
  export type ProductoCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProductoCountOutputType
     */
    select?: ProductoCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * ProductoCountOutputType without action
   */
  export type ProductoCountOutputTypeCountImagenesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ProductoImagenWhereInput;
  };

  /**
   * ProductoCountOutputType without action
   */
  export type ProductoCountOutputTypeCountResenasArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ResenaWhereInput;
  };

  /**
   * ProductoCountOutputType without action
   */
  export type ProductoCountOutputTypeCountFavoritosArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: FavoritoWhereInput;
  };

  /**
   * ProductoCountOutputType without action
   */
  export type ProductoCountOutputTypeCountItemsCarritoArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ItemCarritoWhereInput;
  };

  /**
   * Count Type MarcaCountOutputType
   */

  export type MarcaCountOutputType = {
    productos: number;
  };

  export type MarcaCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    productos?: boolean | MarcaCountOutputTypeCountProductosArgs;
  };

  // Custom InputTypes
  /**
   * MarcaCountOutputType without action
   */
  export type MarcaCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MarcaCountOutputType
     */
    select?: MarcaCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * MarcaCountOutputType without action
   */
  export type MarcaCountOutputTypeCountProductosArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ProductoWhereInput;
  };

  /**
   * Count Type CategoriaCountOutputType
   */

  export type CategoriaCountOutputType = {
    hijos: number;
    productos: number;
  };

  export type CategoriaCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    hijos?: boolean | CategoriaCountOutputTypeCountHijosArgs;
    productos?: boolean | CategoriaCountOutputTypeCountProductosArgs;
  };

  // Custom InputTypes
  /**
   * CategoriaCountOutputType without action
   */
  export type CategoriaCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CategoriaCountOutputType
     */
    select?: CategoriaCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * CategoriaCountOutputType without action
   */
  export type CategoriaCountOutputTypeCountHijosArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: CategoriaWhereInput;
  };

  /**
   * CategoriaCountOutputType without action
   */
  export type CategoriaCountOutputTypeCountProductosArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ProductoWhereInput;
  };

  /**
   * Count Type OrdenCountOutputType
   */

  export type OrdenCountOutputType = {
    items: number;
  };

  export type OrdenCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    items?: boolean | OrdenCountOutputTypeCountItemsArgs;
  };

  // Custom InputTypes
  /**
   * OrdenCountOutputType without action
   */
  export type OrdenCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrdenCountOutputType
     */
    select?: OrdenCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * OrdenCountOutputType without action
   */
  export type OrdenCountOutputTypeCountItemsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ItemOrdenWhereInput;
  };

  /**
   * Count Type DireccionCountOutputType
   */

  export type DireccionCountOutputType = {
    ordenesEnvio: number;
    ordenesFacturacion: number;
  };

  export type DireccionCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    ordenesEnvio?: boolean | DireccionCountOutputTypeCountOrdenesEnvioArgs;
    ordenesFacturacion?:
      | boolean
      | DireccionCountOutputTypeCountOrdenesFacturacionArgs;
  };

  // Custom InputTypes
  /**
   * DireccionCountOutputType without action
   */
  export type DireccionCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DireccionCountOutputType
     */
    select?: DireccionCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * DireccionCountOutputType without action
   */
  export type DireccionCountOutputTypeCountOrdenesEnvioArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: OrdenWhereInput;
  };

  /**
   * DireccionCountOutputType without action
   */
  export type DireccionCountOutputTypeCountOrdenesFacturacionArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: OrdenWhereInput;
  };

  /**
   * Count Type ResenaCountOutputType
   */

  export type ResenaCountOutputType = {
    respuestas: number;
    likes: number;
  };

  export type ResenaCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    respuestas?: boolean | ResenaCountOutputTypeCountRespuestasArgs;
    likes?: boolean | ResenaCountOutputTypeCountLikesArgs;
  };

  // Custom InputTypes
  /**
   * ResenaCountOutputType without action
   */
  export type ResenaCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ResenaCountOutputType
     */
    select?: ResenaCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * ResenaCountOutputType without action
   */
  export type ResenaCountOutputTypeCountRespuestasArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ResenaRespuestaWhereInput;
  };

  /**
   * ResenaCountOutputType without action
   */
  export type ResenaCountOutputTypeCountLikesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ResenaLikeWhereInput;
  };

  /**
   * Count Type ResenaRespuestaCountOutputType
   */

  export type ResenaRespuestaCountOutputType = {
    hijos: number;
  };

  export type ResenaRespuestaCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    hijos?: boolean | ResenaRespuestaCountOutputTypeCountHijosArgs;
  };

  // Custom InputTypes
  /**
   * ResenaRespuestaCountOutputType without action
   */
  export type ResenaRespuestaCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ResenaRespuestaCountOutputType
     */
    select?: ResenaRespuestaCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * ResenaRespuestaCountOutputType without action
   */
  export type ResenaRespuestaCountOutputTypeCountHijosArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ResenaRespuestaWhereInput;
  };

  /**
   * Count Type CarritoCountOutputType
   */

  export type CarritoCountOutputType = {
    items: number;
  };

  export type CarritoCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    items?: boolean | CarritoCountOutputTypeCountItemsArgs;
  };

  // Custom InputTypes
  /**
   * CarritoCountOutputType without action
   */
  export type CarritoCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CarritoCountOutputType
     */
    select?: CarritoCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * CarritoCountOutputType without action
   */
  export type CarritoCountOutputTypeCountItemsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ItemCarritoWhereInput;
  };

  /**
   * Models
   */

  /**
   * Model Usuario
   */

  export type AggregateUsuario = {
    _count: UsuarioCountAggregateOutputType | null;
    _avg: UsuarioAvgAggregateOutputType | null;
    _sum: UsuarioSumAggregateOutputType | null;
    _min: UsuarioMinAggregateOutputType | null;
    _max: UsuarioMaxAggregateOutputType | null;
  };

  export type UsuarioAvgAggregateOutputType = {
    id: number | null;
  };

  export type UsuarioSumAggregateOutputType = {
    id: number | null;
  };

  export type UsuarioMinAggregateOutputType = {
    id: number | null;
    email: string | null;
    nombre: string | null;
    passwordHash: string | null;
    creadoEn: Date | null;
    actualizadoEn: Date | null;
    emailVerificadoEn: Date | null;
  };

  export type UsuarioMaxAggregateOutputType = {
    id: number | null;
    email: string | null;
    nombre: string | null;
    passwordHash: string | null;
    creadoEn: Date | null;
    actualizadoEn: Date | null;
    emailVerificadoEn: Date | null;
  };

  export type UsuarioCountAggregateOutputType = {
    id: number;
    email: number;
    nombre: number;
    passwordHash: number;
    creadoEn: number;
    actualizadoEn: number;
    emailVerificadoEn: number;
    _all: number;
  };

  export type UsuarioAvgAggregateInputType = {
    id?: true;
  };

  export type UsuarioSumAggregateInputType = {
    id?: true;
  };

  export type UsuarioMinAggregateInputType = {
    id?: true;
    email?: true;
    nombre?: true;
    passwordHash?: true;
    creadoEn?: true;
    actualizadoEn?: true;
    emailVerificadoEn?: true;
  };

  export type UsuarioMaxAggregateInputType = {
    id?: true;
    email?: true;
    nombre?: true;
    passwordHash?: true;
    creadoEn?: true;
    actualizadoEn?: true;
    emailVerificadoEn?: true;
  };

  export type UsuarioCountAggregateInputType = {
    id?: true;
    email?: true;
    nombre?: true;
    passwordHash?: true;
    creadoEn?: true;
    actualizadoEn?: true;
    emailVerificadoEn?: true;
    _all?: true;
  };

  export type UsuarioAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Usuario to aggregate.
     */
    where?: UsuarioWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Usuarios to fetch.
     */
    orderBy?:
      | UsuarioOrderByWithRelationInput
      | UsuarioOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: UsuarioWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Usuarios.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Usuarios
     **/
    _count?: true | UsuarioCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: UsuarioAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: UsuarioSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: UsuarioMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: UsuarioMaxAggregateInputType;
  };

  export type GetUsuarioAggregateType<T extends UsuarioAggregateArgs> = {
    [P in keyof T & keyof AggregateUsuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuario[P]>
      : GetScalarType<T[P], AggregateUsuario[P]>;
  };

  export type UsuarioGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: UsuarioWhereInput;
    orderBy?:
      | UsuarioOrderByWithAggregationInput
      | UsuarioOrderByWithAggregationInput[];
    by: UsuarioScalarFieldEnum[] | UsuarioScalarFieldEnum;
    having?: UsuarioScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: UsuarioCountAggregateInputType | true;
    _avg?: UsuarioAvgAggregateInputType;
    _sum?: UsuarioSumAggregateInputType;
    _min?: UsuarioMinAggregateInputType;
    _max?: UsuarioMaxAggregateInputType;
  };

  export type UsuarioGroupByOutputType = {
    id: number;
    email: string;
    nombre: string | null;
    passwordHash: string;
    creadoEn: Date;
    actualizadoEn: Date;
    emailVerificadoEn: Date | null;
    _count: UsuarioCountAggregateOutputType | null;
    _avg: UsuarioAvgAggregateOutputType | null;
    _sum: UsuarioSumAggregateOutputType | null;
    _min: UsuarioMinAggregateOutputType | null;
    _max: UsuarioMaxAggregateOutputType | null;
  };

  type GetUsuarioGroupByPayload<T extends UsuarioGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<UsuarioGroupByOutputType, T['by']> & {
          [P in keyof T & keyof UsuarioGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
            : GetScalarType<T[P], UsuarioGroupByOutputType[P]>;
        }
      >
    >;

  export type UsuarioSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      email?: boolean;
      nombre?: boolean;
      passwordHash?: boolean;
      creadoEn?: boolean;
      actualizadoEn?: boolean;
      emailVerificadoEn?: boolean;
      roles?: boolean | Usuario$rolesArgs<ExtArgs>;
      cursosImpartidos?: boolean | Usuario$cursosImpartidosArgs<ExtArgs>;
      inscripciones?: boolean | Usuario$inscripcionesArgs<ExtArgs>;
      resenas?: boolean | Usuario$resenasArgs<ExtArgs>;
      resenaRespuestas?: boolean | Usuario$resenaRespuestasArgs<ExtArgs>;
      favoritos?: boolean | Usuario$favoritosArgs<ExtArgs>;
      resenaLikes?: boolean | Usuario$resenaLikesArgs<ExtArgs>;
      ordenes?: boolean | Usuario$ordenesArgs<ExtArgs>;
      auditLogs?: boolean | Usuario$auditLogsArgs<ExtArgs>;
      carrito?: boolean | Usuario$carritoArgs<ExtArgs>;
      notificaciones?: boolean | Usuario$notificacionesArgs<ExtArgs>;
      _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['usuario']
  >;

  export type UsuarioSelectScalar = {
    id?: boolean;
    email?: boolean;
    nombre?: boolean;
    passwordHash?: boolean;
    creadoEn?: boolean;
    actualizadoEn?: boolean;
    emailVerificadoEn?: boolean;
  };

  export type UsuarioOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'email'
    | 'nombre'
    | 'passwordHash'
    | 'creadoEn'
    | 'actualizadoEn'
    | 'emailVerificadoEn',
    ExtArgs['result']['usuario']
  >;
  export type UsuarioInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    roles?: boolean | Usuario$rolesArgs<ExtArgs>;
    cursosImpartidos?: boolean | Usuario$cursosImpartidosArgs<ExtArgs>;
    inscripciones?: boolean | Usuario$inscripcionesArgs<ExtArgs>;
    resenas?: boolean | Usuario$resenasArgs<ExtArgs>;
    resenaRespuestas?: boolean | Usuario$resenaRespuestasArgs<ExtArgs>;
    favoritos?: boolean | Usuario$favoritosArgs<ExtArgs>;
    resenaLikes?: boolean | Usuario$resenaLikesArgs<ExtArgs>;
    ordenes?: boolean | Usuario$ordenesArgs<ExtArgs>;
    auditLogs?: boolean | Usuario$auditLogsArgs<ExtArgs>;
    carrito?: boolean | Usuario$carritoArgs<ExtArgs>;
    notificaciones?: boolean | Usuario$notificacionesArgs<ExtArgs>;
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>;
  };

  export type $UsuarioPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Usuario';
    objects: {
      roles: Prisma.$UsuarioRolPayload<ExtArgs>[];
      cursosImpartidos: Prisma.$CursoPayload<ExtArgs>[];
      inscripciones: Prisma.$InscripcionPayload<ExtArgs>[];
      resenas: Prisma.$ResenaPayload<ExtArgs>[];
      resenaRespuestas: Prisma.$ResenaRespuestaPayload<ExtArgs>[];
      favoritos: Prisma.$FavoritoPayload<ExtArgs>[];
      resenaLikes: Prisma.$ResenaLikePayload<ExtArgs>[];
      ordenes: Prisma.$OrdenPayload<ExtArgs>[];
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[];
      carrito: Prisma.$CarritoPayload<ExtArgs> | null;
      notificaciones: Prisma.$NotificacionPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        email: string;
        nombre: string | null;
        passwordHash: string;
        creadoEn: Date;
        actualizadoEn: Date;
        emailVerificadoEn: Date | null;
      },
      ExtArgs['result']['usuario']
    >;
    composites: {};
  };

  type UsuarioGetPayload<
    S extends boolean | null | undefined | UsuarioDefaultArgs,
  > = $Result.GetResult<Prisma.$UsuarioPayload, S>;

  type UsuarioCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<UsuarioFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: UsuarioCountAggregateInputType | true;
  };

  export interface UsuarioDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Usuario'];
      meta: { name: 'Usuario' };
    };
    /**
     * Find zero or one Usuario that matches the filter.
     * @param {UsuarioFindUniqueArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsuarioFindUniqueArgs>(
      args: SelectSubset<T, UsuarioFindUniqueArgs<ExtArgs>>,
    ): Prisma__UsuarioClient<
      $Result.GetResult<
        Prisma.$UsuarioPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Usuario that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UsuarioFindUniqueOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsuarioFindUniqueOrThrowArgs>(
      args: SelectSubset<T, UsuarioFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__UsuarioClient<
      $Result.GetResult<
        Prisma.$UsuarioPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Usuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsuarioFindFirstArgs>(
      args?: SelectSubset<T, UsuarioFindFirstArgs<ExtArgs>>,
    ): Prisma__UsuarioClient<
      $Result.GetResult<
        Prisma.$UsuarioPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Usuario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsuarioFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UsuarioFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__UsuarioClient<
      $Result.GetResult<
        Prisma.$UsuarioPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuario.findMany()
     *
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuario.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const usuarioWithIdOnly = await prisma.usuario.findMany({ select: { id: true } })
     *
     */
    findMany<T extends UsuarioFindManyArgs>(
      args?: SelectSubset<T, UsuarioFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UsuarioPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Usuario.
     * @param {UsuarioCreateArgs} args - Arguments to create a Usuario.
     * @example
     * // Create one Usuario
     * const Usuario = await prisma.usuario.create({
     *   data: {
     *     // ... data to create a Usuario
     *   }
     * })
     *
     */
    create<T extends UsuarioCreateArgs>(
      args: SelectSubset<T, UsuarioCreateArgs<ExtArgs>>,
    ): Prisma__UsuarioClient<
      $Result.GetResult<
        Prisma.$UsuarioPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Usuarios.
     * @param {UsuarioCreateManyArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuario = await prisma.usuario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends UsuarioCreateManyArgs>(
      args?: SelectSubset<T, UsuarioCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Usuario.
     * @param {UsuarioDeleteArgs} args - Arguments to delete one Usuario.
     * @example
     * // Delete one Usuario
     * const Usuario = await prisma.usuario.delete({
     *   where: {
     *     // ... filter to delete one Usuario
     *   }
     * })
     *
     */
    delete<T extends UsuarioDeleteArgs>(
      args: SelectSubset<T, UsuarioDeleteArgs<ExtArgs>>,
    ): Prisma__UsuarioClient<
      $Result.GetResult<
        Prisma.$UsuarioPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Usuario.
     * @param {UsuarioUpdateArgs} args - Arguments to update one Usuario.
     * @example
     * // Update one Usuario
     * const usuario = await prisma.usuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends UsuarioUpdateArgs>(
      args: SelectSubset<T, UsuarioUpdateArgs<ExtArgs>>,
    ): Prisma__UsuarioClient<
      $Result.GetResult<
        Prisma.$UsuarioPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Usuarios.
     * @param {UsuarioDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends UsuarioDeleteManyArgs>(
      args?: SelectSubset<T, UsuarioDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends UsuarioUpdateManyArgs>(
      args: SelectSubset<T, UsuarioUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Usuario.
     * @param {UsuarioUpsertArgs} args - Arguments to update or create a Usuario.
     * @example
     * // Update or create a Usuario
     * const usuario = await prisma.usuario.upsert({
     *   create: {
     *     // ... data to create a Usuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuario we want to update
     *   }
     * })
     */
    upsert<T extends UsuarioUpsertArgs>(
      args: SelectSubset<T, UsuarioUpsertArgs<ExtArgs>>,
    ): Prisma__UsuarioClient<
      $Result.GetResult<
        Prisma.$UsuarioPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuario.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
     **/
    count<T extends UsuarioCountArgs>(
      args?: Subset<T, UsuarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuarioCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends UsuarioAggregateArgs>(
      args: Subset<T, UsuarioAggregateArgs>,
    ): Prisma.PrismaPromise<GetUsuarioAggregateType<T>>;

    /**
     * Group by Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends UsuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsuarioGroupByArgs['orderBy'] }
        : { orderBy?: UsuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, UsuarioGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetUsuarioGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Usuario model
     */
    readonly fields: UsuarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Usuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsuarioClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    roles<T extends Usuario$rolesArgs<ExtArgs> = {}>(
      args?: Subset<T, Usuario$rolesArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$UsuarioRolPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    cursosImpartidos<T extends Usuario$cursosImpartidosArgs<ExtArgs> = {}>(
      args?: Subset<T, Usuario$cursosImpartidosArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$CursoPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    inscripciones<T extends Usuario$inscripcionesArgs<ExtArgs> = {}>(
      args?: Subset<T, Usuario$inscripcionesArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$InscripcionPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    resenas<T extends Usuario$resenasArgs<ExtArgs> = {}>(
      args?: Subset<T, Usuario$resenasArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$ResenaPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    resenaRespuestas<T extends Usuario$resenaRespuestasArgs<ExtArgs> = {}>(
      args?: Subset<T, Usuario$resenaRespuestasArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$ResenaRespuestaPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    favoritos<T extends Usuario$favoritosArgs<ExtArgs> = {}>(
      args?: Subset<T, Usuario$favoritosArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$FavoritoPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    resenaLikes<T extends Usuario$resenaLikesArgs<ExtArgs> = {}>(
      args?: Subset<T, Usuario$resenaLikesArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$ResenaLikePayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    ordenes<T extends Usuario$ordenesArgs<ExtArgs> = {}>(
      args?: Subset<T, Usuario$ordenesArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$OrdenPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    auditLogs<T extends Usuario$auditLogsArgs<ExtArgs> = {}>(
      args?: Subset<T, Usuario$auditLogsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$AuditLogPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    carrito<T extends Usuario$carritoArgs<ExtArgs> = {}>(
      args?: Subset<T, Usuario$carritoArgs<ExtArgs>>,
    ): Prisma__CarritoClient<
      $Result.GetResult<
        Prisma.$CarritoPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    notificaciones<T extends Usuario$notificacionesArgs<ExtArgs> = {}>(
      args?: Subset<T, Usuario$notificacionesArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$NotificacionPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Usuario model
   */
  interface UsuarioFieldRefs {
    readonly id: FieldRef<'Usuario', 'Int'>;
    readonly email: FieldRef<'Usuario', 'String'>;
    readonly nombre: FieldRef<'Usuario', 'String'>;
    readonly passwordHash: FieldRef<'Usuario', 'String'>;
    readonly creadoEn: FieldRef<'Usuario', 'DateTime'>;
    readonly actualizadoEn: FieldRef<'Usuario', 'DateTime'>;
    readonly emailVerificadoEn: FieldRef<'Usuario', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Usuario findUnique
   */
  export type UsuarioFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null;
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput;
  };

  /**
   * Usuario findUniqueOrThrow
   */
  export type UsuarioFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null;
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput;
  };

  /**
   * Usuario findFirst
   */
  export type UsuarioFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null;
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Usuarios to fetch.
     */
    orderBy?:
      | UsuarioOrderByWithRelationInput
      | UsuarioOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Usuarios.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[];
  };

  /**
   * Usuario findFirstOrThrow
   */
  export type UsuarioFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null;
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Usuarios to fetch.
     */
    orderBy?:
      | UsuarioOrderByWithRelationInput
      | UsuarioOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Usuarios.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[];
  };

  /**
   * Usuario findMany
   */
  export type UsuarioFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null;
    /**
     * Filter, which Usuarios to fetch.
     */
    where?: UsuarioWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Usuarios to fetch.
     */
    orderBy?:
      | UsuarioOrderByWithRelationInput
      | UsuarioOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Usuarios.
     */
    skip?: number;
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[];
  };

  /**
   * Usuario create
   */
  export type UsuarioCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null;
    /**
     * The data needed to create a Usuario.
     */
    data: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>;
  };

  /**
   * Usuario createMany
   */
  export type UsuarioCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Usuarios.
     */
    data: UsuarioCreateManyInput | UsuarioCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Usuario update
   */
  export type UsuarioUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null;
    /**
     * The data needed to update a Usuario.
     */
    data: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>;
    /**
     * Choose, which Usuario to update.
     */
    where: UsuarioWhereUniqueInput;
  };

  /**
   * Usuario updateMany
   */
  export type UsuarioUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Usuarios.
     */
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyInput>;
    /**
     * Filter which Usuarios to update
     */
    where?: UsuarioWhereInput;
    /**
     * Limit how many Usuarios to update.
     */
    limit?: number;
  };

  /**
   * Usuario upsert
   */
  export type UsuarioUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null;
    /**
     * The filter to search for the Usuario to update in case it exists.
     */
    where: UsuarioWhereUniqueInput;
    /**
     * In case the Usuario found by the `where` argument doesn't exist, create a new Usuario with this data.
     */
    create: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>;
    /**
     * In case the Usuario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>;
  };

  /**
   * Usuario delete
   */
  export type UsuarioDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null;
    /**
     * Filter which Usuario to delete.
     */
    where: UsuarioWhereUniqueInput;
  };

  /**
   * Usuario deleteMany
   */
  export type UsuarioDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Usuarios to delete
     */
    where?: UsuarioWhereInput;
    /**
     * Limit how many Usuarios to delete.
     */
    limit?: number;
  };

  /**
   * Usuario.roles
   */
  export type Usuario$rolesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UsuarioRol
     */
    select?: UsuarioRolSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UsuarioRol
     */
    omit?: UsuarioRolOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioRolInclude<ExtArgs> | null;
    where?: UsuarioRolWhereInput;
    orderBy?:
      | UsuarioRolOrderByWithRelationInput
      | UsuarioRolOrderByWithRelationInput[];
    cursor?: UsuarioRolWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: UsuarioRolScalarFieldEnum | UsuarioRolScalarFieldEnum[];
  };

  /**
   * Usuario.cursosImpartidos
   */
  export type Usuario$cursosImpartidosArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Curso
     */
    select?: CursoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Curso
     */
    omit?: CursoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoInclude<ExtArgs> | null;
    where?: CursoWhereInput;
    orderBy?: CursoOrderByWithRelationInput | CursoOrderByWithRelationInput[];
    cursor?: CursoWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: CursoScalarFieldEnum | CursoScalarFieldEnum[];
  };

  /**
   * Usuario.inscripciones
   */
  export type Usuario$inscripcionesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Inscripcion
     */
    select?: InscripcionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Inscripcion
     */
    omit?: InscripcionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InscripcionInclude<ExtArgs> | null;
    where?: InscripcionWhereInput;
    orderBy?:
      | InscripcionOrderByWithRelationInput
      | InscripcionOrderByWithRelationInput[];
    cursor?: InscripcionWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: InscripcionScalarFieldEnum | InscripcionScalarFieldEnum[];
  };

  /**
   * Usuario.resenas
   */
  export type Usuario$resenasArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Resena
     */
    select?: ResenaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Resena
     */
    omit?: ResenaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaInclude<ExtArgs> | null;
    where?: ResenaWhereInput;
    orderBy?: ResenaOrderByWithRelationInput | ResenaOrderByWithRelationInput[];
    cursor?: ResenaWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ResenaScalarFieldEnum | ResenaScalarFieldEnum[];
  };

  /**
   * Usuario.resenaRespuestas
   */
  export type Usuario$resenaRespuestasArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ResenaRespuesta
     */
    select?: ResenaRespuestaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ResenaRespuesta
     */
    omit?: ResenaRespuestaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaRespuestaInclude<ExtArgs> | null;
    where?: ResenaRespuestaWhereInput;
    orderBy?:
      | ResenaRespuestaOrderByWithRelationInput
      | ResenaRespuestaOrderByWithRelationInput[];
    cursor?: ResenaRespuestaWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | ResenaRespuestaScalarFieldEnum
      | ResenaRespuestaScalarFieldEnum[];
  };

  /**
   * Usuario.favoritos
   */
  export type Usuario$favoritosArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Favorito
     */
    select?: FavoritoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Favorito
     */
    omit?: FavoritoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoritoInclude<ExtArgs> | null;
    where?: FavoritoWhereInput;
    orderBy?:
      | FavoritoOrderByWithRelationInput
      | FavoritoOrderByWithRelationInput[];
    cursor?: FavoritoWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: FavoritoScalarFieldEnum | FavoritoScalarFieldEnum[];
  };

  /**
   * Usuario.resenaLikes
   */
  export type Usuario$resenaLikesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ResenaLike
     */
    select?: ResenaLikeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ResenaLike
     */
    omit?: ResenaLikeOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaLikeInclude<ExtArgs> | null;
    where?: ResenaLikeWhereInput;
    orderBy?:
      | ResenaLikeOrderByWithRelationInput
      | ResenaLikeOrderByWithRelationInput[];
    cursor?: ResenaLikeWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ResenaLikeScalarFieldEnum | ResenaLikeScalarFieldEnum[];
  };

  /**
   * Usuario.ordenes
   */
  export type Usuario$ordenesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Orden
     */
    select?: OrdenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Orden
     */
    omit?: OrdenOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdenInclude<ExtArgs> | null;
    where?: OrdenWhereInput;
    orderBy?: OrdenOrderByWithRelationInput | OrdenOrderByWithRelationInput[];
    cursor?: OrdenWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: OrdenScalarFieldEnum | OrdenScalarFieldEnum[];
  };

  /**
   * Usuario.auditLogs
   */
  export type Usuario$auditLogsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    where?: AuditLogWhereInput;
    orderBy?:
      | AuditLogOrderByWithRelationInput
      | AuditLogOrderByWithRelationInput[];
    cursor?: AuditLogWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[];
  };

  /**
   * Usuario.carrito
   */
  export type Usuario$carritoArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Carrito
     */
    select?: CarritoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Carrito
     */
    omit?: CarritoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarritoInclude<ExtArgs> | null;
    where?: CarritoWhereInput;
  };

  /**
   * Usuario.notificaciones
   */
  export type Usuario$notificacionesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null;
    where?: NotificacionWhereInput;
    orderBy?:
      | NotificacionOrderByWithRelationInput
      | NotificacionOrderByWithRelationInput[];
    cursor?: NotificacionWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: NotificacionScalarFieldEnum | NotificacionScalarFieldEnum[];
  };

  /**
   * Usuario without action
   */
  export type UsuarioDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null;
  };

  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null;
    _avg: RoleAvgAggregateOutputType | null;
    _sum: RoleSumAggregateOutputType | null;
    _min: RoleMinAggregateOutputType | null;
    _max: RoleMaxAggregateOutputType | null;
  };

  export type RoleAvgAggregateOutputType = {
    id: number | null;
  };

  export type RoleSumAggregateOutputType = {
    id: number | null;
  };

  export type RoleMinAggregateOutputType = {
    id: number | null;
    slug: string | null;
    name: string | null;
    createdAt: Date | null;
  };

  export type RoleMaxAggregateOutputType = {
    id: number | null;
    slug: string | null;
    name: string | null;
    createdAt: Date | null;
  };

  export type RoleCountAggregateOutputType = {
    id: number;
    slug: number;
    name: number;
    createdAt: number;
    _all: number;
  };

  export type RoleAvgAggregateInputType = {
    id?: true;
  };

  export type RoleSumAggregateInputType = {
    id?: true;
  };

  export type RoleMinAggregateInputType = {
    id?: true;
    slug?: true;
    name?: true;
    createdAt?: true;
  };

  export type RoleMaxAggregateInputType = {
    id?: true;
    slug?: true;
    name?: true;
    createdAt?: true;
  };

  export type RoleCountAggregateInputType = {
    id?: true;
    slug?: true;
    name?: true;
    createdAt?: true;
    _all?: true;
  };

  export type RoleAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Roles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Roles
     **/
    _count?: true | RoleCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: RoleAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: RoleSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: RoleMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: RoleMaxAggregateInputType;
  };

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
    [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>;
  };

  export type RoleGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: RoleWhereInput;
    orderBy?:
      | RoleOrderByWithAggregationInput
      | RoleOrderByWithAggregationInput[];
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum;
    having?: RoleScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: RoleCountAggregateInputType | true;
    _avg?: RoleAvgAggregateInputType;
    _sum?: RoleSumAggregateInputType;
    _min?: RoleMinAggregateInputType;
    _max?: RoleMaxAggregateInputType;
  };

  export type RoleGroupByOutputType = {
    id: number;
    slug: string;
    name: string;
    createdAt: Date;
    _count: RoleCountAggregateOutputType | null;
    _avg: RoleAvgAggregateOutputType | null;
    _sum: RoleSumAggregateOutputType | null;
    _min: RoleMinAggregateOutputType | null;
    _max: RoleMaxAggregateOutputType | null;
  };

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> & {
        [P in keyof T & keyof RoleGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
          : GetScalarType<T[P], RoleGroupByOutputType[P]>;
      }
    >
  >;

  export type RoleSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      slug?: boolean;
      name?: boolean;
      createdAt?: boolean;
      usuarios?: boolean | Role$usuariosArgs<ExtArgs>;
      _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['role']
  >;

  export type RoleSelectScalar = {
    id?: boolean;
    slug?: boolean;
    name?: boolean;
    createdAt?: boolean;
  };

  export type RoleOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    'id' | 'slug' | 'name' | 'createdAt',
    ExtArgs['result']['role']
  >;
  export type RoleInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    usuarios?: boolean | Role$usuariosArgs<ExtArgs>;
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>;
  };

  export type $RolePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Role';
    objects: {
      usuarios: Prisma.$UsuarioRolPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        slug: string;
        name: string;
        createdAt: Date;
      },
      ExtArgs['result']['role']
    >;
    composites: {};
  };

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> =
    $Result.GetResult<Prisma.$RolePayload, S>;

  type RoleCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: RoleCountAggregateInputType | true;
  };

  export interface RoleDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Role'];
      meta: { name: 'Role' };
    };
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(
      args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>,
    ): Prisma__RoleClient<
      $Result.GetResult<
        Prisma.$RolePayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(
      args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__RoleClient<
      $Result.GetResult<
        Prisma.$RolePayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(
      args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>,
    ): Prisma__RoleClient<
      $Result.GetResult<
        Prisma.$RolePayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__RoleClient<
      $Result.GetResult<
        Prisma.$RolePayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     *
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     *
     */
    findMany<T extends RoleFindManyArgs>(
      args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$RolePayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     *
     */
    create<T extends RoleCreateArgs>(
      args: SelectSubset<T, RoleCreateArgs<ExtArgs>>,
    ): Prisma__RoleClient<
      $Result.GetResult<
        Prisma.$RolePayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends RoleCreateManyArgs>(
      args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     *
     */
    delete<T extends RoleDeleteArgs>(
      args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>,
    ): Prisma__RoleClient<
      $Result.GetResult<
        Prisma.$RolePayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends RoleUpdateArgs>(
      args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>,
    ): Prisma__RoleClient<
      $Result.GetResult<
        Prisma.$RolePayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends RoleDeleteManyArgs>(
      args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends RoleUpdateManyArgs>(
      args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(
      args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>,
    ): Prisma__RoleClient<
      $Result.GetResult<
        Prisma.$RolePayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
     **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends RoleAggregateArgs>(
      args: Subset<T, RoleAggregateArgs>,
    ): Prisma.PrismaPromise<GetRoleAggregateType<T>>;

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetRoleGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Role model
     */
    readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    usuarios<T extends Role$usuariosArgs<ExtArgs> = {}>(
      args?: Subset<T, Role$usuariosArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$UsuarioRolPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Role model
   */
  interface RoleFieldRefs {
    readonly id: FieldRef<'Role', 'Int'>;
    readonly slug: FieldRef<'Role', 'String'>;
    readonly name: FieldRef<'Role', 'String'>;
    readonly createdAt: FieldRef<'Role', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput;
  };

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput;
  };

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Roles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[];
  };

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Roles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[];
  };

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Roles.
     */
    skip?: number;
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[];
  };

  /**
   * Role create
   */
  export type RoleCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>;
  };

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Role update
   */
  export type RoleUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>;
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput;
  };

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>;
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput;
    /**
     * Limit how many Roles to update.
     */
    limit?: number;
  };

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput;
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>;
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>;
  };

  /**
   * Role delete
   */
  export type RoleDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput;
  };

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput;
    /**
     * Limit how many Roles to delete.
     */
    limit?: number;
  };

  /**
   * Role.usuarios
   */
  export type Role$usuariosArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UsuarioRol
     */
    select?: UsuarioRolSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UsuarioRol
     */
    omit?: UsuarioRolOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioRolInclude<ExtArgs> | null;
    where?: UsuarioRolWhereInput;
    orderBy?:
      | UsuarioRolOrderByWithRelationInput
      | UsuarioRolOrderByWithRelationInput[];
    cursor?: UsuarioRolWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: UsuarioRolScalarFieldEnum | UsuarioRolScalarFieldEnum[];
  };

  /**
   * Role without action
   */
  export type RoleDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
  };

  /**
   * Model UsuarioRol
   */

  export type AggregateUsuarioRol = {
    _count: UsuarioRolCountAggregateOutputType | null;
    _avg: UsuarioRolAvgAggregateOutputType | null;
    _sum: UsuarioRolSumAggregateOutputType | null;
    _min: UsuarioRolMinAggregateOutputType | null;
    _max: UsuarioRolMaxAggregateOutputType | null;
  };

  export type UsuarioRolAvgAggregateOutputType = {
    usuarioId: number | null;
    roleId: number | null;
  };

  export type UsuarioRolSumAggregateOutputType = {
    usuarioId: number | null;
    roleId: number | null;
  };

  export type UsuarioRolMinAggregateOutputType = {
    usuarioId: number | null;
    roleId: number | null;
  };

  export type UsuarioRolMaxAggregateOutputType = {
    usuarioId: number | null;
    roleId: number | null;
  };

  export type UsuarioRolCountAggregateOutputType = {
    usuarioId: number;
    roleId: number;
    _all: number;
  };

  export type UsuarioRolAvgAggregateInputType = {
    usuarioId?: true;
    roleId?: true;
  };

  export type UsuarioRolSumAggregateInputType = {
    usuarioId?: true;
    roleId?: true;
  };

  export type UsuarioRolMinAggregateInputType = {
    usuarioId?: true;
    roleId?: true;
  };

  export type UsuarioRolMaxAggregateInputType = {
    usuarioId?: true;
    roleId?: true;
  };

  export type UsuarioRolCountAggregateInputType = {
    usuarioId?: true;
    roleId?: true;
    _all?: true;
  };

  export type UsuarioRolAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which UsuarioRol to aggregate.
     */
    where?: UsuarioRolWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UsuarioRols to fetch.
     */
    orderBy?:
      | UsuarioRolOrderByWithRelationInput
      | UsuarioRolOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: UsuarioRolWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UsuarioRols from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UsuarioRols.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned UsuarioRols
     **/
    _count?: true | UsuarioRolCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: UsuarioRolAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: UsuarioRolSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: UsuarioRolMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: UsuarioRolMaxAggregateInputType;
  };

  export type GetUsuarioRolAggregateType<T extends UsuarioRolAggregateArgs> = {
    [P in keyof T & keyof AggregateUsuarioRol]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuarioRol[P]>
      : GetScalarType<T[P], AggregateUsuarioRol[P]>;
  };

  export type UsuarioRolGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: UsuarioRolWhereInput;
    orderBy?:
      | UsuarioRolOrderByWithAggregationInput
      | UsuarioRolOrderByWithAggregationInput[];
    by: UsuarioRolScalarFieldEnum[] | UsuarioRolScalarFieldEnum;
    having?: UsuarioRolScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: UsuarioRolCountAggregateInputType | true;
    _avg?: UsuarioRolAvgAggregateInputType;
    _sum?: UsuarioRolSumAggregateInputType;
    _min?: UsuarioRolMinAggregateInputType;
    _max?: UsuarioRolMaxAggregateInputType;
  };

  export type UsuarioRolGroupByOutputType = {
    usuarioId: number;
    roleId: number;
    _count: UsuarioRolCountAggregateOutputType | null;
    _avg: UsuarioRolAvgAggregateOutputType | null;
    _sum: UsuarioRolSumAggregateOutputType | null;
    _min: UsuarioRolMinAggregateOutputType | null;
    _max: UsuarioRolMaxAggregateOutputType | null;
  };

  type GetUsuarioRolGroupByPayload<T extends UsuarioRolGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<UsuarioRolGroupByOutputType, T['by']> & {
          [P in keyof T & keyof UsuarioRolGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuarioRolGroupByOutputType[P]>
            : GetScalarType<T[P], UsuarioRolGroupByOutputType[P]>;
        }
      >
    >;

  export type UsuarioRolSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      usuarioId?: boolean;
      roleId?: boolean;
      usuario?: boolean | UsuarioDefaultArgs<ExtArgs>;
      role?: boolean | RoleDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['usuarioRol']
  >;

  export type UsuarioRolSelectScalar = {
    usuarioId?: boolean;
    roleId?: boolean;
  };

  export type UsuarioRolOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    'usuarioId' | 'roleId',
    ExtArgs['result']['usuarioRol']
  >;
  export type UsuarioRolInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>;
    role?: boolean | RoleDefaultArgs<ExtArgs>;
  };

  export type $UsuarioRolPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'UsuarioRol';
    objects: {
      usuario: Prisma.$UsuarioPayload<ExtArgs>;
      role: Prisma.$RolePayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        usuarioId: number;
        roleId: number;
      },
      ExtArgs['result']['usuarioRol']
    >;
    composites: {};
  };

  type UsuarioRolGetPayload<
    S extends boolean | null | undefined | UsuarioRolDefaultArgs,
  > = $Result.GetResult<Prisma.$UsuarioRolPayload, S>;

  type UsuarioRolCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    UsuarioRolFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: UsuarioRolCountAggregateInputType | true;
  };

  export interface UsuarioRolDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['UsuarioRol'];
      meta: { name: 'UsuarioRol' };
    };
    /**
     * Find zero or one UsuarioRol that matches the filter.
     * @param {UsuarioRolFindUniqueArgs} args - Arguments to find a UsuarioRol
     * @example
     * // Get one UsuarioRol
     * const usuarioRol = await prisma.usuarioRol.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsuarioRolFindUniqueArgs>(
      args: SelectSubset<T, UsuarioRolFindUniqueArgs<ExtArgs>>,
    ): Prisma__UsuarioRolClient<
      $Result.GetResult<
        Prisma.$UsuarioRolPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one UsuarioRol that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UsuarioRolFindUniqueOrThrowArgs} args - Arguments to find a UsuarioRol
     * @example
     * // Get one UsuarioRol
     * const usuarioRol = await prisma.usuarioRol.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsuarioRolFindUniqueOrThrowArgs>(
      args: SelectSubset<T, UsuarioRolFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__UsuarioRolClient<
      $Result.GetResult<
        Prisma.$UsuarioRolPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first UsuarioRol that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioRolFindFirstArgs} args - Arguments to find a UsuarioRol
     * @example
     * // Get one UsuarioRol
     * const usuarioRol = await prisma.usuarioRol.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsuarioRolFindFirstArgs>(
      args?: SelectSubset<T, UsuarioRolFindFirstArgs<ExtArgs>>,
    ): Prisma__UsuarioRolClient<
      $Result.GetResult<
        Prisma.$UsuarioRolPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first UsuarioRol that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioRolFindFirstOrThrowArgs} args - Arguments to find a UsuarioRol
     * @example
     * // Get one UsuarioRol
     * const usuarioRol = await prisma.usuarioRol.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsuarioRolFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UsuarioRolFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__UsuarioRolClient<
      $Result.GetResult<
        Prisma.$UsuarioRolPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more UsuarioRols that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioRolFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UsuarioRols
     * const usuarioRols = await prisma.usuarioRol.findMany()
     *
     * // Get first 10 UsuarioRols
     * const usuarioRols = await prisma.usuarioRol.findMany({ take: 10 })
     *
     * // Only select the `usuarioId`
     * const usuarioRolWithUsuarioIdOnly = await prisma.usuarioRol.findMany({ select: { usuarioId: true } })
     *
     */
    findMany<T extends UsuarioRolFindManyArgs>(
      args?: SelectSubset<T, UsuarioRolFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UsuarioRolPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a UsuarioRol.
     * @param {UsuarioRolCreateArgs} args - Arguments to create a UsuarioRol.
     * @example
     * // Create one UsuarioRol
     * const UsuarioRol = await prisma.usuarioRol.create({
     *   data: {
     *     // ... data to create a UsuarioRol
     *   }
     * })
     *
     */
    create<T extends UsuarioRolCreateArgs>(
      args: SelectSubset<T, UsuarioRolCreateArgs<ExtArgs>>,
    ): Prisma__UsuarioRolClient<
      $Result.GetResult<
        Prisma.$UsuarioRolPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many UsuarioRols.
     * @param {UsuarioRolCreateManyArgs} args - Arguments to create many UsuarioRols.
     * @example
     * // Create many UsuarioRols
     * const usuarioRol = await prisma.usuarioRol.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends UsuarioRolCreateManyArgs>(
      args?: SelectSubset<T, UsuarioRolCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a UsuarioRol.
     * @param {UsuarioRolDeleteArgs} args - Arguments to delete one UsuarioRol.
     * @example
     * // Delete one UsuarioRol
     * const UsuarioRol = await prisma.usuarioRol.delete({
     *   where: {
     *     // ... filter to delete one UsuarioRol
     *   }
     * })
     *
     */
    delete<T extends UsuarioRolDeleteArgs>(
      args: SelectSubset<T, UsuarioRolDeleteArgs<ExtArgs>>,
    ): Prisma__UsuarioRolClient<
      $Result.GetResult<
        Prisma.$UsuarioRolPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one UsuarioRol.
     * @param {UsuarioRolUpdateArgs} args - Arguments to update one UsuarioRol.
     * @example
     * // Update one UsuarioRol
     * const usuarioRol = await prisma.usuarioRol.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends UsuarioRolUpdateArgs>(
      args: SelectSubset<T, UsuarioRolUpdateArgs<ExtArgs>>,
    ): Prisma__UsuarioRolClient<
      $Result.GetResult<
        Prisma.$UsuarioRolPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more UsuarioRols.
     * @param {UsuarioRolDeleteManyArgs} args - Arguments to filter UsuarioRols to delete.
     * @example
     * // Delete a few UsuarioRols
     * const { count } = await prisma.usuarioRol.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends UsuarioRolDeleteManyArgs>(
      args?: SelectSubset<T, UsuarioRolDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more UsuarioRols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioRolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UsuarioRols
     * const usuarioRol = await prisma.usuarioRol.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends UsuarioRolUpdateManyArgs>(
      args: SelectSubset<T, UsuarioRolUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one UsuarioRol.
     * @param {UsuarioRolUpsertArgs} args - Arguments to update or create a UsuarioRol.
     * @example
     * // Update or create a UsuarioRol
     * const usuarioRol = await prisma.usuarioRol.upsert({
     *   create: {
     *     // ... data to create a UsuarioRol
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UsuarioRol we want to update
     *   }
     * })
     */
    upsert<T extends UsuarioRolUpsertArgs>(
      args: SelectSubset<T, UsuarioRolUpsertArgs<ExtArgs>>,
    ): Prisma__UsuarioRolClient<
      $Result.GetResult<
        Prisma.$UsuarioRolPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of UsuarioRols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioRolCountArgs} args - Arguments to filter UsuarioRols to count.
     * @example
     * // Count the number of UsuarioRols
     * const count = await prisma.usuarioRol.count({
     *   where: {
     *     // ... the filter for the UsuarioRols we want to count
     *   }
     * })
     **/
    count<T extends UsuarioRolCountArgs>(
      args?: Subset<T, UsuarioRolCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuarioRolCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a UsuarioRol.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioRolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends UsuarioRolAggregateArgs>(
      args: Subset<T, UsuarioRolAggregateArgs>,
    ): Prisma.PrismaPromise<GetUsuarioRolAggregateType<T>>;

    /**
     * Group by UsuarioRol.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioRolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends UsuarioRolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsuarioRolGroupByArgs['orderBy'] }
        : { orderBy?: UsuarioRolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, UsuarioRolGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetUsuarioRolGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the UsuarioRol model
     */
    readonly fields: UsuarioRolFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UsuarioRol.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsuarioRolClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>,
    ): Prisma__UsuarioClient<
      | $Result.GetResult<
          Prisma.$UsuarioPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, RoleDefaultArgs<ExtArgs>>,
    ): Prisma__RoleClient<
      | $Result.GetResult<
          Prisma.$RolePayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the UsuarioRol model
   */
  interface UsuarioRolFieldRefs {
    readonly usuarioId: FieldRef<'UsuarioRol', 'Int'>;
    readonly roleId: FieldRef<'UsuarioRol', 'Int'>;
  }

  // Custom InputTypes
  /**
   * UsuarioRol findUnique
   */
  export type UsuarioRolFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UsuarioRol
     */
    select?: UsuarioRolSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UsuarioRol
     */
    omit?: UsuarioRolOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioRolInclude<ExtArgs> | null;
    /**
     * Filter, which UsuarioRol to fetch.
     */
    where: UsuarioRolWhereUniqueInput;
  };

  /**
   * UsuarioRol findUniqueOrThrow
   */
  export type UsuarioRolFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UsuarioRol
     */
    select?: UsuarioRolSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UsuarioRol
     */
    omit?: UsuarioRolOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioRolInclude<ExtArgs> | null;
    /**
     * Filter, which UsuarioRol to fetch.
     */
    where: UsuarioRolWhereUniqueInput;
  };

  /**
   * UsuarioRol findFirst
   */
  export type UsuarioRolFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UsuarioRol
     */
    select?: UsuarioRolSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UsuarioRol
     */
    omit?: UsuarioRolOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioRolInclude<ExtArgs> | null;
    /**
     * Filter, which UsuarioRol to fetch.
     */
    where?: UsuarioRolWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UsuarioRols to fetch.
     */
    orderBy?:
      | UsuarioRolOrderByWithRelationInput
      | UsuarioRolOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for UsuarioRols.
     */
    cursor?: UsuarioRolWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UsuarioRols from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UsuarioRols.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of UsuarioRols.
     */
    distinct?: UsuarioRolScalarFieldEnum | UsuarioRolScalarFieldEnum[];
  };

  /**
   * UsuarioRol findFirstOrThrow
   */
  export type UsuarioRolFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UsuarioRol
     */
    select?: UsuarioRolSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UsuarioRol
     */
    omit?: UsuarioRolOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioRolInclude<ExtArgs> | null;
    /**
     * Filter, which UsuarioRol to fetch.
     */
    where?: UsuarioRolWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UsuarioRols to fetch.
     */
    orderBy?:
      | UsuarioRolOrderByWithRelationInput
      | UsuarioRolOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for UsuarioRols.
     */
    cursor?: UsuarioRolWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UsuarioRols from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UsuarioRols.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of UsuarioRols.
     */
    distinct?: UsuarioRolScalarFieldEnum | UsuarioRolScalarFieldEnum[];
  };

  /**
   * UsuarioRol findMany
   */
  export type UsuarioRolFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UsuarioRol
     */
    select?: UsuarioRolSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UsuarioRol
     */
    omit?: UsuarioRolOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioRolInclude<ExtArgs> | null;
    /**
     * Filter, which UsuarioRols to fetch.
     */
    where?: UsuarioRolWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UsuarioRols to fetch.
     */
    orderBy?:
      | UsuarioRolOrderByWithRelationInput
      | UsuarioRolOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing UsuarioRols.
     */
    cursor?: UsuarioRolWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UsuarioRols from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UsuarioRols.
     */
    skip?: number;
    distinct?: UsuarioRolScalarFieldEnum | UsuarioRolScalarFieldEnum[];
  };

  /**
   * UsuarioRol create
   */
  export type UsuarioRolCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UsuarioRol
     */
    select?: UsuarioRolSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UsuarioRol
     */
    omit?: UsuarioRolOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioRolInclude<ExtArgs> | null;
    /**
     * The data needed to create a UsuarioRol.
     */
    data: XOR<UsuarioRolCreateInput, UsuarioRolUncheckedCreateInput>;
  };

  /**
   * UsuarioRol createMany
   */
  export type UsuarioRolCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many UsuarioRols.
     */
    data: UsuarioRolCreateManyInput | UsuarioRolCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * UsuarioRol update
   */
  export type UsuarioRolUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UsuarioRol
     */
    select?: UsuarioRolSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UsuarioRol
     */
    omit?: UsuarioRolOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioRolInclude<ExtArgs> | null;
    /**
     * The data needed to update a UsuarioRol.
     */
    data: XOR<UsuarioRolUpdateInput, UsuarioRolUncheckedUpdateInput>;
    /**
     * Choose, which UsuarioRol to update.
     */
    where: UsuarioRolWhereUniqueInput;
  };

  /**
   * UsuarioRol updateMany
   */
  export type UsuarioRolUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update UsuarioRols.
     */
    data: XOR<
      UsuarioRolUpdateManyMutationInput,
      UsuarioRolUncheckedUpdateManyInput
    >;
    /**
     * Filter which UsuarioRols to update
     */
    where?: UsuarioRolWhereInput;
    /**
     * Limit how many UsuarioRols to update.
     */
    limit?: number;
  };

  /**
   * UsuarioRol upsert
   */
  export type UsuarioRolUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UsuarioRol
     */
    select?: UsuarioRolSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UsuarioRol
     */
    omit?: UsuarioRolOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioRolInclude<ExtArgs> | null;
    /**
     * The filter to search for the UsuarioRol to update in case it exists.
     */
    where: UsuarioRolWhereUniqueInput;
    /**
     * In case the UsuarioRol found by the `where` argument doesn't exist, create a new UsuarioRol with this data.
     */
    create: XOR<UsuarioRolCreateInput, UsuarioRolUncheckedCreateInput>;
    /**
     * In case the UsuarioRol was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsuarioRolUpdateInput, UsuarioRolUncheckedUpdateInput>;
  };

  /**
   * UsuarioRol delete
   */
  export type UsuarioRolDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UsuarioRol
     */
    select?: UsuarioRolSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UsuarioRol
     */
    omit?: UsuarioRolOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioRolInclude<ExtArgs> | null;
    /**
     * Filter which UsuarioRol to delete.
     */
    where: UsuarioRolWhereUniqueInput;
  };

  /**
   * UsuarioRol deleteMany
   */
  export type UsuarioRolDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which UsuarioRols to delete
     */
    where?: UsuarioRolWhereInput;
    /**
     * Limit how many UsuarioRols to delete.
     */
    limit?: number;
  };

  /**
   * UsuarioRol without action
   */
  export type UsuarioRolDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UsuarioRol
     */
    select?: UsuarioRolSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UsuarioRol
     */
    omit?: UsuarioRolOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioRolInclude<ExtArgs> | null;
  };

  /**
   * Model Favorito
   */

  export type AggregateFavorito = {
    _count: FavoritoCountAggregateOutputType | null;
    _avg: FavoritoAvgAggregateOutputType | null;
    _sum: FavoritoSumAggregateOutputType | null;
    _min: FavoritoMinAggregateOutputType | null;
    _max: FavoritoMaxAggregateOutputType | null;
  };

  export type FavoritoAvgAggregateOutputType = {
    id: number | null;
    usuarioId: number | null;
    productoId: number | null;
  };

  export type FavoritoSumAggregateOutputType = {
    id: number | null;
    usuarioId: number | null;
    productoId: number | null;
  };

  export type FavoritoMinAggregateOutputType = {
    id: number | null;
    usuarioId: number | null;
    productoId: number | null;
    creadoEn: Date | null;
  };

  export type FavoritoMaxAggregateOutputType = {
    id: number | null;
    usuarioId: number | null;
    productoId: number | null;
    creadoEn: Date | null;
  };

  export type FavoritoCountAggregateOutputType = {
    id: number;
    usuarioId: number;
    productoId: number;
    creadoEn: number;
    _all: number;
  };

  export type FavoritoAvgAggregateInputType = {
    id?: true;
    usuarioId?: true;
    productoId?: true;
  };

  export type FavoritoSumAggregateInputType = {
    id?: true;
    usuarioId?: true;
    productoId?: true;
  };

  export type FavoritoMinAggregateInputType = {
    id?: true;
    usuarioId?: true;
    productoId?: true;
    creadoEn?: true;
  };

  export type FavoritoMaxAggregateInputType = {
    id?: true;
    usuarioId?: true;
    productoId?: true;
    creadoEn?: true;
  };

  export type FavoritoCountAggregateInputType = {
    id?: true;
    usuarioId?: true;
    productoId?: true;
    creadoEn?: true;
    _all?: true;
  };

  export type FavoritoAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Favorito to aggregate.
     */
    where?: FavoritoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Favoritos to fetch.
     */
    orderBy?:
      | FavoritoOrderByWithRelationInput
      | FavoritoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: FavoritoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Favoritos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Favoritos.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Favoritos
     **/
    _count?: true | FavoritoCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: FavoritoAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: FavoritoSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: FavoritoMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: FavoritoMaxAggregateInputType;
  };

  export type GetFavoritoAggregateType<T extends FavoritoAggregateArgs> = {
    [P in keyof T & keyof AggregateFavorito]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFavorito[P]>
      : GetScalarType<T[P], AggregateFavorito[P]>;
  };

  export type FavoritoGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: FavoritoWhereInput;
    orderBy?:
      | FavoritoOrderByWithAggregationInput
      | FavoritoOrderByWithAggregationInput[];
    by: FavoritoScalarFieldEnum[] | FavoritoScalarFieldEnum;
    having?: FavoritoScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: FavoritoCountAggregateInputType | true;
    _avg?: FavoritoAvgAggregateInputType;
    _sum?: FavoritoSumAggregateInputType;
    _min?: FavoritoMinAggregateInputType;
    _max?: FavoritoMaxAggregateInputType;
  };

  export type FavoritoGroupByOutputType = {
    id: number;
    usuarioId: number;
    productoId: number;
    creadoEn: Date;
    _count: FavoritoCountAggregateOutputType | null;
    _avg: FavoritoAvgAggregateOutputType | null;
    _sum: FavoritoSumAggregateOutputType | null;
    _min: FavoritoMinAggregateOutputType | null;
    _max: FavoritoMaxAggregateOutputType | null;
  };

  type GetFavoritoGroupByPayload<T extends FavoritoGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<FavoritoGroupByOutputType, T['by']> & {
          [P in keyof T & keyof FavoritoGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FavoritoGroupByOutputType[P]>
            : GetScalarType<T[P], FavoritoGroupByOutputType[P]>;
        }
      >
    >;

  export type FavoritoSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      usuarioId?: boolean;
      productoId?: boolean;
      creadoEn?: boolean;
      usuario?: boolean | UsuarioDefaultArgs<ExtArgs>;
      producto?: boolean | ProductoDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['favorito']
  >;

  export type FavoritoSelectScalar = {
    id?: boolean;
    usuarioId?: boolean;
    productoId?: boolean;
    creadoEn?: boolean;
  };

  export type FavoritoOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    'id' | 'usuarioId' | 'productoId' | 'creadoEn',
    ExtArgs['result']['favorito']
  >;
  export type FavoritoInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>;
    producto?: boolean | ProductoDefaultArgs<ExtArgs>;
  };

  export type $FavoritoPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Favorito';
    objects: {
      usuario: Prisma.$UsuarioPayload<ExtArgs>;
      producto: Prisma.$ProductoPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        usuarioId: number;
        productoId: number;
        creadoEn: Date;
      },
      ExtArgs['result']['favorito']
    >;
    composites: {};
  };

  type FavoritoGetPayload<
    S extends boolean | null | undefined | FavoritoDefaultArgs,
  > = $Result.GetResult<Prisma.$FavoritoPayload, S>;

  type FavoritoCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<FavoritoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: FavoritoCountAggregateInputType | true;
  };

  export interface FavoritoDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Favorito'];
      meta: { name: 'Favorito' };
    };
    /**
     * Find zero or one Favorito that matches the filter.
     * @param {FavoritoFindUniqueArgs} args - Arguments to find a Favorito
     * @example
     * // Get one Favorito
     * const favorito = await prisma.favorito.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FavoritoFindUniqueArgs>(
      args: SelectSubset<T, FavoritoFindUniqueArgs<ExtArgs>>,
    ): Prisma__FavoritoClient<
      $Result.GetResult<
        Prisma.$FavoritoPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Favorito that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FavoritoFindUniqueOrThrowArgs} args - Arguments to find a Favorito
     * @example
     * // Get one Favorito
     * const favorito = await prisma.favorito.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FavoritoFindUniqueOrThrowArgs>(
      args: SelectSubset<T, FavoritoFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__FavoritoClient<
      $Result.GetResult<
        Prisma.$FavoritoPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Favorito that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoritoFindFirstArgs} args - Arguments to find a Favorito
     * @example
     * // Get one Favorito
     * const favorito = await prisma.favorito.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FavoritoFindFirstArgs>(
      args?: SelectSubset<T, FavoritoFindFirstArgs<ExtArgs>>,
    ): Prisma__FavoritoClient<
      $Result.GetResult<
        Prisma.$FavoritoPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Favorito that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoritoFindFirstOrThrowArgs} args - Arguments to find a Favorito
     * @example
     * // Get one Favorito
     * const favorito = await prisma.favorito.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FavoritoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FavoritoFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__FavoritoClient<
      $Result.GetResult<
        Prisma.$FavoritoPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Favoritos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoritoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Favoritos
     * const favoritos = await prisma.favorito.findMany()
     *
     * // Get first 10 Favoritos
     * const favoritos = await prisma.favorito.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const favoritoWithIdOnly = await prisma.favorito.findMany({ select: { id: true } })
     *
     */
    findMany<T extends FavoritoFindManyArgs>(
      args?: SelectSubset<T, FavoritoFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FavoritoPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Favorito.
     * @param {FavoritoCreateArgs} args - Arguments to create a Favorito.
     * @example
     * // Create one Favorito
     * const Favorito = await prisma.favorito.create({
     *   data: {
     *     // ... data to create a Favorito
     *   }
     * })
     *
     */
    create<T extends FavoritoCreateArgs>(
      args: SelectSubset<T, FavoritoCreateArgs<ExtArgs>>,
    ): Prisma__FavoritoClient<
      $Result.GetResult<
        Prisma.$FavoritoPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Favoritos.
     * @param {FavoritoCreateManyArgs} args - Arguments to create many Favoritos.
     * @example
     * // Create many Favoritos
     * const favorito = await prisma.favorito.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends FavoritoCreateManyArgs>(
      args?: SelectSubset<T, FavoritoCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Favorito.
     * @param {FavoritoDeleteArgs} args - Arguments to delete one Favorito.
     * @example
     * // Delete one Favorito
     * const Favorito = await prisma.favorito.delete({
     *   where: {
     *     // ... filter to delete one Favorito
     *   }
     * })
     *
     */
    delete<T extends FavoritoDeleteArgs>(
      args: SelectSubset<T, FavoritoDeleteArgs<ExtArgs>>,
    ): Prisma__FavoritoClient<
      $Result.GetResult<
        Prisma.$FavoritoPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Favorito.
     * @param {FavoritoUpdateArgs} args - Arguments to update one Favorito.
     * @example
     * // Update one Favorito
     * const favorito = await prisma.favorito.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends FavoritoUpdateArgs>(
      args: SelectSubset<T, FavoritoUpdateArgs<ExtArgs>>,
    ): Prisma__FavoritoClient<
      $Result.GetResult<
        Prisma.$FavoritoPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Favoritos.
     * @param {FavoritoDeleteManyArgs} args - Arguments to filter Favoritos to delete.
     * @example
     * // Delete a few Favoritos
     * const { count } = await prisma.favorito.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends FavoritoDeleteManyArgs>(
      args?: SelectSubset<T, FavoritoDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Favoritos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoritoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Favoritos
     * const favorito = await prisma.favorito.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends FavoritoUpdateManyArgs>(
      args: SelectSubset<T, FavoritoUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Favorito.
     * @param {FavoritoUpsertArgs} args - Arguments to update or create a Favorito.
     * @example
     * // Update or create a Favorito
     * const favorito = await prisma.favorito.upsert({
     *   create: {
     *     // ... data to create a Favorito
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Favorito we want to update
     *   }
     * })
     */
    upsert<T extends FavoritoUpsertArgs>(
      args: SelectSubset<T, FavoritoUpsertArgs<ExtArgs>>,
    ): Prisma__FavoritoClient<
      $Result.GetResult<
        Prisma.$FavoritoPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Favoritos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoritoCountArgs} args - Arguments to filter Favoritos to count.
     * @example
     * // Count the number of Favoritos
     * const count = await prisma.favorito.count({
     *   where: {
     *     // ... the filter for the Favoritos we want to count
     *   }
     * })
     **/
    count<T extends FavoritoCountArgs>(
      args?: Subset<T, FavoritoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FavoritoCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Favorito.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoritoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends FavoritoAggregateArgs>(
      args: Subset<T, FavoritoAggregateArgs>,
    ): Prisma.PrismaPromise<GetFavoritoAggregateType<T>>;

    /**
     * Group by Favorito.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoritoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends FavoritoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FavoritoGroupByArgs['orderBy'] }
        : { orderBy?: FavoritoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, FavoritoGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetFavoritoGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Favorito model
     */
    readonly fields: FavoritoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Favorito.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FavoritoClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>,
    ): Prisma__UsuarioClient<
      | $Result.GetResult<
          Prisma.$UsuarioPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    producto<T extends ProductoDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, ProductoDefaultArgs<ExtArgs>>,
    ): Prisma__ProductoClient<
      | $Result.GetResult<
          Prisma.$ProductoPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Favorito model
   */
  interface FavoritoFieldRefs {
    readonly id: FieldRef<'Favorito', 'Int'>;
    readonly usuarioId: FieldRef<'Favorito', 'Int'>;
    readonly productoId: FieldRef<'Favorito', 'Int'>;
    readonly creadoEn: FieldRef<'Favorito', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Favorito findUnique
   */
  export type FavoritoFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Favorito
     */
    select?: FavoritoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Favorito
     */
    omit?: FavoritoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoritoInclude<ExtArgs> | null;
    /**
     * Filter, which Favorito to fetch.
     */
    where: FavoritoWhereUniqueInput;
  };

  /**
   * Favorito findUniqueOrThrow
   */
  export type FavoritoFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Favorito
     */
    select?: FavoritoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Favorito
     */
    omit?: FavoritoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoritoInclude<ExtArgs> | null;
    /**
     * Filter, which Favorito to fetch.
     */
    where: FavoritoWhereUniqueInput;
  };

  /**
   * Favorito findFirst
   */
  export type FavoritoFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Favorito
     */
    select?: FavoritoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Favorito
     */
    omit?: FavoritoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoritoInclude<ExtArgs> | null;
    /**
     * Filter, which Favorito to fetch.
     */
    where?: FavoritoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Favoritos to fetch.
     */
    orderBy?:
      | FavoritoOrderByWithRelationInput
      | FavoritoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Favoritos.
     */
    cursor?: FavoritoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Favoritos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Favoritos.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Favoritos.
     */
    distinct?: FavoritoScalarFieldEnum | FavoritoScalarFieldEnum[];
  };

  /**
   * Favorito findFirstOrThrow
   */
  export type FavoritoFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Favorito
     */
    select?: FavoritoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Favorito
     */
    omit?: FavoritoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoritoInclude<ExtArgs> | null;
    /**
     * Filter, which Favorito to fetch.
     */
    where?: FavoritoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Favoritos to fetch.
     */
    orderBy?:
      | FavoritoOrderByWithRelationInput
      | FavoritoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Favoritos.
     */
    cursor?: FavoritoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Favoritos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Favoritos.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Favoritos.
     */
    distinct?: FavoritoScalarFieldEnum | FavoritoScalarFieldEnum[];
  };

  /**
   * Favorito findMany
   */
  export type FavoritoFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Favorito
     */
    select?: FavoritoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Favorito
     */
    omit?: FavoritoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoritoInclude<ExtArgs> | null;
    /**
     * Filter, which Favoritos to fetch.
     */
    where?: FavoritoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Favoritos to fetch.
     */
    orderBy?:
      | FavoritoOrderByWithRelationInput
      | FavoritoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Favoritos.
     */
    cursor?: FavoritoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Favoritos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Favoritos.
     */
    skip?: number;
    distinct?: FavoritoScalarFieldEnum | FavoritoScalarFieldEnum[];
  };

  /**
   * Favorito create
   */
  export type FavoritoCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Favorito
     */
    select?: FavoritoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Favorito
     */
    omit?: FavoritoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoritoInclude<ExtArgs> | null;
    /**
     * The data needed to create a Favorito.
     */
    data: XOR<FavoritoCreateInput, FavoritoUncheckedCreateInput>;
  };

  /**
   * Favorito createMany
   */
  export type FavoritoCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Favoritos.
     */
    data: FavoritoCreateManyInput | FavoritoCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Favorito update
   */
  export type FavoritoUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Favorito
     */
    select?: FavoritoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Favorito
     */
    omit?: FavoritoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoritoInclude<ExtArgs> | null;
    /**
     * The data needed to update a Favorito.
     */
    data: XOR<FavoritoUpdateInput, FavoritoUncheckedUpdateInput>;
    /**
     * Choose, which Favorito to update.
     */
    where: FavoritoWhereUniqueInput;
  };

  /**
   * Favorito updateMany
   */
  export type FavoritoUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Favoritos.
     */
    data: XOR<
      FavoritoUpdateManyMutationInput,
      FavoritoUncheckedUpdateManyInput
    >;
    /**
     * Filter which Favoritos to update
     */
    where?: FavoritoWhereInput;
    /**
     * Limit how many Favoritos to update.
     */
    limit?: number;
  };

  /**
   * Favorito upsert
   */
  export type FavoritoUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Favorito
     */
    select?: FavoritoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Favorito
     */
    omit?: FavoritoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoritoInclude<ExtArgs> | null;
    /**
     * The filter to search for the Favorito to update in case it exists.
     */
    where: FavoritoWhereUniqueInput;
    /**
     * In case the Favorito found by the `where` argument doesn't exist, create a new Favorito with this data.
     */
    create: XOR<FavoritoCreateInput, FavoritoUncheckedCreateInput>;
    /**
     * In case the Favorito was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FavoritoUpdateInput, FavoritoUncheckedUpdateInput>;
  };

  /**
   * Favorito delete
   */
  export type FavoritoDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Favorito
     */
    select?: FavoritoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Favorito
     */
    omit?: FavoritoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoritoInclude<ExtArgs> | null;
    /**
     * Filter which Favorito to delete.
     */
    where: FavoritoWhereUniqueInput;
  };

  /**
   * Favorito deleteMany
   */
  export type FavoritoDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Favoritos to delete
     */
    where?: FavoritoWhereInput;
    /**
     * Limit how many Favoritos to delete.
     */
    limit?: number;
  };

  /**
   * Favorito without action
   */
  export type FavoritoDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Favorito
     */
    select?: FavoritoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Favorito
     */
    omit?: FavoritoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoritoInclude<ExtArgs> | null;
  };

  /**
   * Model Curso
   */

  export type AggregateCurso = {
    _count: CursoCountAggregateOutputType | null;
    _avg: CursoAvgAggregateOutputType | null;
    _sum: CursoSumAggregateOutputType | null;
    _min: CursoMinAggregateOutputType | null;
    _max: CursoMaxAggregateOutputType | null;
  };

  export type CursoAvgAggregateOutputType = {
    id: number | null;
    precio: number | null;
    ratingProm: Decimal | null;
    ratingConteo: number | null;
    instructorId: number | null;
  };

  export type CursoSumAggregateOutputType = {
    id: number | null;
    precio: number | null;
    ratingProm: Decimal | null;
    ratingConteo: number | null;
    instructorId: number | null;
  };

  export type CursoMinAggregateOutputType = {
    id: number | null;
    slug: string | null;
    titulo: string | null;
    resumen: string | null;
    descripcionMD: string | null;
    requisitos: string | null;
    precio: number | null;
    publicado: boolean | null;
    nivel: $Enums.NivelCurso | null;
    portada: string | null;
    destacado: boolean | null;
    ratingProm: Decimal | null;
    ratingConteo: number | null;
    creadoEn: Date | null;
    instructorId: number | null;
  };

  export type CursoMaxAggregateOutputType = {
    id: number | null;
    slug: string | null;
    titulo: string | null;
    resumen: string | null;
    descripcionMD: string | null;
    requisitos: string | null;
    precio: number | null;
    publicado: boolean | null;
    nivel: $Enums.NivelCurso | null;
    portada: string | null;
    destacado: boolean | null;
    ratingProm: Decimal | null;
    ratingConteo: number | null;
    creadoEn: Date | null;
    instructorId: number | null;
  };

  export type CursoCountAggregateOutputType = {
    id: number;
    slug: number;
    titulo: number;
    resumen: number;
    descripcionMD: number;
    requisitos: number;
    precio: number;
    publicado: number;
    nivel: number;
    portada: number;
    destacado: number;
    tags: number;
    ratingProm: number;
    ratingConteo: number;
    creadoEn: number;
    instructorId: number;
    _all: number;
  };

  export type CursoAvgAggregateInputType = {
    id?: true;
    precio?: true;
    ratingProm?: true;
    ratingConteo?: true;
    instructorId?: true;
  };

  export type CursoSumAggregateInputType = {
    id?: true;
    precio?: true;
    ratingProm?: true;
    ratingConteo?: true;
    instructorId?: true;
  };

  export type CursoMinAggregateInputType = {
    id?: true;
    slug?: true;
    titulo?: true;
    resumen?: true;
    descripcionMD?: true;
    requisitos?: true;
    precio?: true;
    publicado?: true;
    nivel?: true;
    portada?: true;
    destacado?: true;
    ratingProm?: true;
    ratingConteo?: true;
    creadoEn?: true;
    instructorId?: true;
  };

  export type CursoMaxAggregateInputType = {
    id?: true;
    slug?: true;
    titulo?: true;
    resumen?: true;
    descripcionMD?: true;
    requisitos?: true;
    precio?: true;
    publicado?: true;
    nivel?: true;
    portada?: true;
    destacado?: true;
    ratingProm?: true;
    ratingConteo?: true;
    creadoEn?: true;
    instructorId?: true;
  };

  export type CursoCountAggregateInputType = {
    id?: true;
    slug?: true;
    titulo?: true;
    resumen?: true;
    descripcionMD?: true;
    requisitos?: true;
    precio?: true;
    publicado?: true;
    nivel?: true;
    portada?: true;
    destacado?: true;
    tags?: true;
    ratingProm?: true;
    ratingConteo?: true;
    creadoEn?: true;
    instructorId?: true;
    _all?: true;
  };

  export type CursoAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Curso to aggregate.
     */
    where?: CursoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Cursos to fetch.
     */
    orderBy?: CursoOrderByWithRelationInput | CursoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: CursoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Cursos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Cursos.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Cursos
     **/
    _count?: true | CursoCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: CursoAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: CursoSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: CursoMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: CursoMaxAggregateInputType;
  };

  export type GetCursoAggregateType<T extends CursoAggregateArgs> = {
    [P in keyof T & keyof AggregateCurso]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCurso[P]>
      : GetScalarType<T[P], AggregateCurso[P]>;
  };

  export type CursoGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: CursoWhereInput;
    orderBy?:
      | CursoOrderByWithAggregationInput
      | CursoOrderByWithAggregationInput[];
    by: CursoScalarFieldEnum[] | CursoScalarFieldEnum;
    having?: CursoScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: CursoCountAggregateInputType | true;
    _avg?: CursoAvgAggregateInputType;
    _sum?: CursoSumAggregateInputType;
    _min?: CursoMinAggregateInputType;
    _max?: CursoMaxAggregateInputType;
  };

  export type CursoGroupByOutputType = {
    id: number;
    slug: string;
    titulo: string;
    resumen: string | null;
    descripcionMD: string | null;
    requisitos: string | null;
    precio: number;
    publicado: boolean;
    nivel: $Enums.NivelCurso;
    portada: string | null;
    destacado: boolean;
    tags: JsonValue | null;
    ratingProm: Decimal | null;
    ratingConteo: number;
    creadoEn: Date;
    instructorId: number | null;
    _count: CursoCountAggregateOutputType | null;
    _avg: CursoAvgAggregateOutputType | null;
    _sum: CursoSumAggregateOutputType | null;
    _min: CursoMinAggregateOutputType | null;
    _max: CursoMaxAggregateOutputType | null;
  };

  type GetCursoGroupByPayload<T extends CursoGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<CursoGroupByOutputType, T['by']> & {
          [P in keyof T & keyof CursoGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CursoGroupByOutputType[P]>
            : GetScalarType<T[P], CursoGroupByOutputType[P]>;
        }
      >
    >;

  export type CursoSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      slug?: boolean;
      titulo?: boolean;
      resumen?: boolean;
      descripcionMD?: boolean;
      requisitos?: boolean;
      precio?: boolean;
      publicado?: boolean;
      nivel?: boolean;
      portada?: boolean;
      destacado?: boolean;
      tags?: boolean;
      ratingProm?: boolean;
      ratingConteo?: boolean;
      creadoEn?: boolean;
      instructorId?: boolean;
      instructor?: boolean | Curso$instructorArgs<ExtArgs>;
      modulos?: boolean | Curso$modulosArgs<ExtArgs>;
      resenas?: boolean | Curso$resenasArgs<ExtArgs>;
      inscripciones?: boolean | Curso$inscripcionesArgs<ExtArgs>;
      itemsCarrito?: boolean | Curso$itemsCarritoArgs<ExtArgs>;
      _count?: boolean | CursoCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['curso']
  >;

  export type CursoSelectScalar = {
    id?: boolean;
    slug?: boolean;
    titulo?: boolean;
    resumen?: boolean;
    descripcionMD?: boolean;
    requisitos?: boolean;
    precio?: boolean;
    publicado?: boolean;
    nivel?: boolean;
    portada?: boolean;
    destacado?: boolean;
    tags?: boolean;
    ratingProm?: boolean;
    ratingConteo?: boolean;
    creadoEn?: boolean;
    instructorId?: boolean;
  };

  export type CursoOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'slug'
    | 'titulo'
    | 'resumen'
    | 'descripcionMD'
    | 'requisitos'
    | 'precio'
    | 'publicado'
    | 'nivel'
    | 'portada'
    | 'destacado'
    | 'tags'
    | 'ratingProm'
    | 'ratingConteo'
    | 'creadoEn'
    | 'instructorId',
    ExtArgs['result']['curso']
  >;
  export type CursoInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    instructor?: boolean | Curso$instructorArgs<ExtArgs>;
    modulos?: boolean | Curso$modulosArgs<ExtArgs>;
    resenas?: boolean | Curso$resenasArgs<ExtArgs>;
    inscripciones?: boolean | Curso$inscripcionesArgs<ExtArgs>;
    itemsCarrito?: boolean | Curso$itemsCarritoArgs<ExtArgs>;
    _count?: boolean | CursoCountOutputTypeDefaultArgs<ExtArgs>;
  };

  export type $CursoPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Curso';
    objects: {
      instructor: Prisma.$UsuarioPayload<ExtArgs> | null;
      modulos: Prisma.$ModuloPayload<ExtArgs>[];
      resenas: Prisma.$ResenaPayload<ExtArgs>[];
      inscripciones: Prisma.$InscripcionPayload<ExtArgs>[];
      itemsCarrito: Prisma.$ItemCarritoPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        slug: string;
        titulo: string;
        resumen: string | null;
        descripcionMD: string | null;
        requisitos: string | null;
        precio: number;
        publicado: boolean;
        nivel: $Enums.NivelCurso;
        portada: string | null;
        destacado: boolean;
        tags: Prisma.JsonValue | null;
        ratingProm: Prisma.Decimal | null;
        ratingConteo: number;
        creadoEn: Date;
        instructorId: number | null;
      },
      ExtArgs['result']['curso']
    >;
    composites: {};
  };

  type CursoGetPayload<
    S extends boolean | null | undefined | CursoDefaultArgs,
  > = $Result.GetResult<Prisma.$CursoPayload, S>;

  type CursoCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<CursoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: CursoCountAggregateInputType | true;
  };

  export interface CursoDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Curso'];
      meta: { name: 'Curso' };
    };
    /**
     * Find zero or one Curso that matches the filter.
     * @param {CursoFindUniqueArgs} args - Arguments to find a Curso
     * @example
     * // Get one Curso
     * const curso = await prisma.curso.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CursoFindUniqueArgs>(
      args: SelectSubset<T, CursoFindUniqueArgs<ExtArgs>>,
    ): Prisma__CursoClient<
      $Result.GetResult<
        Prisma.$CursoPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Curso that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CursoFindUniqueOrThrowArgs} args - Arguments to find a Curso
     * @example
     * // Get one Curso
     * const curso = await prisma.curso.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CursoFindUniqueOrThrowArgs>(
      args: SelectSubset<T, CursoFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__CursoClient<
      $Result.GetResult<
        Prisma.$CursoPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Curso that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursoFindFirstArgs} args - Arguments to find a Curso
     * @example
     * // Get one Curso
     * const curso = await prisma.curso.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CursoFindFirstArgs>(
      args?: SelectSubset<T, CursoFindFirstArgs<ExtArgs>>,
    ): Prisma__CursoClient<
      $Result.GetResult<
        Prisma.$CursoPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Curso that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursoFindFirstOrThrowArgs} args - Arguments to find a Curso
     * @example
     * // Get one Curso
     * const curso = await prisma.curso.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CursoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CursoFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__CursoClient<
      $Result.GetResult<
        Prisma.$CursoPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Cursos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cursos
     * const cursos = await prisma.curso.findMany()
     *
     * // Get first 10 Cursos
     * const cursos = await prisma.curso.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const cursoWithIdOnly = await prisma.curso.findMany({ select: { id: true } })
     *
     */
    findMany<T extends CursoFindManyArgs>(
      args?: SelectSubset<T, CursoFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$CursoPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Curso.
     * @param {CursoCreateArgs} args - Arguments to create a Curso.
     * @example
     * // Create one Curso
     * const Curso = await prisma.curso.create({
     *   data: {
     *     // ... data to create a Curso
     *   }
     * })
     *
     */
    create<T extends CursoCreateArgs>(
      args: SelectSubset<T, CursoCreateArgs<ExtArgs>>,
    ): Prisma__CursoClient<
      $Result.GetResult<
        Prisma.$CursoPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Cursos.
     * @param {CursoCreateManyArgs} args - Arguments to create many Cursos.
     * @example
     * // Create many Cursos
     * const curso = await prisma.curso.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends CursoCreateManyArgs>(
      args?: SelectSubset<T, CursoCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Curso.
     * @param {CursoDeleteArgs} args - Arguments to delete one Curso.
     * @example
     * // Delete one Curso
     * const Curso = await prisma.curso.delete({
     *   where: {
     *     // ... filter to delete one Curso
     *   }
     * })
     *
     */
    delete<T extends CursoDeleteArgs>(
      args: SelectSubset<T, CursoDeleteArgs<ExtArgs>>,
    ): Prisma__CursoClient<
      $Result.GetResult<
        Prisma.$CursoPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Curso.
     * @param {CursoUpdateArgs} args - Arguments to update one Curso.
     * @example
     * // Update one Curso
     * const curso = await prisma.curso.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends CursoUpdateArgs>(
      args: SelectSubset<T, CursoUpdateArgs<ExtArgs>>,
    ): Prisma__CursoClient<
      $Result.GetResult<
        Prisma.$CursoPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Cursos.
     * @param {CursoDeleteManyArgs} args - Arguments to filter Cursos to delete.
     * @example
     * // Delete a few Cursos
     * const { count } = await prisma.curso.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends CursoDeleteManyArgs>(
      args?: SelectSubset<T, CursoDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Cursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cursos
     * const curso = await prisma.curso.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends CursoUpdateManyArgs>(
      args: SelectSubset<T, CursoUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Curso.
     * @param {CursoUpsertArgs} args - Arguments to update or create a Curso.
     * @example
     * // Update or create a Curso
     * const curso = await prisma.curso.upsert({
     *   create: {
     *     // ... data to create a Curso
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Curso we want to update
     *   }
     * })
     */
    upsert<T extends CursoUpsertArgs>(
      args: SelectSubset<T, CursoUpsertArgs<ExtArgs>>,
    ): Prisma__CursoClient<
      $Result.GetResult<
        Prisma.$CursoPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Cursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursoCountArgs} args - Arguments to filter Cursos to count.
     * @example
     * // Count the number of Cursos
     * const count = await prisma.curso.count({
     *   where: {
     *     // ... the filter for the Cursos we want to count
     *   }
     * })
     **/
    count<T extends CursoCountArgs>(
      args?: Subset<T, CursoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CursoCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Curso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends CursoAggregateArgs>(
      args: Subset<T, CursoAggregateArgs>,
    ): Prisma.PrismaPromise<GetCursoAggregateType<T>>;

    /**
     * Group by Curso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends CursoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CursoGroupByArgs['orderBy'] }
        : { orderBy?: CursoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, CursoGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetCursoGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Curso model
     */
    readonly fields: CursoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Curso.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CursoClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    instructor<T extends Curso$instructorArgs<ExtArgs> = {}>(
      args?: Subset<T, Curso$instructorArgs<ExtArgs>>,
    ): Prisma__UsuarioClient<
      $Result.GetResult<
        Prisma.$UsuarioPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    modulos<T extends Curso$modulosArgs<ExtArgs> = {}>(
      args?: Subset<T, Curso$modulosArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$ModuloPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    resenas<T extends Curso$resenasArgs<ExtArgs> = {}>(
      args?: Subset<T, Curso$resenasArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$ResenaPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    inscripciones<T extends Curso$inscripcionesArgs<ExtArgs> = {}>(
      args?: Subset<T, Curso$inscripcionesArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$InscripcionPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    itemsCarrito<T extends Curso$itemsCarritoArgs<ExtArgs> = {}>(
      args?: Subset<T, Curso$itemsCarritoArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$ItemCarritoPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Curso model
   */
  interface CursoFieldRefs {
    readonly id: FieldRef<'Curso', 'Int'>;
    readonly slug: FieldRef<'Curso', 'String'>;
    readonly titulo: FieldRef<'Curso', 'String'>;
    readonly resumen: FieldRef<'Curso', 'String'>;
    readonly descripcionMD: FieldRef<'Curso', 'String'>;
    readonly requisitos: FieldRef<'Curso', 'String'>;
    readonly precio: FieldRef<'Curso', 'Int'>;
    readonly publicado: FieldRef<'Curso', 'Boolean'>;
    readonly nivel: FieldRef<'Curso', 'NivelCurso'>;
    readonly portada: FieldRef<'Curso', 'String'>;
    readonly destacado: FieldRef<'Curso', 'Boolean'>;
    readonly tags: FieldRef<'Curso', 'Json'>;
    readonly ratingProm: FieldRef<'Curso', 'Decimal'>;
    readonly ratingConteo: FieldRef<'Curso', 'Int'>;
    readonly creadoEn: FieldRef<'Curso', 'DateTime'>;
    readonly instructorId: FieldRef<'Curso', 'Int'>;
  }

  // Custom InputTypes
  /**
   * Curso findUnique
   */
  export type CursoFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Curso
     */
    select?: CursoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Curso
     */
    omit?: CursoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoInclude<ExtArgs> | null;
    /**
     * Filter, which Curso to fetch.
     */
    where: CursoWhereUniqueInput;
  };

  /**
   * Curso findUniqueOrThrow
   */
  export type CursoFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Curso
     */
    select?: CursoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Curso
     */
    omit?: CursoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoInclude<ExtArgs> | null;
    /**
     * Filter, which Curso to fetch.
     */
    where: CursoWhereUniqueInput;
  };

  /**
   * Curso findFirst
   */
  export type CursoFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Curso
     */
    select?: CursoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Curso
     */
    omit?: CursoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoInclude<ExtArgs> | null;
    /**
     * Filter, which Curso to fetch.
     */
    where?: CursoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Cursos to fetch.
     */
    orderBy?: CursoOrderByWithRelationInput | CursoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Cursos.
     */
    cursor?: CursoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Cursos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Cursos.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Cursos.
     */
    distinct?: CursoScalarFieldEnum | CursoScalarFieldEnum[];
  };

  /**
   * Curso findFirstOrThrow
   */
  export type CursoFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Curso
     */
    select?: CursoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Curso
     */
    omit?: CursoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoInclude<ExtArgs> | null;
    /**
     * Filter, which Curso to fetch.
     */
    where?: CursoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Cursos to fetch.
     */
    orderBy?: CursoOrderByWithRelationInput | CursoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Cursos.
     */
    cursor?: CursoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Cursos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Cursos.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Cursos.
     */
    distinct?: CursoScalarFieldEnum | CursoScalarFieldEnum[];
  };

  /**
   * Curso findMany
   */
  export type CursoFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Curso
     */
    select?: CursoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Curso
     */
    omit?: CursoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoInclude<ExtArgs> | null;
    /**
     * Filter, which Cursos to fetch.
     */
    where?: CursoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Cursos to fetch.
     */
    orderBy?: CursoOrderByWithRelationInput | CursoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Cursos.
     */
    cursor?: CursoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Cursos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Cursos.
     */
    skip?: number;
    distinct?: CursoScalarFieldEnum | CursoScalarFieldEnum[];
  };

  /**
   * Curso create
   */
  export type CursoCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Curso
     */
    select?: CursoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Curso
     */
    omit?: CursoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoInclude<ExtArgs> | null;
    /**
     * The data needed to create a Curso.
     */
    data: XOR<CursoCreateInput, CursoUncheckedCreateInput>;
  };

  /**
   * Curso createMany
   */
  export type CursoCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Cursos.
     */
    data: CursoCreateManyInput | CursoCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Curso update
   */
  export type CursoUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Curso
     */
    select?: CursoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Curso
     */
    omit?: CursoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoInclude<ExtArgs> | null;
    /**
     * The data needed to update a Curso.
     */
    data: XOR<CursoUpdateInput, CursoUncheckedUpdateInput>;
    /**
     * Choose, which Curso to update.
     */
    where: CursoWhereUniqueInput;
  };

  /**
   * Curso updateMany
   */
  export type CursoUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Cursos.
     */
    data: XOR<CursoUpdateManyMutationInput, CursoUncheckedUpdateManyInput>;
    /**
     * Filter which Cursos to update
     */
    where?: CursoWhereInput;
    /**
     * Limit how many Cursos to update.
     */
    limit?: number;
  };

  /**
   * Curso upsert
   */
  export type CursoUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Curso
     */
    select?: CursoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Curso
     */
    omit?: CursoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoInclude<ExtArgs> | null;
    /**
     * The filter to search for the Curso to update in case it exists.
     */
    where: CursoWhereUniqueInput;
    /**
     * In case the Curso found by the `where` argument doesn't exist, create a new Curso with this data.
     */
    create: XOR<CursoCreateInput, CursoUncheckedCreateInput>;
    /**
     * In case the Curso was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CursoUpdateInput, CursoUncheckedUpdateInput>;
  };

  /**
   * Curso delete
   */
  export type CursoDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Curso
     */
    select?: CursoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Curso
     */
    omit?: CursoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoInclude<ExtArgs> | null;
    /**
     * Filter which Curso to delete.
     */
    where: CursoWhereUniqueInput;
  };

  /**
   * Curso deleteMany
   */
  export type CursoDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Cursos to delete
     */
    where?: CursoWhereInput;
    /**
     * Limit how many Cursos to delete.
     */
    limit?: number;
  };

  /**
   * Curso.instructor
   */
  export type Curso$instructorArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null;
    where?: UsuarioWhereInput;
  };

  /**
   * Curso.modulos
   */
  export type Curso$modulosArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Modulo
     */
    select?: ModuloSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Modulo
     */
    omit?: ModuloOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloInclude<ExtArgs> | null;
    where?: ModuloWhereInput;
    orderBy?: ModuloOrderByWithRelationInput | ModuloOrderByWithRelationInput[];
    cursor?: ModuloWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ModuloScalarFieldEnum | ModuloScalarFieldEnum[];
  };

  /**
   * Curso.resenas
   */
  export type Curso$resenasArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Resena
     */
    select?: ResenaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Resena
     */
    omit?: ResenaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaInclude<ExtArgs> | null;
    where?: ResenaWhereInput;
    orderBy?: ResenaOrderByWithRelationInput | ResenaOrderByWithRelationInput[];
    cursor?: ResenaWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ResenaScalarFieldEnum | ResenaScalarFieldEnum[];
  };

  /**
   * Curso.inscripciones
   */
  export type Curso$inscripcionesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Inscripcion
     */
    select?: InscripcionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Inscripcion
     */
    omit?: InscripcionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InscripcionInclude<ExtArgs> | null;
    where?: InscripcionWhereInput;
    orderBy?:
      | InscripcionOrderByWithRelationInput
      | InscripcionOrderByWithRelationInput[];
    cursor?: InscripcionWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: InscripcionScalarFieldEnum | InscripcionScalarFieldEnum[];
  };

  /**
   * Curso.itemsCarrito
   */
  export type Curso$itemsCarritoArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ItemCarrito
     */
    select?: ItemCarritoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ItemCarrito
     */
    omit?: ItemCarritoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCarritoInclude<ExtArgs> | null;
    where?: ItemCarritoWhereInput;
    orderBy?:
      | ItemCarritoOrderByWithRelationInput
      | ItemCarritoOrderByWithRelationInput[];
    cursor?: ItemCarritoWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ItemCarritoScalarFieldEnum | ItemCarritoScalarFieldEnum[];
  };

  /**
   * Curso without action
   */
  export type CursoDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Curso
     */
    select?: CursoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Curso
     */
    omit?: CursoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoInclude<ExtArgs> | null;
  };

  /**
   * Model Inscripcion
   */

  export type AggregateInscripcion = {
    _count: InscripcionCountAggregateOutputType | null;
    _avg: InscripcionAvgAggregateOutputType | null;
    _sum: InscripcionSumAggregateOutputType | null;
    _min: InscripcionMinAggregateOutputType | null;
    _max: InscripcionMaxAggregateOutputType | null;
  };

  export type InscripcionAvgAggregateOutputType = {
    id: number | null;
    usuarioId: number | null;
    cursoId: number | null;
  };

  export type InscripcionSumAggregateOutputType = {
    id: number | null;
    usuarioId: number | null;
    cursoId: number | null;
  };

  export type InscripcionMinAggregateOutputType = {
    id: number | null;
    usuarioId: number | null;
    cursoId: number | null;
    estado: $Enums.EstadoInscripcion | null;
    creadoEn: Date | null;
    actualizadoEn: Date | null;
  };

  export type InscripcionMaxAggregateOutputType = {
    id: number | null;
    usuarioId: number | null;
    cursoId: number | null;
    estado: $Enums.EstadoInscripcion | null;
    creadoEn: Date | null;
    actualizadoEn: Date | null;
  };

  export type InscripcionCountAggregateOutputType = {
    id: number;
    usuarioId: number;
    cursoId: number;
    estado: number;
    progreso: number;
    creadoEn: number;
    actualizadoEn: number;
    _all: number;
  };

  export type InscripcionAvgAggregateInputType = {
    id?: true;
    usuarioId?: true;
    cursoId?: true;
  };

  export type InscripcionSumAggregateInputType = {
    id?: true;
    usuarioId?: true;
    cursoId?: true;
  };

  export type InscripcionMinAggregateInputType = {
    id?: true;
    usuarioId?: true;
    cursoId?: true;
    estado?: true;
    creadoEn?: true;
    actualizadoEn?: true;
  };

  export type InscripcionMaxAggregateInputType = {
    id?: true;
    usuarioId?: true;
    cursoId?: true;
    estado?: true;
    creadoEn?: true;
    actualizadoEn?: true;
  };

  export type InscripcionCountAggregateInputType = {
    id?: true;
    usuarioId?: true;
    cursoId?: true;
    estado?: true;
    progreso?: true;
    creadoEn?: true;
    actualizadoEn?: true;
    _all?: true;
  };

  export type InscripcionAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Inscripcion to aggregate.
     */
    where?: InscripcionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Inscripcions to fetch.
     */
    orderBy?:
      | InscripcionOrderByWithRelationInput
      | InscripcionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: InscripcionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Inscripcions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Inscripcions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Inscripcions
     **/
    _count?: true | InscripcionCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: InscripcionAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: InscripcionSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: InscripcionMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: InscripcionMaxAggregateInputType;
  };

  export type GetInscripcionAggregateType<T extends InscripcionAggregateArgs> =
    {
      [P in keyof T & keyof AggregateInscripcion]: P extends '_count' | 'count'
        ? T[P] extends true
          ? number
          : GetScalarType<T[P], AggregateInscripcion[P]>
        : GetScalarType<T[P], AggregateInscripcion[P]>;
    };

  export type InscripcionGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: InscripcionWhereInput;
    orderBy?:
      | InscripcionOrderByWithAggregationInput
      | InscripcionOrderByWithAggregationInput[];
    by: InscripcionScalarFieldEnum[] | InscripcionScalarFieldEnum;
    having?: InscripcionScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: InscripcionCountAggregateInputType | true;
    _avg?: InscripcionAvgAggregateInputType;
    _sum?: InscripcionSumAggregateInputType;
    _min?: InscripcionMinAggregateInputType;
    _max?: InscripcionMaxAggregateInputType;
  };

  export type InscripcionGroupByOutputType = {
    id: number;
    usuarioId: number;
    cursoId: number;
    estado: $Enums.EstadoInscripcion;
    progreso: JsonValue;
    creadoEn: Date;
    actualizadoEn: Date;
    _count: InscripcionCountAggregateOutputType | null;
    _avg: InscripcionAvgAggregateOutputType | null;
    _sum: InscripcionSumAggregateOutputType | null;
    _min: InscripcionMinAggregateOutputType | null;
    _max: InscripcionMaxAggregateOutputType | null;
  };

  type GetInscripcionGroupByPayload<T extends InscripcionGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<InscripcionGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof InscripcionGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InscripcionGroupByOutputType[P]>
            : GetScalarType<T[P], InscripcionGroupByOutputType[P]>;
        }
      >
    >;

  export type InscripcionSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      usuarioId?: boolean;
      cursoId?: boolean;
      estado?: boolean;
      progreso?: boolean;
      creadoEn?: boolean;
      actualizadoEn?: boolean;
      usuario?: boolean | UsuarioDefaultArgs<ExtArgs>;
      curso?: boolean | CursoDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['inscripcion']
  >;

  export type InscripcionSelectScalar = {
    id?: boolean;
    usuarioId?: boolean;
    cursoId?: boolean;
    estado?: boolean;
    progreso?: boolean;
    creadoEn?: boolean;
    actualizadoEn?: boolean;
  };

  export type InscripcionOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'usuarioId'
    | 'cursoId'
    | 'estado'
    | 'progreso'
    | 'creadoEn'
    | 'actualizadoEn',
    ExtArgs['result']['inscripcion']
  >;
  export type InscripcionInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>;
    curso?: boolean | CursoDefaultArgs<ExtArgs>;
  };

  export type $InscripcionPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Inscripcion';
    objects: {
      usuario: Prisma.$UsuarioPayload<ExtArgs>;
      curso: Prisma.$CursoPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        usuarioId: number;
        cursoId: number;
        estado: $Enums.EstadoInscripcion;
        progreso: Prisma.JsonValue;
        creadoEn: Date;
        actualizadoEn: Date;
      },
      ExtArgs['result']['inscripcion']
    >;
    composites: {};
  };

  type InscripcionGetPayload<
    S extends boolean | null | undefined | InscripcionDefaultArgs,
  > = $Result.GetResult<Prisma.$InscripcionPayload, S>;

  type InscripcionCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    InscripcionFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: InscripcionCountAggregateInputType | true;
  };

  export interface InscripcionDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Inscripcion'];
      meta: { name: 'Inscripcion' };
    };
    /**
     * Find zero or one Inscripcion that matches the filter.
     * @param {InscripcionFindUniqueArgs} args - Arguments to find a Inscripcion
     * @example
     * // Get one Inscripcion
     * const inscripcion = await prisma.inscripcion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InscripcionFindUniqueArgs>(
      args: SelectSubset<T, InscripcionFindUniqueArgs<ExtArgs>>,
    ): Prisma__InscripcionClient<
      $Result.GetResult<
        Prisma.$InscripcionPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Inscripcion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InscripcionFindUniqueOrThrowArgs} args - Arguments to find a Inscripcion
     * @example
     * // Get one Inscripcion
     * const inscripcion = await prisma.inscripcion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InscripcionFindUniqueOrThrowArgs>(
      args: SelectSubset<T, InscripcionFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__InscripcionClient<
      $Result.GetResult<
        Prisma.$InscripcionPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Inscripcion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InscripcionFindFirstArgs} args - Arguments to find a Inscripcion
     * @example
     * // Get one Inscripcion
     * const inscripcion = await prisma.inscripcion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InscripcionFindFirstArgs>(
      args?: SelectSubset<T, InscripcionFindFirstArgs<ExtArgs>>,
    ): Prisma__InscripcionClient<
      $Result.GetResult<
        Prisma.$InscripcionPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Inscripcion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InscripcionFindFirstOrThrowArgs} args - Arguments to find a Inscripcion
     * @example
     * // Get one Inscripcion
     * const inscripcion = await prisma.inscripcion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InscripcionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, InscripcionFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__InscripcionClient<
      $Result.GetResult<
        Prisma.$InscripcionPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Inscripcions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InscripcionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inscripcions
     * const inscripcions = await prisma.inscripcion.findMany()
     *
     * // Get first 10 Inscripcions
     * const inscripcions = await prisma.inscripcion.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const inscripcionWithIdOnly = await prisma.inscripcion.findMany({ select: { id: true } })
     *
     */
    findMany<T extends InscripcionFindManyArgs>(
      args?: SelectSubset<T, InscripcionFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$InscripcionPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Inscripcion.
     * @param {InscripcionCreateArgs} args - Arguments to create a Inscripcion.
     * @example
     * // Create one Inscripcion
     * const Inscripcion = await prisma.inscripcion.create({
     *   data: {
     *     // ... data to create a Inscripcion
     *   }
     * })
     *
     */
    create<T extends InscripcionCreateArgs>(
      args: SelectSubset<T, InscripcionCreateArgs<ExtArgs>>,
    ): Prisma__InscripcionClient<
      $Result.GetResult<
        Prisma.$InscripcionPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Inscripcions.
     * @param {InscripcionCreateManyArgs} args - Arguments to create many Inscripcions.
     * @example
     * // Create many Inscripcions
     * const inscripcion = await prisma.inscripcion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends InscripcionCreateManyArgs>(
      args?: SelectSubset<T, InscripcionCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Inscripcion.
     * @param {InscripcionDeleteArgs} args - Arguments to delete one Inscripcion.
     * @example
     * // Delete one Inscripcion
     * const Inscripcion = await prisma.inscripcion.delete({
     *   where: {
     *     // ... filter to delete one Inscripcion
     *   }
     * })
     *
     */
    delete<T extends InscripcionDeleteArgs>(
      args: SelectSubset<T, InscripcionDeleteArgs<ExtArgs>>,
    ): Prisma__InscripcionClient<
      $Result.GetResult<
        Prisma.$InscripcionPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Inscripcion.
     * @param {InscripcionUpdateArgs} args - Arguments to update one Inscripcion.
     * @example
     * // Update one Inscripcion
     * const inscripcion = await prisma.inscripcion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends InscripcionUpdateArgs>(
      args: SelectSubset<T, InscripcionUpdateArgs<ExtArgs>>,
    ): Prisma__InscripcionClient<
      $Result.GetResult<
        Prisma.$InscripcionPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Inscripcions.
     * @param {InscripcionDeleteManyArgs} args - Arguments to filter Inscripcions to delete.
     * @example
     * // Delete a few Inscripcions
     * const { count } = await prisma.inscripcion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends InscripcionDeleteManyArgs>(
      args?: SelectSubset<T, InscripcionDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Inscripcions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InscripcionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inscripcions
     * const inscripcion = await prisma.inscripcion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends InscripcionUpdateManyArgs>(
      args: SelectSubset<T, InscripcionUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Inscripcion.
     * @param {InscripcionUpsertArgs} args - Arguments to update or create a Inscripcion.
     * @example
     * // Update or create a Inscripcion
     * const inscripcion = await prisma.inscripcion.upsert({
     *   create: {
     *     // ... data to create a Inscripcion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inscripcion we want to update
     *   }
     * })
     */
    upsert<T extends InscripcionUpsertArgs>(
      args: SelectSubset<T, InscripcionUpsertArgs<ExtArgs>>,
    ): Prisma__InscripcionClient<
      $Result.GetResult<
        Prisma.$InscripcionPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Inscripcions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InscripcionCountArgs} args - Arguments to filter Inscripcions to count.
     * @example
     * // Count the number of Inscripcions
     * const count = await prisma.inscripcion.count({
     *   where: {
     *     // ... the filter for the Inscripcions we want to count
     *   }
     * })
     **/
    count<T extends InscripcionCountArgs>(
      args?: Subset<T, InscripcionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InscripcionCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Inscripcion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InscripcionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends InscripcionAggregateArgs>(
      args: Subset<T, InscripcionAggregateArgs>,
    ): Prisma.PrismaPromise<GetInscripcionAggregateType<T>>;

    /**
     * Group by Inscripcion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InscripcionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends InscripcionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InscripcionGroupByArgs['orderBy'] }
        : { orderBy?: InscripcionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, InscripcionGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetInscripcionGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Inscripcion model
     */
    readonly fields: InscripcionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Inscripcion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InscripcionClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>,
    ): Prisma__UsuarioClient<
      | $Result.GetResult<
          Prisma.$UsuarioPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    curso<T extends CursoDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, CursoDefaultArgs<ExtArgs>>,
    ): Prisma__CursoClient<
      | $Result.GetResult<
          Prisma.$CursoPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Inscripcion model
   */
  interface InscripcionFieldRefs {
    readonly id: FieldRef<'Inscripcion', 'Int'>;
    readonly usuarioId: FieldRef<'Inscripcion', 'Int'>;
    readonly cursoId: FieldRef<'Inscripcion', 'Int'>;
    readonly estado: FieldRef<'Inscripcion', 'EstadoInscripcion'>;
    readonly progreso: FieldRef<'Inscripcion', 'Json'>;
    readonly creadoEn: FieldRef<'Inscripcion', 'DateTime'>;
    readonly actualizadoEn: FieldRef<'Inscripcion', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Inscripcion findUnique
   */
  export type InscripcionFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Inscripcion
     */
    select?: InscripcionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Inscripcion
     */
    omit?: InscripcionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InscripcionInclude<ExtArgs> | null;
    /**
     * Filter, which Inscripcion to fetch.
     */
    where: InscripcionWhereUniqueInput;
  };

  /**
   * Inscripcion findUniqueOrThrow
   */
  export type InscripcionFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Inscripcion
     */
    select?: InscripcionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Inscripcion
     */
    omit?: InscripcionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InscripcionInclude<ExtArgs> | null;
    /**
     * Filter, which Inscripcion to fetch.
     */
    where: InscripcionWhereUniqueInput;
  };

  /**
   * Inscripcion findFirst
   */
  export type InscripcionFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Inscripcion
     */
    select?: InscripcionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Inscripcion
     */
    omit?: InscripcionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InscripcionInclude<ExtArgs> | null;
    /**
     * Filter, which Inscripcion to fetch.
     */
    where?: InscripcionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Inscripcions to fetch.
     */
    orderBy?:
      | InscripcionOrderByWithRelationInput
      | InscripcionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Inscripcions.
     */
    cursor?: InscripcionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Inscripcions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Inscripcions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Inscripcions.
     */
    distinct?: InscripcionScalarFieldEnum | InscripcionScalarFieldEnum[];
  };

  /**
   * Inscripcion findFirstOrThrow
   */
  export type InscripcionFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Inscripcion
     */
    select?: InscripcionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Inscripcion
     */
    omit?: InscripcionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InscripcionInclude<ExtArgs> | null;
    /**
     * Filter, which Inscripcion to fetch.
     */
    where?: InscripcionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Inscripcions to fetch.
     */
    orderBy?:
      | InscripcionOrderByWithRelationInput
      | InscripcionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Inscripcions.
     */
    cursor?: InscripcionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Inscripcions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Inscripcions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Inscripcions.
     */
    distinct?: InscripcionScalarFieldEnum | InscripcionScalarFieldEnum[];
  };

  /**
   * Inscripcion findMany
   */
  export type InscripcionFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Inscripcion
     */
    select?: InscripcionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Inscripcion
     */
    omit?: InscripcionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InscripcionInclude<ExtArgs> | null;
    /**
     * Filter, which Inscripcions to fetch.
     */
    where?: InscripcionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Inscripcions to fetch.
     */
    orderBy?:
      | InscripcionOrderByWithRelationInput
      | InscripcionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Inscripcions.
     */
    cursor?: InscripcionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Inscripcions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Inscripcions.
     */
    skip?: number;
    distinct?: InscripcionScalarFieldEnum | InscripcionScalarFieldEnum[];
  };

  /**
   * Inscripcion create
   */
  export type InscripcionCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Inscripcion
     */
    select?: InscripcionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Inscripcion
     */
    omit?: InscripcionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InscripcionInclude<ExtArgs> | null;
    /**
     * The data needed to create a Inscripcion.
     */
    data: XOR<InscripcionCreateInput, InscripcionUncheckedCreateInput>;
  };

  /**
   * Inscripcion createMany
   */
  export type InscripcionCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Inscripcions.
     */
    data: InscripcionCreateManyInput | InscripcionCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Inscripcion update
   */
  export type InscripcionUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Inscripcion
     */
    select?: InscripcionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Inscripcion
     */
    omit?: InscripcionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InscripcionInclude<ExtArgs> | null;
    /**
     * The data needed to update a Inscripcion.
     */
    data: XOR<InscripcionUpdateInput, InscripcionUncheckedUpdateInput>;
    /**
     * Choose, which Inscripcion to update.
     */
    where: InscripcionWhereUniqueInput;
  };

  /**
   * Inscripcion updateMany
   */
  export type InscripcionUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Inscripcions.
     */
    data: XOR<
      InscripcionUpdateManyMutationInput,
      InscripcionUncheckedUpdateManyInput
    >;
    /**
     * Filter which Inscripcions to update
     */
    where?: InscripcionWhereInput;
    /**
     * Limit how many Inscripcions to update.
     */
    limit?: number;
  };

  /**
   * Inscripcion upsert
   */
  export type InscripcionUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Inscripcion
     */
    select?: InscripcionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Inscripcion
     */
    omit?: InscripcionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InscripcionInclude<ExtArgs> | null;
    /**
     * The filter to search for the Inscripcion to update in case it exists.
     */
    where: InscripcionWhereUniqueInput;
    /**
     * In case the Inscripcion found by the `where` argument doesn't exist, create a new Inscripcion with this data.
     */
    create: XOR<InscripcionCreateInput, InscripcionUncheckedCreateInput>;
    /**
     * In case the Inscripcion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InscripcionUpdateInput, InscripcionUncheckedUpdateInput>;
  };

  /**
   * Inscripcion delete
   */
  export type InscripcionDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Inscripcion
     */
    select?: InscripcionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Inscripcion
     */
    omit?: InscripcionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InscripcionInclude<ExtArgs> | null;
    /**
     * Filter which Inscripcion to delete.
     */
    where: InscripcionWhereUniqueInput;
  };

  /**
   * Inscripcion deleteMany
   */
  export type InscripcionDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Inscripcions to delete
     */
    where?: InscripcionWhereInput;
    /**
     * Limit how many Inscripcions to delete.
     */
    limit?: number;
  };

  /**
   * Inscripcion without action
   */
  export type InscripcionDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Inscripcion
     */
    select?: InscripcionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Inscripcion
     */
    omit?: InscripcionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InscripcionInclude<ExtArgs> | null;
  };

  /**
   * Model Modulo
   */

  export type AggregateModulo = {
    _count: ModuloCountAggregateOutputType | null;
    _avg: ModuloAvgAggregateOutputType | null;
    _sum: ModuloSumAggregateOutputType | null;
    _min: ModuloMinAggregateOutputType | null;
    _max: ModuloMaxAggregateOutputType | null;
  };

  export type ModuloAvgAggregateOutputType = {
    id: number | null;
    cursoId: number | null;
    orden: number | null;
    parentId: number | null;
  };

  export type ModuloSumAggregateOutputType = {
    id: number | null;
    cursoId: number | null;
    orden: number | null;
    parentId: number | null;
  };

  export type ModuloMinAggregateOutputType = {
    id: number | null;
    cursoId: number | null;
    titulo: string | null;
    orden: number | null;
    parentId: number | null;
  };

  export type ModuloMaxAggregateOutputType = {
    id: number | null;
    cursoId: number | null;
    titulo: string | null;
    orden: number | null;
    parentId: number | null;
  };

  export type ModuloCountAggregateOutputType = {
    id: number;
    cursoId: number;
    titulo: number;
    orden: number;
    parentId: number;
    _all: number;
  };

  export type ModuloAvgAggregateInputType = {
    id?: true;
    cursoId?: true;
    orden?: true;
    parentId?: true;
  };

  export type ModuloSumAggregateInputType = {
    id?: true;
    cursoId?: true;
    orden?: true;
    parentId?: true;
  };

  export type ModuloMinAggregateInputType = {
    id?: true;
    cursoId?: true;
    titulo?: true;
    orden?: true;
    parentId?: true;
  };

  export type ModuloMaxAggregateInputType = {
    id?: true;
    cursoId?: true;
    titulo?: true;
    orden?: true;
    parentId?: true;
  };

  export type ModuloCountAggregateInputType = {
    id?: true;
    cursoId?: true;
    titulo?: true;
    orden?: true;
    parentId?: true;
    _all?: true;
  };

  export type ModuloAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Modulo to aggregate.
     */
    where?: ModuloWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Modulos to fetch.
     */
    orderBy?: ModuloOrderByWithRelationInput | ModuloOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ModuloWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Modulos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Modulos.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Modulos
     **/
    _count?: true | ModuloCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ModuloAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ModuloSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ModuloMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ModuloMaxAggregateInputType;
  };

  export type GetModuloAggregateType<T extends ModuloAggregateArgs> = {
    [P in keyof T & keyof AggregateModulo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModulo[P]>
      : GetScalarType<T[P], AggregateModulo[P]>;
  };

  export type ModuloGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ModuloWhereInput;
    orderBy?:
      | ModuloOrderByWithAggregationInput
      | ModuloOrderByWithAggregationInput[];
    by: ModuloScalarFieldEnum[] | ModuloScalarFieldEnum;
    having?: ModuloScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ModuloCountAggregateInputType | true;
    _avg?: ModuloAvgAggregateInputType;
    _sum?: ModuloSumAggregateInputType;
    _min?: ModuloMinAggregateInputType;
    _max?: ModuloMaxAggregateInputType;
  };

  export type ModuloGroupByOutputType = {
    id: number;
    cursoId: number;
    titulo: string;
    orden: number;
    parentId: number | null;
    _count: ModuloCountAggregateOutputType | null;
    _avg: ModuloAvgAggregateOutputType | null;
    _sum: ModuloSumAggregateOutputType | null;
    _min: ModuloMinAggregateOutputType | null;
    _max: ModuloMaxAggregateOutputType | null;
  };

  type GetModuloGroupByPayload<T extends ModuloGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ModuloGroupByOutputType, T['by']> & {
          [P in keyof T & keyof ModuloGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModuloGroupByOutputType[P]>
            : GetScalarType<T[P], ModuloGroupByOutputType[P]>;
        }
      >
    >;

  export type ModuloSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      cursoId?: boolean;
      titulo?: boolean;
      orden?: boolean;
      parentId?: boolean;
      curso?: boolean | CursoDefaultArgs<ExtArgs>;
      lecciones?: boolean | Modulo$leccionesArgs<ExtArgs>;
      _count?: boolean | ModuloCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['modulo']
  >;

  export type ModuloSelectScalar = {
    id?: boolean;
    cursoId?: boolean;
    titulo?: boolean;
    orden?: boolean;
    parentId?: boolean;
  };

  export type ModuloOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    'id' | 'cursoId' | 'titulo' | 'orden' | 'parentId',
    ExtArgs['result']['modulo']
  >;
  export type ModuloInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    curso?: boolean | CursoDefaultArgs<ExtArgs>;
    lecciones?: boolean | Modulo$leccionesArgs<ExtArgs>;
    _count?: boolean | ModuloCountOutputTypeDefaultArgs<ExtArgs>;
  };

  export type $ModuloPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Modulo';
    objects: {
      curso: Prisma.$CursoPayload<ExtArgs>;
      lecciones: Prisma.$LeccionPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        cursoId: number;
        titulo: string;
        orden: number;
        parentId: number | null;
      },
      ExtArgs['result']['modulo']
    >;
    composites: {};
  };

  type ModuloGetPayload<
    S extends boolean | null | undefined | ModuloDefaultArgs,
  > = $Result.GetResult<Prisma.$ModuloPayload, S>;

  type ModuloCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<ModuloFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: ModuloCountAggregateInputType | true;
  };

  export interface ModuloDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Modulo'];
      meta: { name: 'Modulo' };
    };
    /**
     * Find zero or one Modulo that matches the filter.
     * @param {ModuloFindUniqueArgs} args - Arguments to find a Modulo
     * @example
     * // Get one Modulo
     * const modulo = await prisma.modulo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModuloFindUniqueArgs>(
      args: SelectSubset<T, ModuloFindUniqueArgs<ExtArgs>>,
    ): Prisma__ModuloClient<
      $Result.GetResult<
        Prisma.$ModuloPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Modulo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ModuloFindUniqueOrThrowArgs} args - Arguments to find a Modulo
     * @example
     * // Get one Modulo
     * const modulo = await prisma.modulo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModuloFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ModuloFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__ModuloClient<
      $Result.GetResult<
        Prisma.$ModuloPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Modulo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuloFindFirstArgs} args - Arguments to find a Modulo
     * @example
     * // Get one Modulo
     * const modulo = await prisma.modulo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModuloFindFirstArgs>(
      args?: SelectSubset<T, ModuloFindFirstArgs<ExtArgs>>,
    ): Prisma__ModuloClient<
      $Result.GetResult<
        Prisma.$ModuloPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Modulo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuloFindFirstOrThrowArgs} args - Arguments to find a Modulo
     * @example
     * // Get one Modulo
     * const modulo = await prisma.modulo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModuloFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ModuloFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__ModuloClient<
      $Result.GetResult<
        Prisma.$ModuloPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Modulos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuloFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Modulos
     * const modulos = await prisma.modulo.findMany()
     *
     * // Get first 10 Modulos
     * const modulos = await prisma.modulo.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const moduloWithIdOnly = await prisma.modulo.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ModuloFindManyArgs>(
      args?: SelectSubset<T, ModuloFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ModuloPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Modulo.
     * @param {ModuloCreateArgs} args - Arguments to create a Modulo.
     * @example
     * // Create one Modulo
     * const Modulo = await prisma.modulo.create({
     *   data: {
     *     // ... data to create a Modulo
     *   }
     * })
     *
     */
    create<T extends ModuloCreateArgs>(
      args: SelectSubset<T, ModuloCreateArgs<ExtArgs>>,
    ): Prisma__ModuloClient<
      $Result.GetResult<
        Prisma.$ModuloPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Modulos.
     * @param {ModuloCreateManyArgs} args - Arguments to create many Modulos.
     * @example
     * // Create many Modulos
     * const modulo = await prisma.modulo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ModuloCreateManyArgs>(
      args?: SelectSubset<T, ModuloCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Modulo.
     * @param {ModuloDeleteArgs} args - Arguments to delete one Modulo.
     * @example
     * // Delete one Modulo
     * const Modulo = await prisma.modulo.delete({
     *   where: {
     *     // ... filter to delete one Modulo
     *   }
     * })
     *
     */
    delete<T extends ModuloDeleteArgs>(
      args: SelectSubset<T, ModuloDeleteArgs<ExtArgs>>,
    ): Prisma__ModuloClient<
      $Result.GetResult<
        Prisma.$ModuloPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Modulo.
     * @param {ModuloUpdateArgs} args - Arguments to update one Modulo.
     * @example
     * // Update one Modulo
     * const modulo = await prisma.modulo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ModuloUpdateArgs>(
      args: SelectSubset<T, ModuloUpdateArgs<ExtArgs>>,
    ): Prisma__ModuloClient<
      $Result.GetResult<
        Prisma.$ModuloPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Modulos.
     * @param {ModuloDeleteManyArgs} args - Arguments to filter Modulos to delete.
     * @example
     * // Delete a few Modulos
     * const { count } = await prisma.modulo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ModuloDeleteManyArgs>(
      args?: SelectSubset<T, ModuloDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Modulos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuloUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Modulos
     * const modulo = await prisma.modulo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ModuloUpdateManyArgs>(
      args: SelectSubset<T, ModuloUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Modulo.
     * @param {ModuloUpsertArgs} args - Arguments to update or create a Modulo.
     * @example
     * // Update or create a Modulo
     * const modulo = await prisma.modulo.upsert({
     *   create: {
     *     // ... data to create a Modulo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Modulo we want to update
     *   }
     * })
     */
    upsert<T extends ModuloUpsertArgs>(
      args: SelectSubset<T, ModuloUpsertArgs<ExtArgs>>,
    ): Prisma__ModuloClient<
      $Result.GetResult<
        Prisma.$ModuloPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Modulos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuloCountArgs} args - Arguments to filter Modulos to count.
     * @example
     * // Count the number of Modulos
     * const count = await prisma.modulo.count({
     *   where: {
     *     // ... the filter for the Modulos we want to count
     *   }
     * })
     **/
    count<T extends ModuloCountArgs>(
      args?: Subset<T, ModuloCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModuloCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Modulo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuloAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ModuloAggregateArgs>(
      args: Subset<T, ModuloAggregateArgs>,
    ): Prisma.PrismaPromise<GetModuloAggregateType<T>>;

    /**
     * Group by Modulo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuloGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ModuloGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModuloGroupByArgs['orderBy'] }
        : { orderBy?: ModuloGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ModuloGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetModuloGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Modulo model
     */
    readonly fields: ModuloFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Modulo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModuloClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    curso<T extends CursoDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, CursoDefaultArgs<ExtArgs>>,
    ): Prisma__CursoClient<
      | $Result.GetResult<
          Prisma.$CursoPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    lecciones<T extends Modulo$leccionesArgs<ExtArgs> = {}>(
      args?: Subset<T, Modulo$leccionesArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$LeccionPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Modulo model
   */
  interface ModuloFieldRefs {
    readonly id: FieldRef<'Modulo', 'Int'>;
    readonly cursoId: FieldRef<'Modulo', 'Int'>;
    readonly titulo: FieldRef<'Modulo', 'String'>;
    readonly orden: FieldRef<'Modulo', 'Int'>;
    readonly parentId: FieldRef<'Modulo', 'Int'>;
  }

  // Custom InputTypes
  /**
   * Modulo findUnique
   */
  export type ModuloFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Modulo
     */
    select?: ModuloSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Modulo
     */
    omit?: ModuloOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloInclude<ExtArgs> | null;
    /**
     * Filter, which Modulo to fetch.
     */
    where: ModuloWhereUniqueInput;
  };

  /**
   * Modulo findUniqueOrThrow
   */
  export type ModuloFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Modulo
     */
    select?: ModuloSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Modulo
     */
    omit?: ModuloOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloInclude<ExtArgs> | null;
    /**
     * Filter, which Modulo to fetch.
     */
    where: ModuloWhereUniqueInput;
  };

  /**
   * Modulo findFirst
   */
  export type ModuloFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Modulo
     */
    select?: ModuloSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Modulo
     */
    omit?: ModuloOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloInclude<ExtArgs> | null;
    /**
     * Filter, which Modulo to fetch.
     */
    where?: ModuloWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Modulos to fetch.
     */
    orderBy?: ModuloOrderByWithRelationInput | ModuloOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Modulos.
     */
    cursor?: ModuloWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Modulos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Modulos.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Modulos.
     */
    distinct?: ModuloScalarFieldEnum | ModuloScalarFieldEnum[];
  };

  /**
   * Modulo findFirstOrThrow
   */
  export type ModuloFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Modulo
     */
    select?: ModuloSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Modulo
     */
    omit?: ModuloOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloInclude<ExtArgs> | null;
    /**
     * Filter, which Modulo to fetch.
     */
    where?: ModuloWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Modulos to fetch.
     */
    orderBy?: ModuloOrderByWithRelationInput | ModuloOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Modulos.
     */
    cursor?: ModuloWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Modulos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Modulos.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Modulos.
     */
    distinct?: ModuloScalarFieldEnum | ModuloScalarFieldEnum[];
  };

  /**
   * Modulo findMany
   */
  export type ModuloFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Modulo
     */
    select?: ModuloSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Modulo
     */
    omit?: ModuloOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloInclude<ExtArgs> | null;
    /**
     * Filter, which Modulos to fetch.
     */
    where?: ModuloWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Modulos to fetch.
     */
    orderBy?: ModuloOrderByWithRelationInput | ModuloOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Modulos.
     */
    cursor?: ModuloWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Modulos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Modulos.
     */
    skip?: number;
    distinct?: ModuloScalarFieldEnum | ModuloScalarFieldEnum[];
  };

  /**
   * Modulo create
   */
  export type ModuloCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Modulo
     */
    select?: ModuloSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Modulo
     */
    omit?: ModuloOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloInclude<ExtArgs> | null;
    /**
     * The data needed to create a Modulo.
     */
    data: XOR<ModuloCreateInput, ModuloUncheckedCreateInput>;
  };

  /**
   * Modulo createMany
   */
  export type ModuloCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Modulos.
     */
    data: ModuloCreateManyInput | ModuloCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Modulo update
   */
  export type ModuloUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Modulo
     */
    select?: ModuloSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Modulo
     */
    omit?: ModuloOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloInclude<ExtArgs> | null;
    /**
     * The data needed to update a Modulo.
     */
    data: XOR<ModuloUpdateInput, ModuloUncheckedUpdateInput>;
    /**
     * Choose, which Modulo to update.
     */
    where: ModuloWhereUniqueInput;
  };

  /**
   * Modulo updateMany
   */
  export type ModuloUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Modulos.
     */
    data: XOR<ModuloUpdateManyMutationInput, ModuloUncheckedUpdateManyInput>;
    /**
     * Filter which Modulos to update
     */
    where?: ModuloWhereInput;
    /**
     * Limit how many Modulos to update.
     */
    limit?: number;
  };

  /**
   * Modulo upsert
   */
  export type ModuloUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Modulo
     */
    select?: ModuloSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Modulo
     */
    omit?: ModuloOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloInclude<ExtArgs> | null;
    /**
     * The filter to search for the Modulo to update in case it exists.
     */
    where: ModuloWhereUniqueInput;
    /**
     * In case the Modulo found by the `where` argument doesn't exist, create a new Modulo with this data.
     */
    create: XOR<ModuloCreateInput, ModuloUncheckedCreateInput>;
    /**
     * In case the Modulo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModuloUpdateInput, ModuloUncheckedUpdateInput>;
  };

  /**
   * Modulo delete
   */
  export type ModuloDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Modulo
     */
    select?: ModuloSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Modulo
     */
    omit?: ModuloOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloInclude<ExtArgs> | null;
    /**
     * Filter which Modulo to delete.
     */
    where: ModuloWhereUniqueInput;
  };

  /**
   * Modulo deleteMany
   */
  export type ModuloDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Modulos to delete
     */
    where?: ModuloWhereInput;
    /**
     * Limit how many Modulos to delete.
     */
    limit?: number;
  };

  /**
   * Modulo.lecciones
   */
  export type Modulo$leccionesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Leccion
     */
    select?: LeccionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Leccion
     */
    omit?: LeccionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeccionInclude<ExtArgs> | null;
    where?: LeccionWhereInput;
    orderBy?:
      | LeccionOrderByWithRelationInput
      | LeccionOrderByWithRelationInput[];
    cursor?: LeccionWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: LeccionScalarFieldEnum | LeccionScalarFieldEnum[];
  };

  /**
   * Modulo without action
   */
  export type ModuloDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Modulo
     */
    select?: ModuloSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Modulo
     */
    omit?: ModuloOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloInclude<ExtArgs> | null;
  };

  /**
   * Model Leccion
   */

  export type AggregateLeccion = {
    _count: LeccionCountAggregateOutputType | null;
    _avg: LeccionAvgAggregateOutputType | null;
    _sum: LeccionSumAggregateOutputType | null;
    _min: LeccionMinAggregateOutputType | null;
    _max: LeccionMaxAggregateOutputType | null;
  };

  export type LeccionAvgAggregateOutputType = {
    id: number | null;
    moduloId: number | null;
    orden: number | null;
    duracion: number | null;
  };

  export type LeccionSumAggregateOutputType = {
    id: number | null;
    moduloId: number | null;
    orden: number | null;
    duracion: number | null;
  };

  export type LeccionMinAggregateOutputType = {
    id: number | null;
    moduloId: number | null;
    titulo: string | null;
    rutaSrc: string | null;
    orden: number | null;
    tipo: $Enums.TipoLeccion | null;
    descripcion: string | null;
    previewUrl: string | null;
    duracion: number | null;
  };

  export type LeccionMaxAggregateOutputType = {
    id: number | null;
    moduloId: number | null;
    titulo: string | null;
    rutaSrc: string | null;
    orden: number | null;
    tipo: $Enums.TipoLeccion | null;
    descripcion: string | null;
    previewUrl: string | null;
    duracion: number | null;
  };

  export type LeccionCountAggregateOutputType = {
    id: number;
    moduloId: number;
    titulo: number;
    rutaSrc: number;
    orden: number;
    tipo: number;
    descripcion: number;
    contenido: number;
    previewUrl: number;
    duracion: number;
    _all: number;
  };

  export type LeccionAvgAggregateInputType = {
    id?: true;
    moduloId?: true;
    orden?: true;
    duracion?: true;
  };

  export type LeccionSumAggregateInputType = {
    id?: true;
    moduloId?: true;
    orden?: true;
    duracion?: true;
  };

  export type LeccionMinAggregateInputType = {
    id?: true;
    moduloId?: true;
    titulo?: true;
    rutaSrc?: true;
    orden?: true;
    tipo?: true;
    descripcion?: true;
    previewUrl?: true;
    duracion?: true;
  };

  export type LeccionMaxAggregateInputType = {
    id?: true;
    moduloId?: true;
    titulo?: true;
    rutaSrc?: true;
    orden?: true;
    tipo?: true;
    descripcion?: true;
    previewUrl?: true;
    duracion?: true;
  };

  export type LeccionCountAggregateInputType = {
    id?: true;
    moduloId?: true;
    titulo?: true;
    rutaSrc?: true;
    orden?: true;
    tipo?: true;
    descripcion?: true;
    contenido?: true;
    previewUrl?: true;
    duracion?: true;
    _all?: true;
  };

  export type LeccionAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Leccion to aggregate.
     */
    where?: LeccionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Leccions to fetch.
     */
    orderBy?:
      | LeccionOrderByWithRelationInput
      | LeccionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: LeccionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Leccions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Leccions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Leccions
     **/
    _count?: true | LeccionCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: LeccionAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: LeccionSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: LeccionMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: LeccionMaxAggregateInputType;
  };

  export type GetLeccionAggregateType<T extends LeccionAggregateArgs> = {
    [P in keyof T & keyof AggregateLeccion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeccion[P]>
      : GetScalarType<T[P], AggregateLeccion[P]>;
  };

  export type LeccionGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: LeccionWhereInput;
    orderBy?:
      | LeccionOrderByWithAggregationInput
      | LeccionOrderByWithAggregationInput[];
    by: LeccionScalarFieldEnum[] | LeccionScalarFieldEnum;
    having?: LeccionScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: LeccionCountAggregateInputType | true;
    _avg?: LeccionAvgAggregateInputType;
    _sum?: LeccionSumAggregateInputType;
    _min?: LeccionMinAggregateInputType;
    _max?: LeccionMaxAggregateInputType;
  };

  export type LeccionGroupByOutputType = {
    id: number;
    moduloId: number;
    titulo: string;
    rutaSrc: string | null;
    orden: number;
    tipo: $Enums.TipoLeccion;
    descripcion: string | null;
    contenido: JsonValue | null;
    previewUrl: string | null;
    duracion: number;
    _count: LeccionCountAggregateOutputType | null;
    _avg: LeccionAvgAggregateOutputType | null;
    _sum: LeccionSumAggregateOutputType | null;
    _min: LeccionMinAggregateOutputType | null;
    _max: LeccionMaxAggregateOutputType | null;
  };

  type GetLeccionGroupByPayload<T extends LeccionGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<LeccionGroupByOutputType, T['by']> & {
          [P in keyof T & keyof LeccionGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeccionGroupByOutputType[P]>
            : GetScalarType<T[P], LeccionGroupByOutputType[P]>;
        }
      >
    >;

  export type LeccionSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      moduloId?: boolean;
      titulo?: boolean;
      rutaSrc?: boolean;
      orden?: boolean;
      tipo?: boolean;
      descripcion?: boolean;
      contenido?: boolean;
      previewUrl?: boolean;
      duracion?: boolean;
      modulo?: boolean | ModuloDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['leccion']
  >;

  export type LeccionSelectScalar = {
    id?: boolean;
    moduloId?: boolean;
    titulo?: boolean;
    rutaSrc?: boolean;
    orden?: boolean;
    tipo?: boolean;
    descripcion?: boolean;
    contenido?: boolean;
    previewUrl?: boolean;
    duracion?: boolean;
  };

  export type LeccionOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'moduloId'
    | 'titulo'
    | 'rutaSrc'
    | 'orden'
    | 'tipo'
    | 'descripcion'
    | 'contenido'
    | 'previewUrl'
    | 'duracion',
    ExtArgs['result']['leccion']
  >;
  export type LeccionInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    modulo?: boolean | ModuloDefaultArgs<ExtArgs>;
  };

  export type $LeccionPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Leccion';
    objects: {
      modulo: Prisma.$ModuloPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        moduloId: number;
        titulo: string;
        rutaSrc: string | null;
        orden: number;
        tipo: $Enums.TipoLeccion;
        descripcion: string | null;
        contenido: Prisma.JsonValue | null;
        previewUrl: string | null;
        duracion: number;
      },
      ExtArgs['result']['leccion']
    >;
    composites: {};
  };

  type LeccionGetPayload<
    S extends boolean | null | undefined | LeccionDefaultArgs,
  > = $Result.GetResult<Prisma.$LeccionPayload, S>;

  type LeccionCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<LeccionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: LeccionCountAggregateInputType | true;
  };

  export interface LeccionDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Leccion'];
      meta: { name: 'Leccion' };
    };
    /**
     * Find zero or one Leccion that matches the filter.
     * @param {LeccionFindUniqueArgs} args - Arguments to find a Leccion
     * @example
     * // Get one Leccion
     * const leccion = await prisma.leccion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeccionFindUniqueArgs>(
      args: SelectSubset<T, LeccionFindUniqueArgs<ExtArgs>>,
    ): Prisma__LeccionClient<
      $Result.GetResult<
        Prisma.$LeccionPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Leccion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeccionFindUniqueOrThrowArgs} args - Arguments to find a Leccion
     * @example
     * // Get one Leccion
     * const leccion = await prisma.leccion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeccionFindUniqueOrThrowArgs>(
      args: SelectSubset<T, LeccionFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__LeccionClient<
      $Result.GetResult<
        Prisma.$LeccionPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Leccion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeccionFindFirstArgs} args - Arguments to find a Leccion
     * @example
     * // Get one Leccion
     * const leccion = await prisma.leccion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeccionFindFirstArgs>(
      args?: SelectSubset<T, LeccionFindFirstArgs<ExtArgs>>,
    ): Prisma__LeccionClient<
      $Result.GetResult<
        Prisma.$LeccionPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Leccion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeccionFindFirstOrThrowArgs} args - Arguments to find a Leccion
     * @example
     * // Get one Leccion
     * const leccion = await prisma.leccion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeccionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LeccionFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__LeccionClient<
      $Result.GetResult<
        Prisma.$LeccionPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Leccions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeccionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Leccions
     * const leccions = await prisma.leccion.findMany()
     *
     * // Get first 10 Leccions
     * const leccions = await prisma.leccion.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const leccionWithIdOnly = await prisma.leccion.findMany({ select: { id: true } })
     *
     */
    findMany<T extends LeccionFindManyArgs>(
      args?: SelectSubset<T, LeccionFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$LeccionPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Leccion.
     * @param {LeccionCreateArgs} args - Arguments to create a Leccion.
     * @example
     * // Create one Leccion
     * const Leccion = await prisma.leccion.create({
     *   data: {
     *     // ... data to create a Leccion
     *   }
     * })
     *
     */
    create<T extends LeccionCreateArgs>(
      args: SelectSubset<T, LeccionCreateArgs<ExtArgs>>,
    ): Prisma__LeccionClient<
      $Result.GetResult<
        Prisma.$LeccionPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Leccions.
     * @param {LeccionCreateManyArgs} args - Arguments to create many Leccions.
     * @example
     * // Create many Leccions
     * const leccion = await prisma.leccion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends LeccionCreateManyArgs>(
      args?: SelectSubset<T, LeccionCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Leccion.
     * @param {LeccionDeleteArgs} args - Arguments to delete one Leccion.
     * @example
     * // Delete one Leccion
     * const Leccion = await prisma.leccion.delete({
     *   where: {
     *     // ... filter to delete one Leccion
     *   }
     * })
     *
     */
    delete<T extends LeccionDeleteArgs>(
      args: SelectSubset<T, LeccionDeleteArgs<ExtArgs>>,
    ): Prisma__LeccionClient<
      $Result.GetResult<
        Prisma.$LeccionPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Leccion.
     * @param {LeccionUpdateArgs} args - Arguments to update one Leccion.
     * @example
     * // Update one Leccion
     * const leccion = await prisma.leccion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends LeccionUpdateArgs>(
      args: SelectSubset<T, LeccionUpdateArgs<ExtArgs>>,
    ): Prisma__LeccionClient<
      $Result.GetResult<
        Prisma.$LeccionPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Leccions.
     * @param {LeccionDeleteManyArgs} args - Arguments to filter Leccions to delete.
     * @example
     * // Delete a few Leccions
     * const { count } = await prisma.leccion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends LeccionDeleteManyArgs>(
      args?: SelectSubset<T, LeccionDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Leccions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeccionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Leccions
     * const leccion = await prisma.leccion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends LeccionUpdateManyArgs>(
      args: SelectSubset<T, LeccionUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Leccion.
     * @param {LeccionUpsertArgs} args - Arguments to update or create a Leccion.
     * @example
     * // Update or create a Leccion
     * const leccion = await prisma.leccion.upsert({
     *   create: {
     *     // ... data to create a Leccion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Leccion we want to update
     *   }
     * })
     */
    upsert<T extends LeccionUpsertArgs>(
      args: SelectSubset<T, LeccionUpsertArgs<ExtArgs>>,
    ): Prisma__LeccionClient<
      $Result.GetResult<
        Prisma.$LeccionPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Leccions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeccionCountArgs} args - Arguments to filter Leccions to count.
     * @example
     * // Count the number of Leccions
     * const count = await prisma.leccion.count({
     *   where: {
     *     // ... the filter for the Leccions we want to count
     *   }
     * })
     **/
    count<T extends LeccionCountArgs>(
      args?: Subset<T, LeccionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeccionCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Leccion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeccionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends LeccionAggregateArgs>(
      args: Subset<T, LeccionAggregateArgs>,
    ): Prisma.PrismaPromise<GetLeccionAggregateType<T>>;

    /**
     * Group by Leccion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeccionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends LeccionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeccionGroupByArgs['orderBy'] }
        : { orderBy?: LeccionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, LeccionGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetLeccionGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Leccion model
     */
    readonly fields: LeccionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Leccion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeccionClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    modulo<T extends ModuloDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, ModuloDefaultArgs<ExtArgs>>,
    ): Prisma__ModuloClient<
      | $Result.GetResult<
          Prisma.$ModuloPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Leccion model
   */
  interface LeccionFieldRefs {
    readonly id: FieldRef<'Leccion', 'Int'>;
    readonly moduloId: FieldRef<'Leccion', 'Int'>;
    readonly titulo: FieldRef<'Leccion', 'String'>;
    readonly rutaSrc: FieldRef<'Leccion', 'String'>;
    readonly orden: FieldRef<'Leccion', 'Int'>;
    readonly tipo: FieldRef<'Leccion', 'TipoLeccion'>;
    readonly descripcion: FieldRef<'Leccion', 'String'>;
    readonly contenido: FieldRef<'Leccion', 'Json'>;
    readonly previewUrl: FieldRef<'Leccion', 'String'>;
    readonly duracion: FieldRef<'Leccion', 'Float'>;
  }

  // Custom InputTypes
  /**
   * Leccion findUnique
   */
  export type LeccionFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Leccion
     */
    select?: LeccionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Leccion
     */
    omit?: LeccionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeccionInclude<ExtArgs> | null;
    /**
     * Filter, which Leccion to fetch.
     */
    where: LeccionWhereUniqueInput;
  };

  /**
   * Leccion findUniqueOrThrow
   */
  export type LeccionFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Leccion
     */
    select?: LeccionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Leccion
     */
    omit?: LeccionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeccionInclude<ExtArgs> | null;
    /**
     * Filter, which Leccion to fetch.
     */
    where: LeccionWhereUniqueInput;
  };

  /**
   * Leccion findFirst
   */
  export type LeccionFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Leccion
     */
    select?: LeccionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Leccion
     */
    omit?: LeccionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeccionInclude<ExtArgs> | null;
    /**
     * Filter, which Leccion to fetch.
     */
    where?: LeccionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Leccions to fetch.
     */
    orderBy?:
      | LeccionOrderByWithRelationInput
      | LeccionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Leccions.
     */
    cursor?: LeccionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Leccions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Leccions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Leccions.
     */
    distinct?: LeccionScalarFieldEnum | LeccionScalarFieldEnum[];
  };

  /**
   * Leccion findFirstOrThrow
   */
  export type LeccionFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Leccion
     */
    select?: LeccionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Leccion
     */
    omit?: LeccionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeccionInclude<ExtArgs> | null;
    /**
     * Filter, which Leccion to fetch.
     */
    where?: LeccionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Leccions to fetch.
     */
    orderBy?:
      | LeccionOrderByWithRelationInput
      | LeccionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Leccions.
     */
    cursor?: LeccionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Leccions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Leccions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Leccions.
     */
    distinct?: LeccionScalarFieldEnum | LeccionScalarFieldEnum[];
  };

  /**
   * Leccion findMany
   */
  export type LeccionFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Leccion
     */
    select?: LeccionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Leccion
     */
    omit?: LeccionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeccionInclude<ExtArgs> | null;
    /**
     * Filter, which Leccions to fetch.
     */
    where?: LeccionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Leccions to fetch.
     */
    orderBy?:
      | LeccionOrderByWithRelationInput
      | LeccionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Leccions.
     */
    cursor?: LeccionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Leccions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Leccions.
     */
    skip?: number;
    distinct?: LeccionScalarFieldEnum | LeccionScalarFieldEnum[];
  };

  /**
   * Leccion create
   */
  export type LeccionCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Leccion
     */
    select?: LeccionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Leccion
     */
    omit?: LeccionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeccionInclude<ExtArgs> | null;
    /**
     * The data needed to create a Leccion.
     */
    data: XOR<LeccionCreateInput, LeccionUncheckedCreateInput>;
  };

  /**
   * Leccion createMany
   */
  export type LeccionCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Leccions.
     */
    data: LeccionCreateManyInput | LeccionCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Leccion update
   */
  export type LeccionUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Leccion
     */
    select?: LeccionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Leccion
     */
    omit?: LeccionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeccionInclude<ExtArgs> | null;
    /**
     * The data needed to update a Leccion.
     */
    data: XOR<LeccionUpdateInput, LeccionUncheckedUpdateInput>;
    /**
     * Choose, which Leccion to update.
     */
    where: LeccionWhereUniqueInput;
  };

  /**
   * Leccion updateMany
   */
  export type LeccionUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Leccions.
     */
    data: XOR<LeccionUpdateManyMutationInput, LeccionUncheckedUpdateManyInput>;
    /**
     * Filter which Leccions to update
     */
    where?: LeccionWhereInput;
    /**
     * Limit how many Leccions to update.
     */
    limit?: number;
  };

  /**
   * Leccion upsert
   */
  export type LeccionUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Leccion
     */
    select?: LeccionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Leccion
     */
    omit?: LeccionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeccionInclude<ExtArgs> | null;
    /**
     * The filter to search for the Leccion to update in case it exists.
     */
    where: LeccionWhereUniqueInput;
    /**
     * In case the Leccion found by the `where` argument doesn't exist, create a new Leccion with this data.
     */
    create: XOR<LeccionCreateInput, LeccionUncheckedCreateInput>;
    /**
     * In case the Leccion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeccionUpdateInput, LeccionUncheckedUpdateInput>;
  };

  /**
   * Leccion delete
   */
  export type LeccionDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Leccion
     */
    select?: LeccionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Leccion
     */
    omit?: LeccionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeccionInclude<ExtArgs> | null;
    /**
     * Filter which Leccion to delete.
     */
    where: LeccionWhereUniqueInput;
  };

  /**
   * Leccion deleteMany
   */
  export type LeccionDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Leccions to delete
     */
    where?: LeccionWhereInput;
    /**
     * Limit how many Leccions to delete.
     */
    limit?: number;
  };

  /**
   * Leccion without action
   */
  export type LeccionDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Leccion
     */
    select?: LeccionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Leccion
     */
    omit?: LeccionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeccionInclude<ExtArgs> | null;
  };

  /**
   * Model LeccionTipoConfig
   */

  export type AggregateLeccionTipoConfig = {
    _count: LeccionTipoConfigCountAggregateOutputType | null;
    _avg: LeccionTipoConfigAvgAggregateOutputType | null;
    _sum: LeccionTipoConfigSumAggregateOutputType | null;
    _min: LeccionTipoConfigMinAggregateOutputType | null;
    _max: LeccionTipoConfigMaxAggregateOutputType | null;
  };

  export type LeccionTipoConfigAvgAggregateOutputType = {
    id: number | null;
    version: number | null;
  };

  export type LeccionTipoConfigSumAggregateOutputType = {
    id: number | null;
    version: number | null;
  };

  export type LeccionTipoConfigMinAggregateOutputType = {
    id: number | null;
    tipo: $Enums.TipoLeccion | null;
    version: number | null;
    creadoEn: Date | null;
    actualizadoEn: Date | null;
  };

  export type LeccionTipoConfigMaxAggregateOutputType = {
    id: number | null;
    tipo: $Enums.TipoLeccion | null;
    version: number | null;
    creadoEn: Date | null;
    actualizadoEn: Date | null;
  };

  export type LeccionTipoConfigCountAggregateOutputType = {
    id: number;
    tipo: number;
    schema: number;
    ui: number;
    version: number;
    creadoEn: number;
    actualizadoEn: number;
    _all: number;
  };

  export type LeccionTipoConfigAvgAggregateInputType = {
    id?: true;
    version?: true;
  };

  export type LeccionTipoConfigSumAggregateInputType = {
    id?: true;
    version?: true;
  };

  export type LeccionTipoConfigMinAggregateInputType = {
    id?: true;
    tipo?: true;
    version?: true;
    creadoEn?: true;
    actualizadoEn?: true;
  };

  export type LeccionTipoConfigMaxAggregateInputType = {
    id?: true;
    tipo?: true;
    version?: true;
    creadoEn?: true;
    actualizadoEn?: true;
  };

  export type LeccionTipoConfigCountAggregateInputType = {
    id?: true;
    tipo?: true;
    schema?: true;
    ui?: true;
    version?: true;
    creadoEn?: true;
    actualizadoEn?: true;
    _all?: true;
  };

  export type LeccionTipoConfigAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which LeccionTipoConfig to aggregate.
     */
    where?: LeccionTipoConfigWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of LeccionTipoConfigs to fetch.
     */
    orderBy?:
      | LeccionTipoConfigOrderByWithRelationInput
      | LeccionTipoConfigOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: LeccionTipoConfigWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` LeccionTipoConfigs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` LeccionTipoConfigs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned LeccionTipoConfigs
     **/
    _count?: true | LeccionTipoConfigCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: LeccionTipoConfigAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: LeccionTipoConfigSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: LeccionTipoConfigMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: LeccionTipoConfigMaxAggregateInputType;
  };

  export type GetLeccionTipoConfigAggregateType<
    T extends LeccionTipoConfigAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateLeccionTipoConfig]: P extends
      | '_count'
      | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeccionTipoConfig[P]>
      : GetScalarType<T[P], AggregateLeccionTipoConfig[P]>;
  };

  export type LeccionTipoConfigGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: LeccionTipoConfigWhereInput;
    orderBy?:
      | LeccionTipoConfigOrderByWithAggregationInput
      | LeccionTipoConfigOrderByWithAggregationInput[];
    by: LeccionTipoConfigScalarFieldEnum[] | LeccionTipoConfigScalarFieldEnum;
    having?: LeccionTipoConfigScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: LeccionTipoConfigCountAggregateInputType | true;
    _avg?: LeccionTipoConfigAvgAggregateInputType;
    _sum?: LeccionTipoConfigSumAggregateInputType;
    _min?: LeccionTipoConfigMinAggregateInputType;
    _max?: LeccionTipoConfigMaxAggregateInputType;
  };

  export type LeccionTipoConfigGroupByOutputType = {
    id: number;
    tipo: $Enums.TipoLeccion;
    schema: JsonValue;
    ui: JsonValue | null;
    version: number;
    creadoEn: Date;
    actualizadoEn: Date;
    _count: LeccionTipoConfigCountAggregateOutputType | null;
    _avg: LeccionTipoConfigAvgAggregateOutputType | null;
    _sum: LeccionTipoConfigSumAggregateOutputType | null;
    _min: LeccionTipoConfigMinAggregateOutputType | null;
    _max: LeccionTipoConfigMaxAggregateOutputType | null;
  };

  type GetLeccionTipoConfigGroupByPayload<
    T extends LeccionTipoConfigGroupByArgs,
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeccionTipoConfigGroupByOutputType, T['by']> & {
        [P in keyof T &
          keyof LeccionTipoConfigGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], LeccionTipoConfigGroupByOutputType[P]>
          : GetScalarType<T[P], LeccionTipoConfigGroupByOutputType[P]>;
      }
    >
  >;

  export type LeccionTipoConfigSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      tipo?: boolean;
      schema?: boolean;
      ui?: boolean;
      version?: boolean;
      creadoEn?: boolean;
      actualizadoEn?: boolean;
    },
    ExtArgs['result']['leccionTipoConfig']
  >;

  export type LeccionTipoConfigSelectScalar = {
    id?: boolean;
    tipo?: boolean;
    schema?: boolean;
    ui?: boolean;
    version?: boolean;
    creadoEn?: boolean;
    actualizadoEn?: boolean;
  };

  export type LeccionTipoConfigOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    'id' | 'tipo' | 'schema' | 'ui' | 'version' | 'creadoEn' | 'actualizadoEn',
    ExtArgs['result']['leccionTipoConfig']
  >;

  export type $LeccionTipoConfigPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'LeccionTipoConfig';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        tipo: $Enums.TipoLeccion;
        schema: Prisma.JsonValue;
        ui: Prisma.JsonValue | null;
        version: number;
        creadoEn: Date;
        actualizadoEn: Date;
      },
      ExtArgs['result']['leccionTipoConfig']
    >;
    composites: {};
  };

  type LeccionTipoConfigGetPayload<
    S extends boolean | null | undefined | LeccionTipoConfigDefaultArgs,
  > = $Result.GetResult<Prisma.$LeccionTipoConfigPayload, S>;

  type LeccionTipoConfigCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    LeccionTipoConfigFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: LeccionTipoConfigCountAggregateInputType | true;
  };

  export interface LeccionTipoConfigDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['LeccionTipoConfig'];
      meta: { name: 'LeccionTipoConfig' };
    };
    /**
     * Find zero or one LeccionTipoConfig that matches the filter.
     * @param {LeccionTipoConfigFindUniqueArgs} args - Arguments to find a LeccionTipoConfig
     * @example
     * // Get one LeccionTipoConfig
     * const leccionTipoConfig = await prisma.leccionTipoConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeccionTipoConfigFindUniqueArgs>(
      args: SelectSubset<T, LeccionTipoConfigFindUniqueArgs<ExtArgs>>,
    ): Prisma__LeccionTipoConfigClient<
      $Result.GetResult<
        Prisma.$LeccionTipoConfigPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one LeccionTipoConfig that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeccionTipoConfigFindUniqueOrThrowArgs} args - Arguments to find a LeccionTipoConfig
     * @example
     * // Get one LeccionTipoConfig
     * const leccionTipoConfig = await prisma.leccionTipoConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeccionTipoConfigFindUniqueOrThrowArgs>(
      args: SelectSubset<T, LeccionTipoConfigFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__LeccionTipoConfigClient<
      $Result.GetResult<
        Prisma.$LeccionTipoConfigPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first LeccionTipoConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeccionTipoConfigFindFirstArgs} args - Arguments to find a LeccionTipoConfig
     * @example
     * // Get one LeccionTipoConfig
     * const leccionTipoConfig = await prisma.leccionTipoConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeccionTipoConfigFindFirstArgs>(
      args?: SelectSubset<T, LeccionTipoConfigFindFirstArgs<ExtArgs>>,
    ): Prisma__LeccionTipoConfigClient<
      $Result.GetResult<
        Prisma.$LeccionTipoConfigPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first LeccionTipoConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeccionTipoConfigFindFirstOrThrowArgs} args - Arguments to find a LeccionTipoConfig
     * @example
     * // Get one LeccionTipoConfig
     * const leccionTipoConfig = await prisma.leccionTipoConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeccionTipoConfigFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LeccionTipoConfigFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__LeccionTipoConfigClient<
      $Result.GetResult<
        Prisma.$LeccionTipoConfigPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more LeccionTipoConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeccionTipoConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LeccionTipoConfigs
     * const leccionTipoConfigs = await prisma.leccionTipoConfig.findMany()
     *
     * // Get first 10 LeccionTipoConfigs
     * const leccionTipoConfigs = await prisma.leccionTipoConfig.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const leccionTipoConfigWithIdOnly = await prisma.leccionTipoConfig.findMany({ select: { id: true } })
     *
     */
    findMany<T extends LeccionTipoConfigFindManyArgs>(
      args?: SelectSubset<T, LeccionTipoConfigFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$LeccionTipoConfigPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a LeccionTipoConfig.
     * @param {LeccionTipoConfigCreateArgs} args - Arguments to create a LeccionTipoConfig.
     * @example
     * // Create one LeccionTipoConfig
     * const LeccionTipoConfig = await prisma.leccionTipoConfig.create({
     *   data: {
     *     // ... data to create a LeccionTipoConfig
     *   }
     * })
     *
     */
    create<T extends LeccionTipoConfigCreateArgs>(
      args: SelectSubset<T, LeccionTipoConfigCreateArgs<ExtArgs>>,
    ): Prisma__LeccionTipoConfigClient<
      $Result.GetResult<
        Prisma.$LeccionTipoConfigPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many LeccionTipoConfigs.
     * @param {LeccionTipoConfigCreateManyArgs} args - Arguments to create many LeccionTipoConfigs.
     * @example
     * // Create many LeccionTipoConfigs
     * const leccionTipoConfig = await prisma.leccionTipoConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends LeccionTipoConfigCreateManyArgs>(
      args?: SelectSubset<T, LeccionTipoConfigCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a LeccionTipoConfig.
     * @param {LeccionTipoConfigDeleteArgs} args - Arguments to delete one LeccionTipoConfig.
     * @example
     * // Delete one LeccionTipoConfig
     * const LeccionTipoConfig = await prisma.leccionTipoConfig.delete({
     *   where: {
     *     // ... filter to delete one LeccionTipoConfig
     *   }
     * })
     *
     */
    delete<T extends LeccionTipoConfigDeleteArgs>(
      args: SelectSubset<T, LeccionTipoConfigDeleteArgs<ExtArgs>>,
    ): Prisma__LeccionTipoConfigClient<
      $Result.GetResult<
        Prisma.$LeccionTipoConfigPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one LeccionTipoConfig.
     * @param {LeccionTipoConfigUpdateArgs} args - Arguments to update one LeccionTipoConfig.
     * @example
     * // Update one LeccionTipoConfig
     * const leccionTipoConfig = await prisma.leccionTipoConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends LeccionTipoConfigUpdateArgs>(
      args: SelectSubset<T, LeccionTipoConfigUpdateArgs<ExtArgs>>,
    ): Prisma__LeccionTipoConfigClient<
      $Result.GetResult<
        Prisma.$LeccionTipoConfigPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more LeccionTipoConfigs.
     * @param {LeccionTipoConfigDeleteManyArgs} args - Arguments to filter LeccionTipoConfigs to delete.
     * @example
     * // Delete a few LeccionTipoConfigs
     * const { count } = await prisma.leccionTipoConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends LeccionTipoConfigDeleteManyArgs>(
      args?: SelectSubset<T, LeccionTipoConfigDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more LeccionTipoConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeccionTipoConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LeccionTipoConfigs
     * const leccionTipoConfig = await prisma.leccionTipoConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends LeccionTipoConfigUpdateManyArgs>(
      args: SelectSubset<T, LeccionTipoConfigUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one LeccionTipoConfig.
     * @param {LeccionTipoConfigUpsertArgs} args - Arguments to update or create a LeccionTipoConfig.
     * @example
     * // Update or create a LeccionTipoConfig
     * const leccionTipoConfig = await prisma.leccionTipoConfig.upsert({
     *   create: {
     *     // ... data to create a LeccionTipoConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LeccionTipoConfig we want to update
     *   }
     * })
     */
    upsert<T extends LeccionTipoConfigUpsertArgs>(
      args: SelectSubset<T, LeccionTipoConfigUpsertArgs<ExtArgs>>,
    ): Prisma__LeccionTipoConfigClient<
      $Result.GetResult<
        Prisma.$LeccionTipoConfigPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of LeccionTipoConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeccionTipoConfigCountArgs} args - Arguments to filter LeccionTipoConfigs to count.
     * @example
     * // Count the number of LeccionTipoConfigs
     * const count = await prisma.leccionTipoConfig.count({
     *   where: {
     *     // ... the filter for the LeccionTipoConfigs we want to count
     *   }
     * })
     **/
    count<T extends LeccionTipoConfigCountArgs>(
      args?: Subset<T, LeccionTipoConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<
              T['select'],
              LeccionTipoConfigCountAggregateOutputType
            >
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a LeccionTipoConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeccionTipoConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends LeccionTipoConfigAggregateArgs>(
      args: Subset<T, LeccionTipoConfigAggregateArgs>,
    ): Prisma.PrismaPromise<GetLeccionTipoConfigAggregateType<T>>;

    /**
     * Group by LeccionTipoConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeccionTipoConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends LeccionTipoConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeccionTipoConfigGroupByArgs['orderBy'] }
        : { orderBy?: LeccionTipoConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, LeccionTipoConfigGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetLeccionTipoConfigGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the LeccionTipoConfig model
     */
    readonly fields: LeccionTipoConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LeccionTipoConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeccionTipoConfigClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the LeccionTipoConfig model
   */
  interface LeccionTipoConfigFieldRefs {
    readonly id: FieldRef<'LeccionTipoConfig', 'Int'>;
    readonly tipo: FieldRef<'LeccionTipoConfig', 'TipoLeccion'>;
    readonly schema: FieldRef<'LeccionTipoConfig', 'Json'>;
    readonly ui: FieldRef<'LeccionTipoConfig', 'Json'>;
    readonly version: FieldRef<'LeccionTipoConfig', 'Int'>;
    readonly creadoEn: FieldRef<'LeccionTipoConfig', 'DateTime'>;
    readonly actualizadoEn: FieldRef<'LeccionTipoConfig', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * LeccionTipoConfig findUnique
   */
  export type LeccionTipoConfigFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LeccionTipoConfig
     */
    select?: LeccionTipoConfigSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LeccionTipoConfig
     */
    omit?: LeccionTipoConfigOmit<ExtArgs> | null;
    /**
     * Filter, which LeccionTipoConfig to fetch.
     */
    where: LeccionTipoConfigWhereUniqueInput;
  };

  /**
   * LeccionTipoConfig findUniqueOrThrow
   */
  export type LeccionTipoConfigFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LeccionTipoConfig
     */
    select?: LeccionTipoConfigSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LeccionTipoConfig
     */
    omit?: LeccionTipoConfigOmit<ExtArgs> | null;
    /**
     * Filter, which LeccionTipoConfig to fetch.
     */
    where: LeccionTipoConfigWhereUniqueInput;
  };

  /**
   * LeccionTipoConfig findFirst
   */
  export type LeccionTipoConfigFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LeccionTipoConfig
     */
    select?: LeccionTipoConfigSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LeccionTipoConfig
     */
    omit?: LeccionTipoConfigOmit<ExtArgs> | null;
    /**
     * Filter, which LeccionTipoConfig to fetch.
     */
    where?: LeccionTipoConfigWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of LeccionTipoConfigs to fetch.
     */
    orderBy?:
      | LeccionTipoConfigOrderByWithRelationInput
      | LeccionTipoConfigOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for LeccionTipoConfigs.
     */
    cursor?: LeccionTipoConfigWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` LeccionTipoConfigs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` LeccionTipoConfigs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of LeccionTipoConfigs.
     */
    distinct?:
      | LeccionTipoConfigScalarFieldEnum
      | LeccionTipoConfigScalarFieldEnum[];
  };

  /**
   * LeccionTipoConfig findFirstOrThrow
   */
  export type LeccionTipoConfigFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LeccionTipoConfig
     */
    select?: LeccionTipoConfigSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LeccionTipoConfig
     */
    omit?: LeccionTipoConfigOmit<ExtArgs> | null;
    /**
     * Filter, which LeccionTipoConfig to fetch.
     */
    where?: LeccionTipoConfigWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of LeccionTipoConfigs to fetch.
     */
    orderBy?:
      | LeccionTipoConfigOrderByWithRelationInput
      | LeccionTipoConfigOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for LeccionTipoConfigs.
     */
    cursor?: LeccionTipoConfigWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` LeccionTipoConfigs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` LeccionTipoConfigs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of LeccionTipoConfigs.
     */
    distinct?:
      | LeccionTipoConfigScalarFieldEnum
      | LeccionTipoConfigScalarFieldEnum[];
  };

  /**
   * LeccionTipoConfig findMany
   */
  export type LeccionTipoConfigFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LeccionTipoConfig
     */
    select?: LeccionTipoConfigSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LeccionTipoConfig
     */
    omit?: LeccionTipoConfigOmit<ExtArgs> | null;
    /**
     * Filter, which LeccionTipoConfigs to fetch.
     */
    where?: LeccionTipoConfigWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of LeccionTipoConfigs to fetch.
     */
    orderBy?:
      | LeccionTipoConfigOrderByWithRelationInput
      | LeccionTipoConfigOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing LeccionTipoConfigs.
     */
    cursor?: LeccionTipoConfigWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` LeccionTipoConfigs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` LeccionTipoConfigs.
     */
    skip?: number;
    distinct?:
      | LeccionTipoConfigScalarFieldEnum
      | LeccionTipoConfigScalarFieldEnum[];
  };

  /**
   * LeccionTipoConfig create
   */
  export type LeccionTipoConfigCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LeccionTipoConfig
     */
    select?: LeccionTipoConfigSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LeccionTipoConfig
     */
    omit?: LeccionTipoConfigOmit<ExtArgs> | null;
    /**
     * The data needed to create a LeccionTipoConfig.
     */
    data: XOR<
      LeccionTipoConfigCreateInput,
      LeccionTipoConfigUncheckedCreateInput
    >;
  };

  /**
   * LeccionTipoConfig createMany
   */
  export type LeccionTipoConfigCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many LeccionTipoConfigs.
     */
    data: LeccionTipoConfigCreateManyInput | LeccionTipoConfigCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * LeccionTipoConfig update
   */
  export type LeccionTipoConfigUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LeccionTipoConfig
     */
    select?: LeccionTipoConfigSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LeccionTipoConfig
     */
    omit?: LeccionTipoConfigOmit<ExtArgs> | null;
    /**
     * The data needed to update a LeccionTipoConfig.
     */
    data: XOR<
      LeccionTipoConfigUpdateInput,
      LeccionTipoConfigUncheckedUpdateInput
    >;
    /**
     * Choose, which LeccionTipoConfig to update.
     */
    where: LeccionTipoConfigWhereUniqueInput;
  };

  /**
   * LeccionTipoConfig updateMany
   */
  export type LeccionTipoConfigUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update LeccionTipoConfigs.
     */
    data: XOR<
      LeccionTipoConfigUpdateManyMutationInput,
      LeccionTipoConfigUncheckedUpdateManyInput
    >;
    /**
     * Filter which LeccionTipoConfigs to update
     */
    where?: LeccionTipoConfigWhereInput;
    /**
     * Limit how many LeccionTipoConfigs to update.
     */
    limit?: number;
  };

  /**
   * LeccionTipoConfig upsert
   */
  export type LeccionTipoConfigUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LeccionTipoConfig
     */
    select?: LeccionTipoConfigSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LeccionTipoConfig
     */
    omit?: LeccionTipoConfigOmit<ExtArgs> | null;
    /**
     * The filter to search for the LeccionTipoConfig to update in case it exists.
     */
    where: LeccionTipoConfigWhereUniqueInput;
    /**
     * In case the LeccionTipoConfig found by the `where` argument doesn't exist, create a new LeccionTipoConfig with this data.
     */
    create: XOR<
      LeccionTipoConfigCreateInput,
      LeccionTipoConfigUncheckedCreateInput
    >;
    /**
     * In case the LeccionTipoConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      LeccionTipoConfigUpdateInput,
      LeccionTipoConfigUncheckedUpdateInput
    >;
  };

  /**
   * LeccionTipoConfig delete
   */
  export type LeccionTipoConfigDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LeccionTipoConfig
     */
    select?: LeccionTipoConfigSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LeccionTipoConfig
     */
    omit?: LeccionTipoConfigOmit<ExtArgs> | null;
    /**
     * Filter which LeccionTipoConfig to delete.
     */
    where: LeccionTipoConfigWhereUniqueInput;
  };

  /**
   * LeccionTipoConfig deleteMany
   */
  export type LeccionTipoConfigDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which LeccionTipoConfigs to delete
     */
    where?: LeccionTipoConfigWhereInput;
    /**
     * Limit how many LeccionTipoConfigs to delete.
     */
    limit?: number;
  };

  /**
   * LeccionTipoConfig without action
   */
  export type LeccionTipoConfigDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LeccionTipoConfig
     */
    select?: LeccionTipoConfigSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LeccionTipoConfig
     */
    omit?: LeccionTipoConfigOmit<ExtArgs> | null;
  };

  /**
   * Model Producto
   */

  export type AggregateProducto = {
    _count: ProductoCountAggregateOutputType | null;
    _avg: ProductoAvgAggregateOutputType | null;
    _sum: ProductoSumAggregateOutputType | null;
    _min: ProductoMinAggregateOutputType | null;
    _max: ProductoMaxAggregateOutputType | null;
  };

  export type ProductoAvgAggregateOutputType = {
    id: number | null;
    precio: number | null;
    stock: number | null;
    precioLista: number | null;
    ratingProm: Decimal | null;
    ratingConteo: number | null;
    marcaId: number | null;
    categoriaId: number | null;
  };

  export type ProductoSumAggregateOutputType = {
    id: number | null;
    precio: number | null;
    stock: number | null;
    precioLista: number | null;
    ratingProm: Decimal | null;
    ratingConteo: number | null;
    marcaId: number | null;
    categoriaId: number | null;
  };

  export type ProductoMinAggregateOutputType = {
    id: number | null;
    slug: string | null;
    titulo: string | null;
    precio: number | null;
    stock: number | null;
    publicado: boolean | null;
    destacado: boolean | null;
    imagen: string | null;
    descripcionMD: string | null;
    precioLista: number | null;
    ratingProm: Decimal | null;
    ratingConteo: number | null;
    creadoEn: Date | null;
    marcaId: number | null;
    categoriaId: number | null;
  };

  export type ProductoMaxAggregateOutputType = {
    id: number | null;
    slug: string | null;
    titulo: string | null;
    precio: number | null;
    stock: number | null;
    publicado: boolean | null;
    destacado: boolean | null;
    imagen: string | null;
    descripcionMD: string | null;
    precioLista: number | null;
    ratingProm: Decimal | null;
    ratingConteo: number | null;
    creadoEn: Date | null;
    marcaId: number | null;
    categoriaId: number | null;
  };

  export type ProductoCountAggregateOutputType = {
    id: number;
    slug: number;
    titulo: number;
    precio: number;
    stock: number;
    publicado: number;
    destacado: number;
    imagen: number;
    descripcionMD: number;
    precioLista: number;
    ratingProm: number;
    ratingConteo: number;
    creadoEn: number;
    marcaId: number;
    categoriaId: number;
    _all: number;
  };

  export type ProductoAvgAggregateInputType = {
    id?: true;
    precio?: true;
    stock?: true;
    precioLista?: true;
    ratingProm?: true;
    ratingConteo?: true;
    marcaId?: true;
    categoriaId?: true;
  };

  export type ProductoSumAggregateInputType = {
    id?: true;
    precio?: true;
    stock?: true;
    precioLista?: true;
    ratingProm?: true;
    ratingConteo?: true;
    marcaId?: true;
    categoriaId?: true;
  };

  export type ProductoMinAggregateInputType = {
    id?: true;
    slug?: true;
    titulo?: true;
    precio?: true;
    stock?: true;
    publicado?: true;
    destacado?: true;
    imagen?: true;
    descripcionMD?: true;
    precioLista?: true;
    ratingProm?: true;
    ratingConteo?: true;
    creadoEn?: true;
    marcaId?: true;
    categoriaId?: true;
  };

  export type ProductoMaxAggregateInputType = {
    id?: true;
    slug?: true;
    titulo?: true;
    precio?: true;
    stock?: true;
    publicado?: true;
    destacado?: true;
    imagen?: true;
    descripcionMD?: true;
    precioLista?: true;
    ratingProm?: true;
    ratingConteo?: true;
    creadoEn?: true;
    marcaId?: true;
    categoriaId?: true;
  };

  export type ProductoCountAggregateInputType = {
    id?: true;
    slug?: true;
    titulo?: true;
    precio?: true;
    stock?: true;
    publicado?: true;
    destacado?: true;
    imagen?: true;
    descripcionMD?: true;
    precioLista?: true;
    ratingProm?: true;
    ratingConteo?: true;
    creadoEn?: true;
    marcaId?: true;
    categoriaId?: true;
    _all?: true;
  };

  export type ProductoAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Producto to aggregate.
     */
    where?: ProductoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Productos to fetch.
     */
    orderBy?:
      | ProductoOrderByWithRelationInput
      | ProductoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ProductoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Productos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Productos.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Productos
     **/
    _count?: true | ProductoCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ProductoAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ProductoSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ProductoMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ProductoMaxAggregateInputType;
  };

  export type GetProductoAggregateType<T extends ProductoAggregateArgs> = {
    [P in keyof T & keyof AggregateProducto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProducto[P]>
      : GetScalarType<T[P], AggregateProducto[P]>;
  };

  export type ProductoGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ProductoWhereInput;
    orderBy?:
      | ProductoOrderByWithAggregationInput
      | ProductoOrderByWithAggregationInput[];
    by: ProductoScalarFieldEnum[] | ProductoScalarFieldEnum;
    having?: ProductoScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ProductoCountAggregateInputType | true;
    _avg?: ProductoAvgAggregateInputType;
    _sum?: ProductoSumAggregateInputType;
    _min?: ProductoMinAggregateInputType;
    _max?: ProductoMaxAggregateInputType;
  };

  export type ProductoGroupByOutputType = {
    id: number;
    slug: string;
    titulo: string;
    precio: number;
    stock: number;
    publicado: boolean;
    destacado: boolean;
    imagen: string | null;
    descripcionMD: string | null;
    precioLista: number | null;
    ratingProm: Decimal | null;
    ratingConteo: number;
    creadoEn: Date;
    marcaId: number | null;
    categoriaId: number | null;
    _count: ProductoCountAggregateOutputType | null;
    _avg: ProductoAvgAggregateOutputType | null;
    _sum: ProductoSumAggregateOutputType | null;
    _min: ProductoMinAggregateOutputType | null;
    _max: ProductoMaxAggregateOutputType | null;
  };

  type GetProductoGroupByPayload<T extends ProductoGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ProductoGroupByOutputType, T['by']> & {
          [P in keyof T & keyof ProductoGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductoGroupByOutputType[P]>
            : GetScalarType<T[P], ProductoGroupByOutputType[P]>;
        }
      >
    >;

  export type ProductoSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      slug?: boolean;
      titulo?: boolean;
      precio?: boolean;
      stock?: boolean;
      publicado?: boolean;
      destacado?: boolean;
      imagen?: boolean;
      descripcionMD?: boolean;
      precioLista?: boolean;
      ratingProm?: boolean;
      ratingConteo?: boolean;
      creadoEn?: boolean;
      marcaId?: boolean;
      categoriaId?: boolean;
      marca?: boolean | Producto$marcaArgs<ExtArgs>;
      categoria?: boolean | Producto$categoriaArgs<ExtArgs>;
      imagenes?: boolean | Producto$imagenesArgs<ExtArgs>;
      resenas?: boolean | Producto$resenasArgs<ExtArgs>;
      favoritos?: boolean | Producto$favoritosArgs<ExtArgs>;
      itemsCarrito?: boolean | Producto$itemsCarritoArgs<ExtArgs>;
      _count?: boolean | ProductoCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['producto']
  >;

  export type ProductoSelectScalar = {
    id?: boolean;
    slug?: boolean;
    titulo?: boolean;
    precio?: boolean;
    stock?: boolean;
    publicado?: boolean;
    destacado?: boolean;
    imagen?: boolean;
    descripcionMD?: boolean;
    precioLista?: boolean;
    ratingProm?: boolean;
    ratingConteo?: boolean;
    creadoEn?: boolean;
    marcaId?: boolean;
    categoriaId?: boolean;
  };

  export type ProductoOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'slug'
    | 'titulo'
    | 'precio'
    | 'stock'
    | 'publicado'
    | 'destacado'
    | 'imagen'
    | 'descripcionMD'
    | 'precioLista'
    | 'ratingProm'
    | 'ratingConteo'
    | 'creadoEn'
    | 'marcaId'
    | 'categoriaId',
    ExtArgs['result']['producto']
  >;
  export type ProductoInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    marca?: boolean | Producto$marcaArgs<ExtArgs>;
    categoria?: boolean | Producto$categoriaArgs<ExtArgs>;
    imagenes?: boolean | Producto$imagenesArgs<ExtArgs>;
    resenas?: boolean | Producto$resenasArgs<ExtArgs>;
    favoritos?: boolean | Producto$favoritosArgs<ExtArgs>;
    itemsCarrito?: boolean | Producto$itemsCarritoArgs<ExtArgs>;
    _count?: boolean | ProductoCountOutputTypeDefaultArgs<ExtArgs>;
  };

  export type $ProductoPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Producto';
    objects: {
      marca: Prisma.$MarcaPayload<ExtArgs> | null;
      categoria: Prisma.$CategoriaPayload<ExtArgs> | null;
      imagenes: Prisma.$ProductoImagenPayload<ExtArgs>[];
      resenas: Prisma.$ResenaPayload<ExtArgs>[];
      favoritos: Prisma.$FavoritoPayload<ExtArgs>[];
      itemsCarrito: Prisma.$ItemCarritoPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        slug: string;
        titulo: string;
        precio: number;
        stock: number;
        publicado: boolean;
        destacado: boolean;
        imagen: string | null;
        descripcionMD: string | null;
        precioLista: number | null;
        ratingProm: Prisma.Decimal | null;
        ratingConteo: number;
        creadoEn: Date;
        marcaId: number | null;
        categoriaId: number | null;
      },
      ExtArgs['result']['producto']
    >;
    composites: {};
  };

  type ProductoGetPayload<
    S extends boolean | null | undefined | ProductoDefaultArgs,
  > = $Result.GetResult<Prisma.$ProductoPayload, S>;

  type ProductoCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<ProductoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: ProductoCountAggregateInputType | true;
  };

  export interface ProductoDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Producto'];
      meta: { name: 'Producto' };
    };
    /**
     * Find zero or one Producto that matches the filter.
     * @param {ProductoFindUniqueArgs} args - Arguments to find a Producto
     * @example
     * // Get one Producto
     * const producto = await prisma.producto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductoFindUniqueArgs>(
      args: SelectSubset<T, ProductoFindUniqueArgs<ExtArgs>>,
    ): Prisma__ProductoClient<
      $Result.GetResult<
        Prisma.$ProductoPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Producto that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductoFindUniqueOrThrowArgs} args - Arguments to find a Producto
     * @example
     * // Get one Producto
     * const producto = await prisma.producto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductoFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ProductoFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__ProductoClient<
      $Result.GetResult<
        Prisma.$ProductoPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Producto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoFindFirstArgs} args - Arguments to find a Producto
     * @example
     * // Get one Producto
     * const producto = await prisma.producto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductoFindFirstArgs>(
      args?: SelectSubset<T, ProductoFindFirstArgs<ExtArgs>>,
    ): Prisma__ProductoClient<
      $Result.GetResult<
        Prisma.$ProductoPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Producto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoFindFirstOrThrowArgs} args - Arguments to find a Producto
     * @example
     * // Get one Producto
     * const producto = await prisma.producto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ProductoFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__ProductoClient<
      $Result.GetResult<
        Prisma.$ProductoPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Productos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Productos
     * const productos = await prisma.producto.findMany()
     *
     * // Get first 10 Productos
     * const productos = await prisma.producto.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const productoWithIdOnly = await prisma.producto.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ProductoFindManyArgs>(
      args?: SelectSubset<T, ProductoFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ProductoPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Producto.
     * @param {ProductoCreateArgs} args - Arguments to create a Producto.
     * @example
     * // Create one Producto
     * const Producto = await prisma.producto.create({
     *   data: {
     *     // ... data to create a Producto
     *   }
     * })
     *
     */
    create<T extends ProductoCreateArgs>(
      args: SelectSubset<T, ProductoCreateArgs<ExtArgs>>,
    ): Prisma__ProductoClient<
      $Result.GetResult<
        Prisma.$ProductoPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Productos.
     * @param {ProductoCreateManyArgs} args - Arguments to create many Productos.
     * @example
     * // Create many Productos
     * const producto = await prisma.producto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ProductoCreateManyArgs>(
      args?: SelectSubset<T, ProductoCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Producto.
     * @param {ProductoDeleteArgs} args - Arguments to delete one Producto.
     * @example
     * // Delete one Producto
     * const Producto = await prisma.producto.delete({
     *   where: {
     *     // ... filter to delete one Producto
     *   }
     * })
     *
     */
    delete<T extends ProductoDeleteArgs>(
      args: SelectSubset<T, ProductoDeleteArgs<ExtArgs>>,
    ): Prisma__ProductoClient<
      $Result.GetResult<
        Prisma.$ProductoPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Producto.
     * @param {ProductoUpdateArgs} args - Arguments to update one Producto.
     * @example
     * // Update one Producto
     * const producto = await prisma.producto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ProductoUpdateArgs>(
      args: SelectSubset<T, ProductoUpdateArgs<ExtArgs>>,
    ): Prisma__ProductoClient<
      $Result.GetResult<
        Prisma.$ProductoPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Productos.
     * @param {ProductoDeleteManyArgs} args - Arguments to filter Productos to delete.
     * @example
     * // Delete a few Productos
     * const { count } = await prisma.producto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ProductoDeleteManyArgs>(
      args?: SelectSubset<T, ProductoDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Productos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Productos
     * const producto = await prisma.producto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ProductoUpdateManyArgs>(
      args: SelectSubset<T, ProductoUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Producto.
     * @param {ProductoUpsertArgs} args - Arguments to update or create a Producto.
     * @example
     * // Update or create a Producto
     * const producto = await prisma.producto.upsert({
     *   create: {
     *     // ... data to create a Producto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Producto we want to update
     *   }
     * })
     */
    upsert<T extends ProductoUpsertArgs>(
      args: SelectSubset<T, ProductoUpsertArgs<ExtArgs>>,
    ): Prisma__ProductoClient<
      $Result.GetResult<
        Prisma.$ProductoPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Productos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoCountArgs} args - Arguments to filter Productos to count.
     * @example
     * // Count the number of Productos
     * const count = await prisma.producto.count({
     *   where: {
     *     // ... the filter for the Productos we want to count
     *   }
     * })
     **/
    count<T extends ProductoCountArgs>(
      args?: Subset<T, ProductoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductoCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Producto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ProductoAggregateArgs>(
      args: Subset<T, ProductoAggregateArgs>,
    ): Prisma.PrismaPromise<GetProductoAggregateType<T>>;

    /**
     * Group by Producto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ProductoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductoGroupByArgs['orderBy'] }
        : { orderBy?: ProductoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ProductoGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetProductoGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Producto model
     */
    readonly fields: ProductoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Producto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductoClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    marca<T extends Producto$marcaArgs<ExtArgs> = {}>(
      args?: Subset<T, Producto$marcaArgs<ExtArgs>>,
    ): Prisma__MarcaClient<
      $Result.GetResult<
        Prisma.$MarcaPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    categoria<T extends Producto$categoriaArgs<ExtArgs> = {}>(
      args?: Subset<T, Producto$categoriaArgs<ExtArgs>>,
    ): Prisma__CategoriaClient<
      $Result.GetResult<
        Prisma.$CategoriaPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    imagenes<T extends Producto$imagenesArgs<ExtArgs> = {}>(
      args?: Subset<T, Producto$imagenesArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$ProductoImagenPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    resenas<T extends Producto$resenasArgs<ExtArgs> = {}>(
      args?: Subset<T, Producto$resenasArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$ResenaPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    favoritos<T extends Producto$favoritosArgs<ExtArgs> = {}>(
      args?: Subset<T, Producto$favoritosArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$FavoritoPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    itemsCarrito<T extends Producto$itemsCarritoArgs<ExtArgs> = {}>(
      args?: Subset<T, Producto$itemsCarritoArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$ItemCarritoPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Producto model
   */
  interface ProductoFieldRefs {
    readonly id: FieldRef<'Producto', 'Int'>;
    readonly slug: FieldRef<'Producto', 'String'>;
    readonly titulo: FieldRef<'Producto', 'String'>;
    readonly precio: FieldRef<'Producto', 'Int'>;
    readonly stock: FieldRef<'Producto', 'Int'>;
    readonly publicado: FieldRef<'Producto', 'Boolean'>;
    readonly destacado: FieldRef<'Producto', 'Boolean'>;
    readonly imagen: FieldRef<'Producto', 'String'>;
    readonly descripcionMD: FieldRef<'Producto', 'String'>;
    readonly precioLista: FieldRef<'Producto', 'Int'>;
    readonly ratingProm: FieldRef<'Producto', 'Decimal'>;
    readonly ratingConteo: FieldRef<'Producto', 'Int'>;
    readonly creadoEn: FieldRef<'Producto', 'DateTime'>;
    readonly marcaId: FieldRef<'Producto', 'Int'>;
    readonly categoriaId: FieldRef<'Producto', 'Int'>;
  }

  // Custom InputTypes
  /**
   * Producto findUnique
   */
  export type ProductoFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Producto
     */
    omit?: ProductoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoInclude<ExtArgs> | null;
    /**
     * Filter, which Producto to fetch.
     */
    where: ProductoWhereUniqueInput;
  };

  /**
   * Producto findUniqueOrThrow
   */
  export type ProductoFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Producto
     */
    omit?: ProductoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoInclude<ExtArgs> | null;
    /**
     * Filter, which Producto to fetch.
     */
    where: ProductoWhereUniqueInput;
  };

  /**
   * Producto findFirst
   */
  export type ProductoFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Producto
     */
    omit?: ProductoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoInclude<ExtArgs> | null;
    /**
     * Filter, which Producto to fetch.
     */
    where?: ProductoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Productos to fetch.
     */
    orderBy?:
      | ProductoOrderByWithRelationInput
      | ProductoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Productos.
     */
    cursor?: ProductoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Productos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Productos.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Productos.
     */
    distinct?: ProductoScalarFieldEnum | ProductoScalarFieldEnum[];
  };

  /**
   * Producto findFirstOrThrow
   */
  export type ProductoFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Producto
     */
    omit?: ProductoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoInclude<ExtArgs> | null;
    /**
     * Filter, which Producto to fetch.
     */
    where?: ProductoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Productos to fetch.
     */
    orderBy?:
      | ProductoOrderByWithRelationInput
      | ProductoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Productos.
     */
    cursor?: ProductoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Productos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Productos.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Productos.
     */
    distinct?: ProductoScalarFieldEnum | ProductoScalarFieldEnum[];
  };

  /**
   * Producto findMany
   */
  export type ProductoFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Producto
     */
    omit?: ProductoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoInclude<ExtArgs> | null;
    /**
     * Filter, which Productos to fetch.
     */
    where?: ProductoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Productos to fetch.
     */
    orderBy?:
      | ProductoOrderByWithRelationInput
      | ProductoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Productos.
     */
    cursor?: ProductoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Productos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Productos.
     */
    skip?: number;
    distinct?: ProductoScalarFieldEnum | ProductoScalarFieldEnum[];
  };

  /**
   * Producto create
   */
  export type ProductoCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Producto
     */
    omit?: ProductoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoInclude<ExtArgs> | null;
    /**
     * The data needed to create a Producto.
     */
    data: XOR<ProductoCreateInput, ProductoUncheckedCreateInput>;
  };

  /**
   * Producto createMany
   */
  export type ProductoCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Productos.
     */
    data: ProductoCreateManyInput | ProductoCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Producto update
   */
  export type ProductoUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Producto
     */
    omit?: ProductoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoInclude<ExtArgs> | null;
    /**
     * The data needed to update a Producto.
     */
    data: XOR<ProductoUpdateInput, ProductoUncheckedUpdateInput>;
    /**
     * Choose, which Producto to update.
     */
    where: ProductoWhereUniqueInput;
  };

  /**
   * Producto updateMany
   */
  export type ProductoUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Productos.
     */
    data: XOR<
      ProductoUpdateManyMutationInput,
      ProductoUncheckedUpdateManyInput
    >;
    /**
     * Filter which Productos to update
     */
    where?: ProductoWhereInput;
    /**
     * Limit how many Productos to update.
     */
    limit?: number;
  };

  /**
   * Producto upsert
   */
  export type ProductoUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Producto
     */
    omit?: ProductoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoInclude<ExtArgs> | null;
    /**
     * The filter to search for the Producto to update in case it exists.
     */
    where: ProductoWhereUniqueInput;
    /**
     * In case the Producto found by the `where` argument doesn't exist, create a new Producto with this data.
     */
    create: XOR<ProductoCreateInput, ProductoUncheckedCreateInput>;
    /**
     * In case the Producto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductoUpdateInput, ProductoUncheckedUpdateInput>;
  };

  /**
   * Producto delete
   */
  export type ProductoDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Producto
     */
    omit?: ProductoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoInclude<ExtArgs> | null;
    /**
     * Filter which Producto to delete.
     */
    where: ProductoWhereUniqueInput;
  };

  /**
   * Producto deleteMany
   */
  export type ProductoDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Productos to delete
     */
    where?: ProductoWhereInput;
    /**
     * Limit how many Productos to delete.
     */
    limit?: number;
  };

  /**
   * Producto.marca
   */
  export type Producto$marcaArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Marca
     */
    select?: MarcaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Marca
     */
    omit?: MarcaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarcaInclude<ExtArgs> | null;
    where?: MarcaWhereInput;
  };

  /**
   * Producto.categoria
   */
  export type Producto$categoriaArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Categoria
     */
    omit?: CategoriaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null;
    where?: CategoriaWhereInput;
  };

  /**
   * Producto.imagenes
   */
  export type Producto$imagenesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProductoImagen
     */
    select?: ProductoImagenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProductoImagen
     */
    omit?: ProductoImagenOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoImagenInclude<ExtArgs> | null;
    where?: ProductoImagenWhereInput;
    orderBy?:
      | ProductoImagenOrderByWithRelationInput
      | ProductoImagenOrderByWithRelationInput[];
    cursor?: ProductoImagenWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ProductoImagenScalarFieldEnum | ProductoImagenScalarFieldEnum[];
  };

  /**
   * Producto.resenas
   */
  export type Producto$resenasArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Resena
     */
    select?: ResenaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Resena
     */
    omit?: ResenaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaInclude<ExtArgs> | null;
    where?: ResenaWhereInput;
    orderBy?: ResenaOrderByWithRelationInput | ResenaOrderByWithRelationInput[];
    cursor?: ResenaWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ResenaScalarFieldEnum | ResenaScalarFieldEnum[];
  };

  /**
   * Producto.favoritos
   */
  export type Producto$favoritosArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Favorito
     */
    select?: FavoritoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Favorito
     */
    omit?: FavoritoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoritoInclude<ExtArgs> | null;
    where?: FavoritoWhereInput;
    orderBy?:
      | FavoritoOrderByWithRelationInput
      | FavoritoOrderByWithRelationInput[];
    cursor?: FavoritoWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: FavoritoScalarFieldEnum | FavoritoScalarFieldEnum[];
  };

  /**
   * Producto.itemsCarrito
   */
  export type Producto$itemsCarritoArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ItemCarrito
     */
    select?: ItemCarritoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ItemCarrito
     */
    omit?: ItemCarritoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCarritoInclude<ExtArgs> | null;
    where?: ItemCarritoWhereInput;
    orderBy?:
      | ItemCarritoOrderByWithRelationInput
      | ItemCarritoOrderByWithRelationInput[];
    cursor?: ItemCarritoWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ItemCarritoScalarFieldEnum | ItemCarritoScalarFieldEnum[];
  };

  /**
   * Producto without action
   */
  export type ProductoDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Producto
     */
    omit?: ProductoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoInclude<ExtArgs> | null;
  };

  /**
   * Model ProductoImagen
   */

  export type AggregateProductoImagen = {
    _count: ProductoImagenCountAggregateOutputType | null;
    _avg: ProductoImagenAvgAggregateOutputType | null;
    _sum: ProductoImagenSumAggregateOutputType | null;
    _min: ProductoImagenMinAggregateOutputType | null;
    _max: ProductoImagenMaxAggregateOutputType | null;
  };

  export type ProductoImagenAvgAggregateOutputType = {
    id: number | null;
    productoId: number | null;
    orden: number | null;
  };

  export type ProductoImagenSumAggregateOutputType = {
    id: number | null;
    productoId: number | null;
    orden: number | null;
  };

  export type ProductoImagenMinAggregateOutputType = {
    id: number | null;
    productoId: number | null;
    archivo: string | null;
    alt: string | null;
    orden: number | null;
  };

  export type ProductoImagenMaxAggregateOutputType = {
    id: number | null;
    productoId: number | null;
    archivo: string | null;
    alt: string | null;
    orden: number | null;
  };

  export type ProductoImagenCountAggregateOutputType = {
    id: number;
    productoId: number;
    archivo: number;
    alt: number;
    orden: number;
    _all: number;
  };

  export type ProductoImagenAvgAggregateInputType = {
    id?: true;
    productoId?: true;
    orden?: true;
  };

  export type ProductoImagenSumAggregateInputType = {
    id?: true;
    productoId?: true;
    orden?: true;
  };

  export type ProductoImagenMinAggregateInputType = {
    id?: true;
    productoId?: true;
    archivo?: true;
    alt?: true;
    orden?: true;
  };

  export type ProductoImagenMaxAggregateInputType = {
    id?: true;
    productoId?: true;
    archivo?: true;
    alt?: true;
    orden?: true;
  };

  export type ProductoImagenCountAggregateInputType = {
    id?: true;
    productoId?: true;
    archivo?: true;
    alt?: true;
    orden?: true;
    _all?: true;
  };

  export type ProductoImagenAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ProductoImagen to aggregate.
     */
    where?: ProductoImagenWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ProductoImagens to fetch.
     */
    orderBy?:
      | ProductoImagenOrderByWithRelationInput
      | ProductoImagenOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ProductoImagenWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ProductoImagens from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ProductoImagens.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned ProductoImagens
     **/
    _count?: true | ProductoImagenCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ProductoImagenAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ProductoImagenSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ProductoImagenMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ProductoImagenMaxAggregateInputType;
  };

  export type GetProductoImagenAggregateType<
    T extends ProductoImagenAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateProductoImagen]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductoImagen[P]>
      : GetScalarType<T[P], AggregateProductoImagen[P]>;
  };

  export type ProductoImagenGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ProductoImagenWhereInput;
    orderBy?:
      | ProductoImagenOrderByWithAggregationInput
      | ProductoImagenOrderByWithAggregationInput[];
    by: ProductoImagenScalarFieldEnum[] | ProductoImagenScalarFieldEnum;
    having?: ProductoImagenScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ProductoImagenCountAggregateInputType | true;
    _avg?: ProductoImagenAvgAggregateInputType;
    _sum?: ProductoImagenSumAggregateInputType;
    _min?: ProductoImagenMinAggregateInputType;
    _max?: ProductoImagenMaxAggregateInputType;
  };

  export type ProductoImagenGroupByOutputType = {
    id: number;
    productoId: number;
    archivo: string;
    alt: string | null;
    orden: number;
    _count: ProductoImagenCountAggregateOutputType | null;
    _avg: ProductoImagenAvgAggregateOutputType | null;
    _sum: ProductoImagenSumAggregateOutputType | null;
    _min: ProductoImagenMinAggregateOutputType | null;
    _max: ProductoImagenMaxAggregateOutputType | null;
  };

  type GetProductoImagenGroupByPayload<T extends ProductoImagenGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ProductoImagenGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof ProductoImagenGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductoImagenGroupByOutputType[P]>
            : GetScalarType<T[P], ProductoImagenGroupByOutputType[P]>;
        }
      >
    >;

  export type ProductoImagenSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      productoId?: boolean;
      archivo?: boolean;
      alt?: boolean;
      orden?: boolean;
      producto?: boolean | ProductoDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['productoImagen']
  >;

  export type ProductoImagenSelectScalar = {
    id?: boolean;
    productoId?: boolean;
    archivo?: boolean;
    alt?: boolean;
    orden?: boolean;
  };

  export type ProductoImagenOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    'id' | 'productoId' | 'archivo' | 'alt' | 'orden',
    ExtArgs['result']['productoImagen']
  >;
  export type ProductoImagenInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    producto?: boolean | ProductoDefaultArgs<ExtArgs>;
  };

  export type $ProductoImagenPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'ProductoImagen';
    objects: {
      producto: Prisma.$ProductoPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        productoId: number;
        archivo: string;
        alt: string | null;
        orden: number;
      },
      ExtArgs['result']['productoImagen']
    >;
    composites: {};
  };

  type ProductoImagenGetPayload<
    S extends boolean | null | undefined | ProductoImagenDefaultArgs,
  > = $Result.GetResult<Prisma.$ProductoImagenPayload, S>;

  type ProductoImagenCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    ProductoImagenFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: ProductoImagenCountAggregateInputType | true;
  };

  export interface ProductoImagenDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['ProductoImagen'];
      meta: { name: 'ProductoImagen' };
    };
    /**
     * Find zero or one ProductoImagen that matches the filter.
     * @param {ProductoImagenFindUniqueArgs} args - Arguments to find a ProductoImagen
     * @example
     * // Get one ProductoImagen
     * const productoImagen = await prisma.productoImagen.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductoImagenFindUniqueArgs>(
      args: SelectSubset<T, ProductoImagenFindUniqueArgs<ExtArgs>>,
    ): Prisma__ProductoImagenClient<
      $Result.GetResult<
        Prisma.$ProductoImagenPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one ProductoImagen that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductoImagenFindUniqueOrThrowArgs} args - Arguments to find a ProductoImagen
     * @example
     * // Get one ProductoImagen
     * const productoImagen = await prisma.productoImagen.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductoImagenFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ProductoImagenFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__ProductoImagenClient<
      $Result.GetResult<
        Prisma.$ProductoImagenPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ProductoImagen that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoImagenFindFirstArgs} args - Arguments to find a ProductoImagen
     * @example
     * // Get one ProductoImagen
     * const productoImagen = await prisma.productoImagen.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductoImagenFindFirstArgs>(
      args?: SelectSubset<T, ProductoImagenFindFirstArgs<ExtArgs>>,
    ): Prisma__ProductoImagenClient<
      $Result.GetResult<
        Prisma.$ProductoImagenPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ProductoImagen that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoImagenFindFirstOrThrowArgs} args - Arguments to find a ProductoImagen
     * @example
     * // Get one ProductoImagen
     * const productoImagen = await prisma.productoImagen.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductoImagenFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ProductoImagenFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__ProductoImagenClient<
      $Result.GetResult<
        Prisma.$ProductoImagenPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more ProductoImagens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoImagenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductoImagens
     * const productoImagens = await prisma.productoImagen.findMany()
     *
     * // Get first 10 ProductoImagens
     * const productoImagens = await prisma.productoImagen.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const productoImagenWithIdOnly = await prisma.productoImagen.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ProductoImagenFindManyArgs>(
      args?: SelectSubset<T, ProductoImagenFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ProductoImagenPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a ProductoImagen.
     * @param {ProductoImagenCreateArgs} args - Arguments to create a ProductoImagen.
     * @example
     * // Create one ProductoImagen
     * const ProductoImagen = await prisma.productoImagen.create({
     *   data: {
     *     // ... data to create a ProductoImagen
     *   }
     * })
     *
     */
    create<T extends ProductoImagenCreateArgs>(
      args: SelectSubset<T, ProductoImagenCreateArgs<ExtArgs>>,
    ): Prisma__ProductoImagenClient<
      $Result.GetResult<
        Prisma.$ProductoImagenPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many ProductoImagens.
     * @param {ProductoImagenCreateManyArgs} args - Arguments to create many ProductoImagens.
     * @example
     * // Create many ProductoImagens
     * const productoImagen = await prisma.productoImagen.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ProductoImagenCreateManyArgs>(
      args?: SelectSubset<T, ProductoImagenCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a ProductoImagen.
     * @param {ProductoImagenDeleteArgs} args - Arguments to delete one ProductoImagen.
     * @example
     * // Delete one ProductoImagen
     * const ProductoImagen = await prisma.productoImagen.delete({
     *   where: {
     *     // ... filter to delete one ProductoImagen
     *   }
     * })
     *
     */
    delete<T extends ProductoImagenDeleteArgs>(
      args: SelectSubset<T, ProductoImagenDeleteArgs<ExtArgs>>,
    ): Prisma__ProductoImagenClient<
      $Result.GetResult<
        Prisma.$ProductoImagenPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one ProductoImagen.
     * @param {ProductoImagenUpdateArgs} args - Arguments to update one ProductoImagen.
     * @example
     * // Update one ProductoImagen
     * const productoImagen = await prisma.productoImagen.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ProductoImagenUpdateArgs>(
      args: SelectSubset<T, ProductoImagenUpdateArgs<ExtArgs>>,
    ): Prisma__ProductoImagenClient<
      $Result.GetResult<
        Prisma.$ProductoImagenPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more ProductoImagens.
     * @param {ProductoImagenDeleteManyArgs} args - Arguments to filter ProductoImagens to delete.
     * @example
     * // Delete a few ProductoImagens
     * const { count } = await prisma.productoImagen.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ProductoImagenDeleteManyArgs>(
      args?: SelectSubset<T, ProductoImagenDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ProductoImagens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoImagenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductoImagens
     * const productoImagen = await prisma.productoImagen.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ProductoImagenUpdateManyArgs>(
      args: SelectSubset<T, ProductoImagenUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one ProductoImagen.
     * @param {ProductoImagenUpsertArgs} args - Arguments to update or create a ProductoImagen.
     * @example
     * // Update or create a ProductoImagen
     * const productoImagen = await prisma.productoImagen.upsert({
     *   create: {
     *     // ... data to create a ProductoImagen
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductoImagen we want to update
     *   }
     * })
     */
    upsert<T extends ProductoImagenUpsertArgs>(
      args: SelectSubset<T, ProductoImagenUpsertArgs<ExtArgs>>,
    ): Prisma__ProductoImagenClient<
      $Result.GetResult<
        Prisma.$ProductoImagenPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of ProductoImagens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoImagenCountArgs} args - Arguments to filter ProductoImagens to count.
     * @example
     * // Count the number of ProductoImagens
     * const count = await prisma.productoImagen.count({
     *   where: {
     *     // ... the filter for the ProductoImagens we want to count
     *   }
     * })
     **/
    count<T extends ProductoImagenCountArgs>(
      args?: Subset<T, ProductoImagenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductoImagenCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a ProductoImagen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoImagenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ProductoImagenAggregateArgs>(
      args: Subset<T, ProductoImagenAggregateArgs>,
    ): Prisma.PrismaPromise<GetProductoImagenAggregateType<T>>;

    /**
     * Group by ProductoImagen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoImagenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ProductoImagenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductoImagenGroupByArgs['orderBy'] }
        : { orderBy?: ProductoImagenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ProductoImagenGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetProductoImagenGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the ProductoImagen model
     */
    readonly fields: ProductoImagenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductoImagen.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductoImagenClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    producto<T extends ProductoDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, ProductoDefaultArgs<ExtArgs>>,
    ): Prisma__ProductoClient<
      | $Result.GetResult<
          Prisma.$ProductoPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the ProductoImagen model
   */
  interface ProductoImagenFieldRefs {
    readonly id: FieldRef<'ProductoImagen', 'Int'>;
    readonly productoId: FieldRef<'ProductoImagen', 'Int'>;
    readonly archivo: FieldRef<'ProductoImagen', 'String'>;
    readonly alt: FieldRef<'ProductoImagen', 'String'>;
    readonly orden: FieldRef<'ProductoImagen', 'Int'>;
  }

  // Custom InputTypes
  /**
   * ProductoImagen findUnique
   */
  export type ProductoImagenFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProductoImagen
     */
    select?: ProductoImagenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProductoImagen
     */
    omit?: ProductoImagenOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoImagenInclude<ExtArgs> | null;
    /**
     * Filter, which ProductoImagen to fetch.
     */
    where: ProductoImagenWhereUniqueInput;
  };

  /**
   * ProductoImagen findUniqueOrThrow
   */
  export type ProductoImagenFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProductoImagen
     */
    select?: ProductoImagenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProductoImagen
     */
    omit?: ProductoImagenOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoImagenInclude<ExtArgs> | null;
    /**
     * Filter, which ProductoImagen to fetch.
     */
    where: ProductoImagenWhereUniqueInput;
  };

  /**
   * ProductoImagen findFirst
   */
  export type ProductoImagenFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProductoImagen
     */
    select?: ProductoImagenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProductoImagen
     */
    omit?: ProductoImagenOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoImagenInclude<ExtArgs> | null;
    /**
     * Filter, which ProductoImagen to fetch.
     */
    where?: ProductoImagenWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ProductoImagens to fetch.
     */
    orderBy?:
      | ProductoImagenOrderByWithRelationInput
      | ProductoImagenOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ProductoImagens.
     */
    cursor?: ProductoImagenWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ProductoImagens from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ProductoImagens.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ProductoImagens.
     */
    distinct?: ProductoImagenScalarFieldEnum | ProductoImagenScalarFieldEnum[];
  };

  /**
   * ProductoImagen findFirstOrThrow
   */
  export type ProductoImagenFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProductoImagen
     */
    select?: ProductoImagenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProductoImagen
     */
    omit?: ProductoImagenOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoImagenInclude<ExtArgs> | null;
    /**
     * Filter, which ProductoImagen to fetch.
     */
    where?: ProductoImagenWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ProductoImagens to fetch.
     */
    orderBy?:
      | ProductoImagenOrderByWithRelationInput
      | ProductoImagenOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ProductoImagens.
     */
    cursor?: ProductoImagenWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ProductoImagens from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ProductoImagens.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ProductoImagens.
     */
    distinct?: ProductoImagenScalarFieldEnum | ProductoImagenScalarFieldEnum[];
  };

  /**
   * ProductoImagen findMany
   */
  export type ProductoImagenFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProductoImagen
     */
    select?: ProductoImagenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProductoImagen
     */
    omit?: ProductoImagenOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoImagenInclude<ExtArgs> | null;
    /**
     * Filter, which ProductoImagens to fetch.
     */
    where?: ProductoImagenWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ProductoImagens to fetch.
     */
    orderBy?:
      | ProductoImagenOrderByWithRelationInput
      | ProductoImagenOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing ProductoImagens.
     */
    cursor?: ProductoImagenWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ProductoImagens from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ProductoImagens.
     */
    skip?: number;
    distinct?: ProductoImagenScalarFieldEnum | ProductoImagenScalarFieldEnum[];
  };

  /**
   * ProductoImagen create
   */
  export type ProductoImagenCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProductoImagen
     */
    select?: ProductoImagenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProductoImagen
     */
    omit?: ProductoImagenOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoImagenInclude<ExtArgs> | null;
    /**
     * The data needed to create a ProductoImagen.
     */
    data: XOR<ProductoImagenCreateInput, ProductoImagenUncheckedCreateInput>;
  };

  /**
   * ProductoImagen createMany
   */
  export type ProductoImagenCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many ProductoImagens.
     */
    data: ProductoImagenCreateManyInput | ProductoImagenCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * ProductoImagen update
   */
  export type ProductoImagenUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProductoImagen
     */
    select?: ProductoImagenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProductoImagen
     */
    omit?: ProductoImagenOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoImagenInclude<ExtArgs> | null;
    /**
     * The data needed to update a ProductoImagen.
     */
    data: XOR<ProductoImagenUpdateInput, ProductoImagenUncheckedUpdateInput>;
    /**
     * Choose, which ProductoImagen to update.
     */
    where: ProductoImagenWhereUniqueInput;
  };

  /**
   * ProductoImagen updateMany
   */
  export type ProductoImagenUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update ProductoImagens.
     */
    data: XOR<
      ProductoImagenUpdateManyMutationInput,
      ProductoImagenUncheckedUpdateManyInput
    >;
    /**
     * Filter which ProductoImagens to update
     */
    where?: ProductoImagenWhereInput;
    /**
     * Limit how many ProductoImagens to update.
     */
    limit?: number;
  };

  /**
   * ProductoImagen upsert
   */
  export type ProductoImagenUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProductoImagen
     */
    select?: ProductoImagenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProductoImagen
     */
    omit?: ProductoImagenOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoImagenInclude<ExtArgs> | null;
    /**
     * The filter to search for the ProductoImagen to update in case it exists.
     */
    where: ProductoImagenWhereUniqueInput;
    /**
     * In case the ProductoImagen found by the `where` argument doesn't exist, create a new ProductoImagen with this data.
     */
    create: XOR<ProductoImagenCreateInput, ProductoImagenUncheckedCreateInput>;
    /**
     * In case the ProductoImagen was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductoImagenUpdateInput, ProductoImagenUncheckedUpdateInput>;
  };

  /**
   * ProductoImagen delete
   */
  export type ProductoImagenDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProductoImagen
     */
    select?: ProductoImagenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProductoImagen
     */
    omit?: ProductoImagenOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoImagenInclude<ExtArgs> | null;
    /**
     * Filter which ProductoImagen to delete.
     */
    where: ProductoImagenWhereUniqueInput;
  };

  /**
   * ProductoImagen deleteMany
   */
  export type ProductoImagenDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ProductoImagens to delete
     */
    where?: ProductoImagenWhereInput;
    /**
     * Limit how many ProductoImagens to delete.
     */
    limit?: number;
  };

  /**
   * ProductoImagen without action
   */
  export type ProductoImagenDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProductoImagen
     */
    select?: ProductoImagenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProductoImagen
     */
    omit?: ProductoImagenOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoImagenInclude<ExtArgs> | null;
  };

  /**
   * Model Marca
   */

  export type AggregateMarca = {
    _count: MarcaCountAggregateOutputType | null;
    _avg: MarcaAvgAggregateOutputType | null;
    _sum: MarcaSumAggregateOutputType | null;
    _min: MarcaMinAggregateOutputType | null;
    _max: MarcaMaxAggregateOutputType | null;
  };

  export type MarcaAvgAggregateOutputType = {
    id: number | null;
    orden: number | null;
  };

  export type MarcaSumAggregateOutputType = {
    id: number | null;
    orden: number | null;
  };

  export type MarcaMinAggregateOutputType = {
    id: number | null;
    slug: string | null;
    nombre: string | null;
    imagen: string | null;
    activa: boolean | null;
    orden: number | null;
    creadoEn: Date | null;
  };

  export type MarcaMaxAggregateOutputType = {
    id: number | null;
    slug: string | null;
    nombre: string | null;
    imagen: string | null;
    activa: boolean | null;
    orden: number | null;
    creadoEn: Date | null;
  };

  export type MarcaCountAggregateOutputType = {
    id: number;
    slug: number;
    nombre: number;
    imagen: number;
    activa: number;
    orden: number;
    creadoEn: number;
    _all: number;
  };

  export type MarcaAvgAggregateInputType = {
    id?: true;
    orden?: true;
  };

  export type MarcaSumAggregateInputType = {
    id?: true;
    orden?: true;
  };

  export type MarcaMinAggregateInputType = {
    id?: true;
    slug?: true;
    nombre?: true;
    imagen?: true;
    activa?: true;
    orden?: true;
    creadoEn?: true;
  };

  export type MarcaMaxAggregateInputType = {
    id?: true;
    slug?: true;
    nombre?: true;
    imagen?: true;
    activa?: true;
    orden?: true;
    creadoEn?: true;
  };

  export type MarcaCountAggregateInputType = {
    id?: true;
    slug?: true;
    nombre?: true;
    imagen?: true;
    activa?: true;
    orden?: true;
    creadoEn?: true;
    _all?: true;
  };

  export type MarcaAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Marca to aggregate.
     */
    where?: MarcaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Marcas to fetch.
     */
    orderBy?: MarcaOrderByWithRelationInput | MarcaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: MarcaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Marcas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Marcas.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Marcas
     **/
    _count?: true | MarcaCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: MarcaAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: MarcaSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: MarcaMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: MarcaMaxAggregateInputType;
  };

  export type GetMarcaAggregateType<T extends MarcaAggregateArgs> = {
    [P in keyof T & keyof AggregateMarca]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarca[P]>
      : GetScalarType<T[P], AggregateMarca[P]>;
  };

  export type MarcaGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: MarcaWhereInput;
    orderBy?:
      | MarcaOrderByWithAggregationInput
      | MarcaOrderByWithAggregationInput[];
    by: MarcaScalarFieldEnum[] | MarcaScalarFieldEnum;
    having?: MarcaScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: MarcaCountAggregateInputType | true;
    _avg?: MarcaAvgAggregateInputType;
    _sum?: MarcaSumAggregateInputType;
    _min?: MarcaMinAggregateInputType;
    _max?: MarcaMaxAggregateInputType;
  };

  export type MarcaGroupByOutputType = {
    id: number;
    slug: string;
    nombre: string;
    imagen: string | null;
    activa: boolean;
    orden: number;
    creadoEn: Date;
    _count: MarcaCountAggregateOutputType | null;
    _avg: MarcaAvgAggregateOutputType | null;
    _sum: MarcaSumAggregateOutputType | null;
    _min: MarcaMinAggregateOutputType | null;
    _max: MarcaMaxAggregateOutputType | null;
  };

  type GetMarcaGroupByPayload<T extends MarcaGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<MarcaGroupByOutputType, T['by']> & {
          [P in keyof T & keyof MarcaGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MarcaGroupByOutputType[P]>
            : GetScalarType<T[P], MarcaGroupByOutputType[P]>;
        }
      >
    >;

  export type MarcaSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      slug?: boolean;
      nombre?: boolean;
      imagen?: boolean;
      activa?: boolean;
      orden?: boolean;
      creadoEn?: boolean;
      productos?: boolean | Marca$productosArgs<ExtArgs>;
      _count?: boolean | MarcaCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['marca']
  >;

  export type MarcaSelectScalar = {
    id?: boolean;
    slug?: boolean;
    nombre?: boolean;
    imagen?: boolean;
    activa?: boolean;
    orden?: boolean;
    creadoEn?: boolean;
  };

  export type MarcaOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    'id' | 'slug' | 'nombre' | 'imagen' | 'activa' | 'orden' | 'creadoEn',
    ExtArgs['result']['marca']
  >;
  export type MarcaInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    productos?: boolean | Marca$productosArgs<ExtArgs>;
    _count?: boolean | MarcaCountOutputTypeDefaultArgs<ExtArgs>;
  };

  export type $MarcaPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Marca';
    objects: {
      productos: Prisma.$ProductoPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        slug: string;
        nombre: string;
        imagen: string | null;
        activa: boolean;
        orden: number;
        creadoEn: Date;
      },
      ExtArgs['result']['marca']
    >;
    composites: {};
  };

  type MarcaGetPayload<
    S extends boolean | null | undefined | MarcaDefaultArgs,
  > = $Result.GetResult<Prisma.$MarcaPayload, S>;

  type MarcaCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<MarcaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: MarcaCountAggregateInputType | true;
  };

  export interface MarcaDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Marca'];
      meta: { name: 'Marca' };
    };
    /**
     * Find zero or one Marca that matches the filter.
     * @param {MarcaFindUniqueArgs} args - Arguments to find a Marca
     * @example
     * // Get one Marca
     * const marca = await prisma.marca.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MarcaFindUniqueArgs>(
      args: SelectSubset<T, MarcaFindUniqueArgs<ExtArgs>>,
    ): Prisma__MarcaClient<
      $Result.GetResult<
        Prisma.$MarcaPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Marca that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MarcaFindUniqueOrThrowArgs} args - Arguments to find a Marca
     * @example
     * // Get one Marca
     * const marca = await prisma.marca.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MarcaFindUniqueOrThrowArgs>(
      args: SelectSubset<T, MarcaFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__MarcaClient<
      $Result.GetResult<
        Prisma.$MarcaPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Marca that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarcaFindFirstArgs} args - Arguments to find a Marca
     * @example
     * // Get one Marca
     * const marca = await prisma.marca.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MarcaFindFirstArgs>(
      args?: SelectSubset<T, MarcaFindFirstArgs<ExtArgs>>,
    ): Prisma__MarcaClient<
      $Result.GetResult<
        Prisma.$MarcaPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Marca that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarcaFindFirstOrThrowArgs} args - Arguments to find a Marca
     * @example
     * // Get one Marca
     * const marca = await prisma.marca.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MarcaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MarcaFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__MarcaClient<
      $Result.GetResult<
        Prisma.$MarcaPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Marcas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarcaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Marcas
     * const marcas = await prisma.marca.findMany()
     *
     * // Get first 10 Marcas
     * const marcas = await prisma.marca.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const marcaWithIdOnly = await prisma.marca.findMany({ select: { id: true } })
     *
     */
    findMany<T extends MarcaFindManyArgs>(
      args?: SelectSubset<T, MarcaFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$MarcaPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Marca.
     * @param {MarcaCreateArgs} args - Arguments to create a Marca.
     * @example
     * // Create one Marca
     * const Marca = await prisma.marca.create({
     *   data: {
     *     // ... data to create a Marca
     *   }
     * })
     *
     */
    create<T extends MarcaCreateArgs>(
      args: SelectSubset<T, MarcaCreateArgs<ExtArgs>>,
    ): Prisma__MarcaClient<
      $Result.GetResult<
        Prisma.$MarcaPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Marcas.
     * @param {MarcaCreateManyArgs} args - Arguments to create many Marcas.
     * @example
     * // Create many Marcas
     * const marca = await prisma.marca.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends MarcaCreateManyArgs>(
      args?: SelectSubset<T, MarcaCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Marca.
     * @param {MarcaDeleteArgs} args - Arguments to delete one Marca.
     * @example
     * // Delete one Marca
     * const Marca = await prisma.marca.delete({
     *   where: {
     *     // ... filter to delete one Marca
     *   }
     * })
     *
     */
    delete<T extends MarcaDeleteArgs>(
      args: SelectSubset<T, MarcaDeleteArgs<ExtArgs>>,
    ): Prisma__MarcaClient<
      $Result.GetResult<
        Prisma.$MarcaPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Marca.
     * @param {MarcaUpdateArgs} args - Arguments to update one Marca.
     * @example
     * // Update one Marca
     * const marca = await prisma.marca.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends MarcaUpdateArgs>(
      args: SelectSubset<T, MarcaUpdateArgs<ExtArgs>>,
    ): Prisma__MarcaClient<
      $Result.GetResult<
        Prisma.$MarcaPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Marcas.
     * @param {MarcaDeleteManyArgs} args - Arguments to filter Marcas to delete.
     * @example
     * // Delete a few Marcas
     * const { count } = await prisma.marca.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends MarcaDeleteManyArgs>(
      args?: SelectSubset<T, MarcaDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Marcas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarcaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Marcas
     * const marca = await prisma.marca.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends MarcaUpdateManyArgs>(
      args: SelectSubset<T, MarcaUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Marca.
     * @param {MarcaUpsertArgs} args - Arguments to update or create a Marca.
     * @example
     * // Update or create a Marca
     * const marca = await prisma.marca.upsert({
     *   create: {
     *     // ... data to create a Marca
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Marca we want to update
     *   }
     * })
     */
    upsert<T extends MarcaUpsertArgs>(
      args: SelectSubset<T, MarcaUpsertArgs<ExtArgs>>,
    ): Prisma__MarcaClient<
      $Result.GetResult<
        Prisma.$MarcaPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Marcas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarcaCountArgs} args - Arguments to filter Marcas to count.
     * @example
     * // Count the number of Marcas
     * const count = await prisma.marca.count({
     *   where: {
     *     // ... the filter for the Marcas we want to count
     *   }
     * })
     **/
    count<T extends MarcaCountArgs>(
      args?: Subset<T, MarcaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MarcaCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Marca.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarcaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends MarcaAggregateArgs>(
      args: Subset<T, MarcaAggregateArgs>,
    ): Prisma.PrismaPromise<GetMarcaAggregateType<T>>;

    /**
     * Group by Marca.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarcaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends MarcaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MarcaGroupByArgs['orderBy'] }
        : { orderBy?: MarcaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, MarcaGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetMarcaGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Marca model
     */
    readonly fields: MarcaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Marca.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MarcaClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    productos<T extends Marca$productosArgs<ExtArgs> = {}>(
      args?: Subset<T, Marca$productosArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$ProductoPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Marca model
   */
  interface MarcaFieldRefs {
    readonly id: FieldRef<'Marca', 'Int'>;
    readonly slug: FieldRef<'Marca', 'String'>;
    readonly nombre: FieldRef<'Marca', 'String'>;
    readonly imagen: FieldRef<'Marca', 'String'>;
    readonly activa: FieldRef<'Marca', 'Boolean'>;
    readonly orden: FieldRef<'Marca', 'Int'>;
    readonly creadoEn: FieldRef<'Marca', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Marca findUnique
   */
  export type MarcaFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Marca
     */
    select?: MarcaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Marca
     */
    omit?: MarcaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarcaInclude<ExtArgs> | null;
    /**
     * Filter, which Marca to fetch.
     */
    where: MarcaWhereUniqueInput;
  };

  /**
   * Marca findUniqueOrThrow
   */
  export type MarcaFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Marca
     */
    select?: MarcaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Marca
     */
    omit?: MarcaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarcaInclude<ExtArgs> | null;
    /**
     * Filter, which Marca to fetch.
     */
    where: MarcaWhereUniqueInput;
  };

  /**
   * Marca findFirst
   */
  export type MarcaFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Marca
     */
    select?: MarcaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Marca
     */
    omit?: MarcaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarcaInclude<ExtArgs> | null;
    /**
     * Filter, which Marca to fetch.
     */
    where?: MarcaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Marcas to fetch.
     */
    orderBy?: MarcaOrderByWithRelationInput | MarcaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Marcas.
     */
    cursor?: MarcaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Marcas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Marcas.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Marcas.
     */
    distinct?: MarcaScalarFieldEnum | MarcaScalarFieldEnum[];
  };

  /**
   * Marca findFirstOrThrow
   */
  export type MarcaFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Marca
     */
    select?: MarcaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Marca
     */
    omit?: MarcaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarcaInclude<ExtArgs> | null;
    /**
     * Filter, which Marca to fetch.
     */
    where?: MarcaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Marcas to fetch.
     */
    orderBy?: MarcaOrderByWithRelationInput | MarcaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Marcas.
     */
    cursor?: MarcaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Marcas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Marcas.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Marcas.
     */
    distinct?: MarcaScalarFieldEnum | MarcaScalarFieldEnum[];
  };

  /**
   * Marca findMany
   */
  export type MarcaFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Marca
     */
    select?: MarcaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Marca
     */
    omit?: MarcaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarcaInclude<ExtArgs> | null;
    /**
     * Filter, which Marcas to fetch.
     */
    where?: MarcaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Marcas to fetch.
     */
    orderBy?: MarcaOrderByWithRelationInput | MarcaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Marcas.
     */
    cursor?: MarcaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Marcas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Marcas.
     */
    skip?: number;
    distinct?: MarcaScalarFieldEnum | MarcaScalarFieldEnum[];
  };

  /**
   * Marca create
   */
  export type MarcaCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Marca
     */
    select?: MarcaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Marca
     */
    omit?: MarcaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarcaInclude<ExtArgs> | null;
    /**
     * The data needed to create a Marca.
     */
    data: XOR<MarcaCreateInput, MarcaUncheckedCreateInput>;
  };

  /**
   * Marca createMany
   */
  export type MarcaCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Marcas.
     */
    data: MarcaCreateManyInput | MarcaCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Marca update
   */
  export type MarcaUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Marca
     */
    select?: MarcaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Marca
     */
    omit?: MarcaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarcaInclude<ExtArgs> | null;
    /**
     * The data needed to update a Marca.
     */
    data: XOR<MarcaUpdateInput, MarcaUncheckedUpdateInput>;
    /**
     * Choose, which Marca to update.
     */
    where: MarcaWhereUniqueInput;
  };

  /**
   * Marca updateMany
   */
  export type MarcaUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Marcas.
     */
    data: XOR<MarcaUpdateManyMutationInput, MarcaUncheckedUpdateManyInput>;
    /**
     * Filter which Marcas to update
     */
    where?: MarcaWhereInput;
    /**
     * Limit how many Marcas to update.
     */
    limit?: number;
  };

  /**
   * Marca upsert
   */
  export type MarcaUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Marca
     */
    select?: MarcaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Marca
     */
    omit?: MarcaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarcaInclude<ExtArgs> | null;
    /**
     * The filter to search for the Marca to update in case it exists.
     */
    where: MarcaWhereUniqueInput;
    /**
     * In case the Marca found by the `where` argument doesn't exist, create a new Marca with this data.
     */
    create: XOR<MarcaCreateInput, MarcaUncheckedCreateInput>;
    /**
     * In case the Marca was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MarcaUpdateInput, MarcaUncheckedUpdateInput>;
  };

  /**
   * Marca delete
   */
  export type MarcaDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Marca
     */
    select?: MarcaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Marca
     */
    omit?: MarcaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarcaInclude<ExtArgs> | null;
    /**
     * Filter which Marca to delete.
     */
    where: MarcaWhereUniqueInput;
  };

  /**
   * Marca deleteMany
   */
  export type MarcaDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Marcas to delete
     */
    where?: MarcaWhereInput;
    /**
     * Limit how many Marcas to delete.
     */
    limit?: number;
  };

  /**
   * Marca.productos
   */
  export type Marca$productosArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Producto
     */
    omit?: ProductoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoInclude<ExtArgs> | null;
    where?: ProductoWhereInput;
    orderBy?:
      | ProductoOrderByWithRelationInput
      | ProductoOrderByWithRelationInput[];
    cursor?: ProductoWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ProductoScalarFieldEnum | ProductoScalarFieldEnum[];
  };

  /**
   * Marca without action
   */
  export type MarcaDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Marca
     */
    select?: MarcaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Marca
     */
    omit?: MarcaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarcaInclude<ExtArgs> | null;
  };

  /**
   * Model Categoria
   */

  export type AggregateCategoria = {
    _count: CategoriaCountAggregateOutputType | null;
    _avg: CategoriaAvgAggregateOutputType | null;
    _sum: CategoriaSumAggregateOutputType | null;
    _min: CategoriaMinAggregateOutputType | null;
    _max: CategoriaMaxAggregateOutputType | null;
  };

  export type CategoriaAvgAggregateOutputType = {
    id: number | null;
    orden: number | null;
    parentId: number | null;
  };

  export type CategoriaSumAggregateOutputType = {
    id: number | null;
    orden: number | null;
    parentId: number | null;
  };

  export type CategoriaMinAggregateOutputType = {
    id: number | null;
    slug: string | null;
    nombre: string | null;
    descripcion: string | null;
    imagen: string | null;
    activa: boolean | null;
    orden: number | null;
    creadoEn: Date | null;
    parentId: number | null;
  };

  export type CategoriaMaxAggregateOutputType = {
    id: number | null;
    slug: string | null;
    nombre: string | null;
    descripcion: string | null;
    imagen: string | null;
    activa: boolean | null;
    orden: number | null;
    creadoEn: Date | null;
    parentId: number | null;
  };

  export type CategoriaCountAggregateOutputType = {
    id: number;
    slug: number;
    nombre: number;
    descripcion: number;
    imagen: number;
    activa: number;
    orden: number;
    creadoEn: number;
    parentId: number;
    _all: number;
  };

  export type CategoriaAvgAggregateInputType = {
    id?: true;
    orden?: true;
    parentId?: true;
  };

  export type CategoriaSumAggregateInputType = {
    id?: true;
    orden?: true;
    parentId?: true;
  };

  export type CategoriaMinAggregateInputType = {
    id?: true;
    slug?: true;
    nombre?: true;
    descripcion?: true;
    imagen?: true;
    activa?: true;
    orden?: true;
    creadoEn?: true;
    parentId?: true;
  };

  export type CategoriaMaxAggregateInputType = {
    id?: true;
    slug?: true;
    nombre?: true;
    descripcion?: true;
    imagen?: true;
    activa?: true;
    orden?: true;
    creadoEn?: true;
    parentId?: true;
  };

  export type CategoriaCountAggregateInputType = {
    id?: true;
    slug?: true;
    nombre?: true;
    descripcion?: true;
    imagen?: true;
    activa?: true;
    orden?: true;
    creadoEn?: true;
    parentId?: true;
    _all?: true;
  };

  export type CategoriaAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Categoria to aggregate.
     */
    where?: CategoriaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Categorias to fetch.
     */
    orderBy?:
      | CategoriaOrderByWithRelationInput
      | CategoriaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: CategoriaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Categorias from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Categorias.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Categorias
     **/
    _count?: true | CategoriaCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: CategoriaAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: CategoriaSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: CategoriaMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: CategoriaMaxAggregateInputType;
  };

  export type GetCategoriaAggregateType<T extends CategoriaAggregateArgs> = {
    [P in keyof T & keyof AggregateCategoria]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategoria[P]>
      : GetScalarType<T[P], AggregateCategoria[P]>;
  };

  export type CategoriaGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: CategoriaWhereInput;
    orderBy?:
      | CategoriaOrderByWithAggregationInput
      | CategoriaOrderByWithAggregationInput[];
    by: CategoriaScalarFieldEnum[] | CategoriaScalarFieldEnum;
    having?: CategoriaScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: CategoriaCountAggregateInputType | true;
    _avg?: CategoriaAvgAggregateInputType;
    _sum?: CategoriaSumAggregateInputType;
    _min?: CategoriaMinAggregateInputType;
    _max?: CategoriaMaxAggregateInputType;
  };

  export type CategoriaGroupByOutputType = {
    id: number;
    slug: string;
    nombre: string;
    descripcion: string | null;
    imagen: string | null;
    activa: boolean;
    orden: number;
    creadoEn: Date;
    parentId: number | null;
    _count: CategoriaCountAggregateOutputType | null;
    _avg: CategoriaAvgAggregateOutputType | null;
    _sum: CategoriaSumAggregateOutputType | null;
    _min: CategoriaMinAggregateOutputType | null;
    _max: CategoriaMaxAggregateOutputType | null;
  };

  type GetCategoriaGroupByPayload<T extends CategoriaGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<CategoriaGroupByOutputType, T['by']> & {
          [P in keyof T & keyof CategoriaGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoriaGroupByOutputType[P]>
            : GetScalarType<T[P], CategoriaGroupByOutputType[P]>;
        }
      >
    >;

  export type CategoriaSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      slug?: boolean;
      nombre?: boolean;
      descripcion?: boolean;
      imagen?: boolean;
      activa?: boolean;
      orden?: boolean;
      creadoEn?: boolean;
      parentId?: boolean;
      parent?: boolean | Categoria$parentArgs<ExtArgs>;
      hijos?: boolean | Categoria$hijosArgs<ExtArgs>;
      productos?: boolean | Categoria$productosArgs<ExtArgs>;
      _count?: boolean | CategoriaCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['categoria']
  >;

  export type CategoriaSelectScalar = {
    id?: boolean;
    slug?: boolean;
    nombre?: boolean;
    descripcion?: boolean;
    imagen?: boolean;
    activa?: boolean;
    orden?: boolean;
    creadoEn?: boolean;
    parentId?: boolean;
  };

  export type CategoriaOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'slug'
    | 'nombre'
    | 'descripcion'
    | 'imagen'
    | 'activa'
    | 'orden'
    | 'creadoEn'
    | 'parentId',
    ExtArgs['result']['categoria']
  >;
  export type CategoriaInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    parent?: boolean | Categoria$parentArgs<ExtArgs>;
    hijos?: boolean | Categoria$hijosArgs<ExtArgs>;
    productos?: boolean | Categoria$productosArgs<ExtArgs>;
    _count?: boolean | CategoriaCountOutputTypeDefaultArgs<ExtArgs>;
  };

  export type $CategoriaPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Categoria';
    objects: {
      parent: Prisma.$CategoriaPayload<ExtArgs> | null;
      hijos: Prisma.$CategoriaPayload<ExtArgs>[];
      productos: Prisma.$ProductoPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        slug: string;
        nombre: string;
        descripcion: string | null;
        imagen: string | null;
        activa: boolean;
        orden: number;
        creadoEn: Date;
        parentId: number | null;
      },
      ExtArgs['result']['categoria']
    >;
    composites: {};
  };

  type CategoriaGetPayload<
    S extends boolean | null | undefined | CategoriaDefaultArgs,
  > = $Result.GetResult<Prisma.$CategoriaPayload, S>;

  type CategoriaCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    CategoriaFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: CategoriaCountAggregateInputType | true;
  };

  export interface CategoriaDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Categoria'];
      meta: { name: 'Categoria' };
    };
    /**
     * Find zero or one Categoria that matches the filter.
     * @param {CategoriaFindUniqueArgs} args - Arguments to find a Categoria
     * @example
     * // Get one Categoria
     * const categoria = await prisma.categoria.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoriaFindUniqueArgs>(
      args: SelectSubset<T, CategoriaFindUniqueArgs<ExtArgs>>,
    ): Prisma__CategoriaClient<
      $Result.GetResult<
        Prisma.$CategoriaPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Categoria that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoriaFindUniqueOrThrowArgs} args - Arguments to find a Categoria
     * @example
     * // Get one Categoria
     * const categoria = await prisma.categoria.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoriaFindUniqueOrThrowArgs>(
      args: SelectSubset<T, CategoriaFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__CategoriaClient<
      $Result.GetResult<
        Prisma.$CategoriaPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Categoria that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaFindFirstArgs} args - Arguments to find a Categoria
     * @example
     * // Get one Categoria
     * const categoria = await prisma.categoria.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoriaFindFirstArgs>(
      args?: SelectSubset<T, CategoriaFindFirstArgs<ExtArgs>>,
    ): Prisma__CategoriaClient<
      $Result.GetResult<
        Prisma.$CategoriaPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Categoria that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaFindFirstOrThrowArgs} args - Arguments to find a Categoria
     * @example
     * // Get one Categoria
     * const categoria = await prisma.categoria.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoriaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CategoriaFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__CategoriaClient<
      $Result.GetResult<
        Prisma.$CategoriaPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Categorias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categorias
     * const categorias = await prisma.categoria.findMany()
     *
     * // Get first 10 Categorias
     * const categorias = await prisma.categoria.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const categoriaWithIdOnly = await prisma.categoria.findMany({ select: { id: true } })
     *
     */
    findMany<T extends CategoriaFindManyArgs>(
      args?: SelectSubset<T, CategoriaFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$CategoriaPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Categoria.
     * @param {CategoriaCreateArgs} args - Arguments to create a Categoria.
     * @example
     * // Create one Categoria
     * const Categoria = await prisma.categoria.create({
     *   data: {
     *     // ... data to create a Categoria
     *   }
     * })
     *
     */
    create<T extends CategoriaCreateArgs>(
      args: SelectSubset<T, CategoriaCreateArgs<ExtArgs>>,
    ): Prisma__CategoriaClient<
      $Result.GetResult<
        Prisma.$CategoriaPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Categorias.
     * @param {CategoriaCreateManyArgs} args - Arguments to create many Categorias.
     * @example
     * // Create many Categorias
     * const categoria = await prisma.categoria.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends CategoriaCreateManyArgs>(
      args?: SelectSubset<T, CategoriaCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Categoria.
     * @param {CategoriaDeleteArgs} args - Arguments to delete one Categoria.
     * @example
     * // Delete one Categoria
     * const Categoria = await prisma.categoria.delete({
     *   where: {
     *     // ... filter to delete one Categoria
     *   }
     * })
     *
     */
    delete<T extends CategoriaDeleteArgs>(
      args: SelectSubset<T, CategoriaDeleteArgs<ExtArgs>>,
    ): Prisma__CategoriaClient<
      $Result.GetResult<
        Prisma.$CategoriaPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Categoria.
     * @param {CategoriaUpdateArgs} args - Arguments to update one Categoria.
     * @example
     * // Update one Categoria
     * const categoria = await prisma.categoria.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends CategoriaUpdateArgs>(
      args: SelectSubset<T, CategoriaUpdateArgs<ExtArgs>>,
    ): Prisma__CategoriaClient<
      $Result.GetResult<
        Prisma.$CategoriaPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Categorias.
     * @param {CategoriaDeleteManyArgs} args - Arguments to filter Categorias to delete.
     * @example
     * // Delete a few Categorias
     * const { count } = await prisma.categoria.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends CategoriaDeleteManyArgs>(
      args?: SelectSubset<T, CategoriaDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Categorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categorias
     * const categoria = await prisma.categoria.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends CategoriaUpdateManyArgs>(
      args: SelectSubset<T, CategoriaUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Categoria.
     * @param {CategoriaUpsertArgs} args - Arguments to update or create a Categoria.
     * @example
     * // Update or create a Categoria
     * const categoria = await prisma.categoria.upsert({
     *   create: {
     *     // ... data to create a Categoria
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Categoria we want to update
     *   }
     * })
     */
    upsert<T extends CategoriaUpsertArgs>(
      args: SelectSubset<T, CategoriaUpsertArgs<ExtArgs>>,
    ): Prisma__CategoriaClient<
      $Result.GetResult<
        Prisma.$CategoriaPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Categorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaCountArgs} args - Arguments to filter Categorias to count.
     * @example
     * // Count the number of Categorias
     * const count = await prisma.categoria.count({
     *   where: {
     *     // ... the filter for the Categorias we want to count
     *   }
     * })
     **/
    count<T extends CategoriaCountArgs>(
      args?: Subset<T, CategoriaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoriaCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Categoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends CategoriaAggregateArgs>(
      args: Subset<T, CategoriaAggregateArgs>,
    ): Prisma.PrismaPromise<GetCategoriaAggregateType<T>>;

    /**
     * Group by Categoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends CategoriaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoriaGroupByArgs['orderBy'] }
        : { orderBy?: CategoriaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, CategoriaGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetCategoriaGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Categoria model
     */
    readonly fields: CategoriaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Categoria.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoriaClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    parent<T extends Categoria$parentArgs<ExtArgs> = {}>(
      args?: Subset<T, Categoria$parentArgs<ExtArgs>>,
    ): Prisma__CategoriaClient<
      $Result.GetResult<
        Prisma.$CategoriaPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    hijos<T extends Categoria$hijosArgs<ExtArgs> = {}>(
      args?: Subset<T, Categoria$hijosArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$CategoriaPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    productos<T extends Categoria$productosArgs<ExtArgs> = {}>(
      args?: Subset<T, Categoria$productosArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$ProductoPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Categoria model
   */
  interface CategoriaFieldRefs {
    readonly id: FieldRef<'Categoria', 'Int'>;
    readonly slug: FieldRef<'Categoria', 'String'>;
    readonly nombre: FieldRef<'Categoria', 'String'>;
    readonly descripcion: FieldRef<'Categoria', 'String'>;
    readonly imagen: FieldRef<'Categoria', 'String'>;
    readonly activa: FieldRef<'Categoria', 'Boolean'>;
    readonly orden: FieldRef<'Categoria', 'Int'>;
    readonly creadoEn: FieldRef<'Categoria', 'DateTime'>;
    readonly parentId: FieldRef<'Categoria', 'Int'>;
  }

  // Custom InputTypes
  /**
   * Categoria findUnique
   */
  export type CategoriaFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Categoria
     */
    omit?: CategoriaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null;
    /**
     * Filter, which Categoria to fetch.
     */
    where: CategoriaWhereUniqueInput;
  };

  /**
   * Categoria findUniqueOrThrow
   */
  export type CategoriaFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Categoria
     */
    omit?: CategoriaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null;
    /**
     * Filter, which Categoria to fetch.
     */
    where: CategoriaWhereUniqueInput;
  };

  /**
   * Categoria findFirst
   */
  export type CategoriaFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Categoria
     */
    omit?: CategoriaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null;
    /**
     * Filter, which Categoria to fetch.
     */
    where?: CategoriaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Categorias to fetch.
     */
    orderBy?:
      | CategoriaOrderByWithRelationInput
      | CategoriaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Categorias.
     */
    cursor?: CategoriaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Categorias from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Categorias.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Categorias.
     */
    distinct?: CategoriaScalarFieldEnum | CategoriaScalarFieldEnum[];
  };

  /**
   * Categoria findFirstOrThrow
   */
  export type CategoriaFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Categoria
     */
    omit?: CategoriaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null;
    /**
     * Filter, which Categoria to fetch.
     */
    where?: CategoriaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Categorias to fetch.
     */
    orderBy?:
      | CategoriaOrderByWithRelationInput
      | CategoriaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Categorias.
     */
    cursor?: CategoriaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Categorias from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Categorias.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Categorias.
     */
    distinct?: CategoriaScalarFieldEnum | CategoriaScalarFieldEnum[];
  };

  /**
   * Categoria findMany
   */
  export type CategoriaFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Categoria
     */
    omit?: CategoriaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null;
    /**
     * Filter, which Categorias to fetch.
     */
    where?: CategoriaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Categorias to fetch.
     */
    orderBy?:
      | CategoriaOrderByWithRelationInput
      | CategoriaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Categorias.
     */
    cursor?: CategoriaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Categorias from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Categorias.
     */
    skip?: number;
    distinct?: CategoriaScalarFieldEnum | CategoriaScalarFieldEnum[];
  };

  /**
   * Categoria create
   */
  export type CategoriaCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Categoria
     */
    omit?: CategoriaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null;
    /**
     * The data needed to create a Categoria.
     */
    data: XOR<CategoriaCreateInput, CategoriaUncheckedCreateInput>;
  };

  /**
   * Categoria createMany
   */
  export type CategoriaCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Categorias.
     */
    data: CategoriaCreateManyInput | CategoriaCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Categoria update
   */
  export type CategoriaUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Categoria
     */
    omit?: CategoriaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null;
    /**
     * The data needed to update a Categoria.
     */
    data: XOR<CategoriaUpdateInput, CategoriaUncheckedUpdateInput>;
    /**
     * Choose, which Categoria to update.
     */
    where: CategoriaWhereUniqueInput;
  };

  /**
   * Categoria updateMany
   */
  export type CategoriaUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Categorias.
     */
    data: XOR<
      CategoriaUpdateManyMutationInput,
      CategoriaUncheckedUpdateManyInput
    >;
    /**
     * Filter which Categorias to update
     */
    where?: CategoriaWhereInput;
    /**
     * Limit how many Categorias to update.
     */
    limit?: number;
  };

  /**
   * Categoria upsert
   */
  export type CategoriaUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Categoria
     */
    omit?: CategoriaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null;
    /**
     * The filter to search for the Categoria to update in case it exists.
     */
    where: CategoriaWhereUniqueInput;
    /**
     * In case the Categoria found by the `where` argument doesn't exist, create a new Categoria with this data.
     */
    create: XOR<CategoriaCreateInput, CategoriaUncheckedCreateInput>;
    /**
     * In case the Categoria was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoriaUpdateInput, CategoriaUncheckedUpdateInput>;
  };

  /**
   * Categoria delete
   */
  export type CategoriaDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Categoria
     */
    omit?: CategoriaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null;
    /**
     * Filter which Categoria to delete.
     */
    where: CategoriaWhereUniqueInput;
  };

  /**
   * Categoria deleteMany
   */
  export type CategoriaDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Categorias to delete
     */
    where?: CategoriaWhereInput;
    /**
     * Limit how many Categorias to delete.
     */
    limit?: number;
  };

  /**
   * Categoria.parent
   */
  export type Categoria$parentArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Categoria
     */
    omit?: CategoriaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null;
    where?: CategoriaWhereInput;
  };

  /**
   * Categoria.hijos
   */
  export type Categoria$hijosArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Categoria
     */
    omit?: CategoriaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null;
    where?: CategoriaWhereInput;
    orderBy?:
      | CategoriaOrderByWithRelationInput
      | CategoriaOrderByWithRelationInput[];
    cursor?: CategoriaWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: CategoriaScalarFieldEnum | CategoriaScalarFieldEnum[];
  };

  /**
   * Categoria.productos
   */
  export type Categoria$productosArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Producto
     */
    omit?: ProductoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoInclude<ExtArgs> | null;
    where?: ProductoWhereInput;
    orderBy?:
      | ProductoOrderByWithRelationInput
      | ProductoOrderByWithRelationInput[];
    cursor?: ProductoWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ProductoScalarFieldEnum | ProductoScalarFieldEnum[];
  };

  /**
   * Categoria without action
   */
  export type CategoriaDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Categoria
     */
    omit?: CategoriaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null;
  };

  /**
   * Model Orden
   */

  export type AggregateOrden = {
    _count: OrdenCountAggregateOutputType | null;
    _avg: OrdenAvgAggregateOutputType | null;
    _sum: OrdenSumAggregateOutputType | null;
    _min: OrdenMinAggregateOutputType | null;
    _max: OrdenMaxAggregateOutputType | null;
  };

  export type OrdenAvgAggregateOutputType = {
    id: number | null;
    usuarioId: number | null;
    total: number | null;
    suscripcionFrecuencia: number | null;
    direccionEnvioId: number | null;
    direccionFacturacionId: number | null;
  };

  export type OrdenSumAggregateOutputType = {
    id: number | null;
    usuarioId: number | null;
    total: number | null;
    suscripcionFrecuencia: number | null;
    direccionEnvioId: number | null;
    direccionFacturacionId: number | null;
  };

  export type OrdenMinAggregateOutputType = {
    id: number | null;
    usuarioId: number | null;
    estado: $Enums.EstadoOrden | null;
    total: number | null;
    moneda: string | null;
    referenciaPago: string | null;
    creadoEn: Date | null;
    actualizadoEn: Date | null;
    esSuscripcion: boolean | null;
    suscripcionActiva: boolean | null;
    suscripcionId: string | null;
    suscripcionFrecuencia: number | null;
    suscripcionTipoFrecuencia: string | null;
    direccionEnvioId: number | null;
    direccionFacturacionId: number | null;
  };

  export type OrdenMaxAggregateOutputType = {
    id: number | null;
    usuarioId: number | null;
    estado: $Enums.EstadoOrden | null;
    total: number | null;
    moneda: string | null;
    referenciaPago: string | null;
    creadoEn: Date | null;
    actualizadoEn: Date | null;
    esSuscripcion: boolean | null;
    suscripcionActiva: boolean | null;
    suscripcionId: string | null;
    suscripcionFrecuencia: number | null;
    suscripcionTipoFrecuencia: string | null;
    direccionEnvioId: number | null;
    direccionFacturacionId: number | null;
  };

  export type OrdenCountAggregateOutputType = {
    id: number;
    usuarioId: number;
    estado: number;
    total: number;
    moneda: number;
    referenciaPago: number;
    creadoEn: number;
    actualizadoEn: number;
    esSuscripcion: number;
    suscripcionActiva: number;
    suscripcionId: number;
    suscripcionFrecuencia: number;
    suscripcionTipoFrecuencia: number;
    metadatos: number;
    direccionEnvioId: number;
    direccionFacturacionId: number;
    _all: number;
  };

  export type OrdenAvgAggregateInputType = {
    id?: true;
    usuarioId?: true;
    total?: true;
    suscripcionFrecuencia?: true;
    direccionEnvioId?: true;
    direccionFacturacionId?: true;
  };

  export type OrdenSumAggregateInputType = {
    id?: true;
    usuarioId?: true;
    total?: true;
    suscripcionFrecuencia?: true;
    direccionEnvioId?: true;
    direccionFacturacionId?: true;
  };

  export type OrdenMinAggregateInputType = {
    id?: true;
    usuarioId?: true;
    estado?: true;
    total?: true;
    moneda?: true;
    referenciaPago?: true;
    creadoEn?: true;
    actualizadoEn?: true;
    esSuscripcion?: true;
    suscripcionActiva?: true;
    suscripcionId?: true;
    suscripcionFrecuencia?: true;
    suscripcionTipoFrecuencia?: true;
    direccionEnvioId?: true;
    direccionFacturacionId?: true;
  };

  export type OrdenMaxAggregateInputType = {
    id?: true;
    usuarioId?: true;
    estado?: true;
    total?: true;
    moneda?: true;
    referenciaPago?: true;
    creadoEn?: true;
    actualizadoEn?: true;
    esSuscripcion?: true;
    suscripcionActiva?: true;
    suscripcionId?: true;
    suscripcionFrecuencia?: true;
    suscripcionTipoFrecuencia?: true;
    direccionEnvioId?: true;
    direccionFacturacionId?: true;
  };

  export type OrdenCountAggregateInputType = {
    id?: true;
    usuarioId?: true;
    estado?: true;
    total?: true;
    moneda?: true;
    referenciaPago?: true;
    creadoEn?: true;
    actualizadoEn?: true;
    esSuscripcion?: true;
    suscripcionActiva?: true;
    suscripcionId?: true;
    suscripcionFrecuencia?: true;
    suscripcionTipoFrecuencia?: true;
    metadatos?: true;
    direccionEnvioId?: true;
    direccionFacturacionId?: true;
    _all?: true;
  };

  export type OrdenAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Orden to aggregate.
     */
    where?: OrdenWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Ordens to fetch.
     */
    orderBy?: OrdenOrderByWithRelationInput | OrdenOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: OrdenWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Ordens from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Ordens.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Ordens
     **/
    _count?: true | OrdenCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: OrdenAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: OrdenSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: OrdenMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: OrdenMaxAggregateInputType;
  };

  export type GetOrdenAggregateType<T extends OrdenAggregateArgs> = {
    [P in keyof T & keyof AggregateOrden]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrden[P]>
      : GetScalarType<T[P], AggregateOrden[P]>;
  };

  export type OrdenGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: OrdenWhereInput;
    orderBy?:
      | OrdenOrderByWithAggregationInput
      | OrdenOrderByWithAggregationInput[];
    by: OrdenScalarFieldEnum[] | OrdenScalarFieldEnum;
    having?: OrdenScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: OrdenCountAggregateInputType | true;
    _avg?: OrdenAvgAggregateInputType;
    _sum?: OrdenSumAggregateInputType;
    _min?: OrdenMinAggregateInputType;
    _max?: OrdenMaxAggregateInputType;
  };

  export type OrdenGroupByOutputType = {
    id: number;
    usuarioId: number;
    estado: $Enums.EstadoOrden;
    total: number;
    moneda: string;
    referenciaPago: string | null;
    creadoEn: Date;
    actualizadoEn: Date;
    esSuscripcion: boolean;
    suscripcionActiva: boolean | null;
    suscripcionId: string | null;
    suscripcionFrecuencia: number | null;
    suscripcionTipoFrecuencia: string | null;
    metadatos: JsonValue | null;
    direccionEnvioId: number | null;
    direccionFacturacionId: number | null;
    _count: OrdenCountAggregateOutputType | null;
    _avg: OrdenAvgAggregateOutputType | null;
    _sum: OrdenSumAggregateOutputType | null;
    _min: OrdenMinAggregateOutputType | null;
    _max: OrdenMaxAggregateOutputType | null;
  };

  type GetOrdenGroupByPayload<T extends OrdenGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<OrdenGroupByOutputType, T['by']> & {
          [P in keyof T & keyof OrdenGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrdenGroupByOutputType[P]>
            : GetScalarType<T[P], OrdenGroupByOutputType[P]>;
        }
      >
    >;

  export type OrdenSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      usuarioId?: boolean;
      estado?: boolean;
      total?: boolean;
      moneda?: boolean;
      referenciaPago?: boolean;
      creadoEn?: boolean;
      actualizadoEn?: boolean;
      esSuscripcion?: boolean;
      suscripcionActiva?: boolean;
      suscripcionId?: boolean;
      suscripcionFrecuencia?: boolean;
      suscripcionTipoFrecuencia?: boolean;
      metadatos?: boolean;
      direccionEnvioId?: boolean;
      direccionFacturacionId?: boolean;
      usuario?: boolean | UsuarioDefaultArgs<ExtArgs>;
      direccionEnvio?: boolean | Orden$direccionEnvioArgs<ExtArgs>;
      direccionFacturacion?: boolean | Orden$direccionFacturacionArgs<ExtArgs>;
      items?: boolean | Orden$itemsArgs<ExtArgs>;
      _count?: boolean | OrdenCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['orden']
  >;

  export type OrdenSelectScalar = {
    id?: boolean;
    usuarioId?: boolean;
    estado?: boolean;
    total?: boolean;
    moneda?: boolean;
    referenciaPago?: boolean;
    creadoEn?: boolean;
    actualizadoEn?: boolean;
    esSuscripcion?: boolean;
    suscripcionActiva?: boolean;
    suscripcionId?: boolean;
    suscripcionFrecuencia?: boolean;
    suscripcionTipoFrecuencia?: boolean;
    metadatos?: boolean;
    direccionEnvioId?: boolean;
    direccionFacturacionId?: boolean;
  };

  export type OrdenOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'usuarioId'
    | 'estado'
    | 'total'
    | 'moneda'
    | 'referenciaPago'
    | 'creadoEn'
    | 'actualizadoEn'
    | 'esSuscripcion'
    | 'suscripcionActiva'
    | 'suscripcionId'
    | 'suscripcionFrecuencia'
    | 'suscripcionTipoFrecuencia'
    | 'metadatos'
    | 'direccionEnvioId'
    | 'direccionFacturacionId',
    ExtArgs['result']['orden']
  >;
  export type OrdenInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>;
    direccionEnvio?: boolean | Orden$direccionEnvioArgs<ExtArgs>;
    direccionFacturacion?: boolean | Orden$direccionFacturacionArgs<ExtArgs>;
    items?: boolean | Orden$itemsArgs<ExtArgs>;
    _count?: boolean | OrdenCountOutputTypeDefaultArgs<ExtArgs>;
  };

  export type $OrdenPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Orden';
    objects: {
      usuario: Prisma.$UsuarioPayload<ExtArgs>;
      direccionEnvio: Prisma.$DireccionPayload<ExtArgs> | null;
      direccionFacturacion: Prisma.$DireccionPayload<ExtArgs> | null;
      items: Prisma.$ItemOrdenPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        usuarioId: number;
        estado: $Enums.EstadoOrden;
        total: number;
        moneda: string;
        referenciaPago: string | null;
        creadoEn: Date;
        actualizadoEn: Date;
        esSuscripcion: boolean;
        suscripcionActiva: boolean | null;
        suscripcionId: string | null;
        suscripcionFrecuencia: number | null;
        suscripcionTipoFrecuencia: string | null;
        metadatos: Prisma.JsonValue | null;
        direccionEnvioId: number | null;
        direccionFacturacionId: number | null;
      },
      ExtArgs['result']['orden']
    >;
    composites: {};
  };

  type OrdenGetPayload<
    S extends boolean | null | undefined | OrdenDefaultArgs,
  > = $Result.GetResult<Prisma.$OrdenPayload, S>;

  type OrdenCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<OrdenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: OrdenCountAggregateInputType | true;
  };

  export interface OrdenDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Orden'];
      meta: { name: 'Orden' };
    };
    /**
     * Find zero or one Orden that matches the filter.
     * @param {OrdenFindUniqueArgs} args - Arguments to find a Orden
     * @example
     * // Get one Orden
     * const orden = await prisma.orden.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrdenFindUniqueArgs>(
      args: SelectSubset<T, OrdenFindUniqueArgs<ExtArgs>>,
    ): Prisma__OrdenClient<
      $Result.GetResult<
        Prisma.$OrdenPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Orden that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrdenFindUniqueOrThrowArgs} args - Arguments to find a Orden
     * @example
     * // Get one Orden
     * const orden = await prisma.orden.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrdenFindUniqueOrThrowArgs>(
      args: SelectSubset<T, OrdenFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__OrdenClient<
      $Result.GetResult<
        Prisma.$OrdenPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Orden that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdenFindFirstArgs} args - Arguments to find a Orden
     * @example
     * // Get one Orden
     * const orden = await prisma.orden.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrdenFindFirstArgs>(
      args?: SelectSubset<T, OrdenFindFirstArgs<ExtArgs>>,
    ): Prisma__OrdenClient<
      $Result.GetResult<
        Prisma.$OrdenPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Orden that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdenFindFirstOrThrowArgs} args - Arguments to find a Orden
     * @example
     * // Get one Orden
     * const orden = await prisma.orden.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrdenFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OrdenFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__OrdenClient<
      $Result.GetResult<
        Prisma.$OrdenPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Ordens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ordens
     * const ordens = await prisma.orden.findMany()
     *
     * // Get first 10 Ordens
     * const ordens = await prisma.orden.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const ordenWithIdOnly = await prisma.orden.findMany({ select: { id: true } })
     *
     */
    findMany<T extends OrdenFindManyArgs>(
      args?: SelectSubset<T, OrdenFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$OrdenPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Orden.
     * @param {OrdenCreateArgs} args - Arguments to create a Orden.
     * @example
     * // Create one Orden
     * const Orden = await prisma.orden.create({
     *   data: {
     *     // ... data to create a Orden
     *   }
     * })
     *
     */
    create<T extends OrdenCreateArgs>(
      args: SelectSubset<T, OrdenCreateArgs<ExtArgs>>,
    ): Prisma__OrdenClient<
      $Result.GetResult<
        Prisma.$OrdenPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Ordens.
     * @param {OrdenCreateManyArgs} args - Arguments to create many Ordens.
     * @example
     * // Create many Ordens
     * const orden = await prisma.orden.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends OrdenCreateManyArgs>(
      args?: SelectSubset<T, OrdenCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Orden.
     * @param {OrdenDeleteArgs} args - Arguments to delete one Orden.
     * @example
     * // Delete one Orden
     * const Orden = await prisma.orden.delete({
     *   where: {
     *     // ... filter to delete one Orden
     *   }
     * })
     *
     */
    delete<T extends OrdenDeleteArgs>(
      args: SelectSubset<T, OrdenDeleteArgs<ExtArgs>>,
    ): Prisma__OrdenClient<
      $Result.GetResult<
        Prisma.$OrdenPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Orden.
     * @param {OrdenUpdateArgs} args - Arguments to update one Orden.
     * @example
     * // Update one Orden
     * const orden = await prisma.orden.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends OrdenUpdateArgs>(
      args: SelectSubset<T, OrdenUpdateArgs<ExtArgs>>,
    ): Prisma__OrdenClient<
      $Result.GetResult<
        Prisma.$OrdenPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Ordens.
     * @param {OrdenDeleteManyArgs} args - Arguments to filter Ordens to delete.
     * @example
     * // Delete a few Ordens
     * const { count } = await prisma.orden.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends OrdenDeleteManyArgs>(
      args?: SelectSubset<T, OrdenDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Ordens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ordens
     * const orden = await prisma.orden.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends OrdenUpdateManyArgs>(
      args: SelectSubset<T, OrdenUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Orden.
     * @param {OrdenUpsertArgs} args - Arguments to update or create a Orden.
     * @example
     * // Update or create a Orden
     * const orden = await prisma.orden.upsert({
     *   create: {
     *     // ... data to create a Orden
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Orden we want to update
     *   }
     * })
     */
    upsert<T extends OrdenUpsertArgs>(
      args: SelectSubset<T, OrdenUpsertArgs<ExtArgs>>,
    ): Prisma__OrdenClient<
      $Result.GetResult<
        Prisma.$OrdenPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Ordens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdenCountArgs} args - Arguments to filter Ordens to count.
     * @example
     * // Count the number of Ordens
     * const count = await prisma.orden.count({
     *   where: {
     *     // ... the filter for the Ordens we want to count
     *   }
     * })
     **/
    count<T extends OrdenCountArgs>(
      args?: Subset<T, OrdenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrdenCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Orden.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends OrdenAggregateArgs>(
      args: Subset<T, OrdenAggregateArgs>,
    ): Prisma.PrismaPromise<GetOrdenAggregateType<T>>;

    /**
     * Group by Orden.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends OrdenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrdenGroupByArgs['orderBy'] }
        : { orderBy?: OrdenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, OrdenGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetOrdenGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Orden model
     */
    readonly fields: OrdenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Orden.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrdenClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>,
    ): Prisma__UsuarioClient<
      | $Result.GetResult<
          Prisma.$UsuarioPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    direccionEnvio<T extends Orden$direccionEnvioArgs<ExtArgs> = {}>(
      args?: Subset<T, Orden$direccionEnvioArgs<ExtArgs>>,
    ): Prisma__DireccionClient<
      $Result.GetResult<
        Prisma.$DireccionPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    direccionFacturacion<
      T extends Orden$direccionFacturacionArgs<ExtArgs> = {},
    >(
      args?: Subset<T, Orden$direccionFacturacionArgs<ExtArgs>>,
    ): Prisma__DireccionClient<
      $Result.GetResult<
        Prisma.$DireccionPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    items<T extends Orden$itemsArgs<ExtArgs> = {}>(
      args?: Subset<T, Orden$itemsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$ItemOrdenPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Orden model
   */
  interface OrdenFieldRefs {
    readonly id: FieldRef<'Orden', 'Int'>;
    readonly usuarioId: FieldRef<'Orden', 'Int'>;
    readonly estado: FieldRef<'Orden', 'EstadoOrden'>;
    readonly total: FieldRef<'Orden', 'Int'>;
    readonly moneda: FieldRef<'Orden', 'String'>;
    readonly referenciaPago: FieldRef<'Orden', 'String'>;
    readonly creadoEn: FieldRef<'Orden', 'DateTime'>;
    readonly actualizadoEn: FieldRef<'Orden', 'DateTime'>;
    readonly esSuscripcion: FieldRef<'Orden', 'Boolean'>;
    readonly suscripcionActiva: FieldRef<'Orden', 'Boolean'>;
    readonly suscripcionId: FieldRef<'Orden', 'String'>;
    readonly suscripcionFrecuencia: FieldRef<'Orden', 'Int'>;
    readonly suscripcionTipoFrecuencia: FieldRef<'Orden', 'String'>;
    readonly metadatos: FieldRef<'Orden', 'Json'>;
    readonly direccionEnvioId: FieldRef<'Orden', 'Int'>;
    readonly direccionFacturacionId: FieldRef<'Orden', 'Int'>;
  }

  // Custom InputTypes
  /**
   * Orden findUnique
   */
  export type OrdenFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Orden
     */
    select?: OrdenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Orden
     */
    omit?: OrdenOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdenInclude<ExtArgs> | null;
    /**
     * Filter, which Orden to fetch.
     */
    where: OrdenWhereUniqueInput;
  };

  /**
   * Orden findUniqueOrThrow
   */
  export type OrdenFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Orden
     */
    select?: OrdenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Orden
     */
    omit?: OrdenOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdenInclude<ExtArgs> | null;
    /**
     * Filter, which Orden to fetch.
     */
    where: OrdenWhereUniqueInput;
  };

  /**
   * Orden findFirst
   */
  export type OrdenFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Orden
     */
    select?: OrdenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Orden
     */
    omit?: OrdenOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdenInclude<ExtArgs> | null;
    /**
     * Filter, which Orden to fetch.
     */
    where?: OrdenWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Ordens to fetch.
     */
    orderBy?: OrdenOrderByWithRelationInput | OrdenOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Ordens.
     */
    cursor?: OrdenWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Ordens from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Ordens.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Ordens.
     */
    distinct?: OrdenScalarFieldEnum | OrdenScalarFieldEnum[];
  };

  /**
   * Orden findFirstOrThrow
   */
  export type OrdenFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Orden
     */
    select?: OrdenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Orden
     */
    omit?: OrdenOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdenInclude<ExtArgs> | null;
    /**
     * Filter, which Orden to fetch.
     */
    where?: OrdenWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Ordens to fetch.
     */
    orderBy?: OrdenOrderByWithRelationInput | OrdenOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Ordens.
     */
    cursor?: OrdenWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Ordens from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Ordens.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Ordens.
     */
    distinct?: OrdenScalarFieldEnum | OrdenScalarFieldEnum[];
  };

  /**
   * Orden findMany
   */
  export type OrdenFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Orden
     */
    select?: OrdenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Orden
     */
    omit?: OrdenOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdenInclude<ExtArgs> | null;
    /**
     * Filter, which Ordens to fetch.
     */
    where?: OrdenWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Ordens to fetch.
     */
    orderBy?: OrdenOrderByWithRelationInput | OrdenOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Ordens.
     */
    cursor?: OrdenWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Ordens from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Ordens.
     */
    skip?: number;
    distinct?: OrdenScalarFieldEnum | OrdenScalarFieldEnum[];
  };

  /**
   * Orden create
   */
  export type OrdenCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Orden
     */
    select?: OrdenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Orden
     */
    omit?: OrdenOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdenInclude<ExtArgs> | null;
    /**
     * The data needed to create a Orden.
     */
    data: XOR<OrdenCreateInput, OrdenUncheckedCreateInput>;
  };

  /**
   * Orden createMany
   */
  export type OrdenCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Ordens.
     */
    data: OrdenCreateManyInput | OrdenCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Orden update
   */
  export type OrdenUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Orden
     */
    select?: OrdenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Orden
     */
    omit?: OrdenOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdenInclude<ExtArgs> | null;
    /**
     * The data needed to update a Orden.
     */
    data: XOR<OrdenUpdateInput, OrdenUncheckedUpdateInput>;
    /**
     * Choose, which Orden to update.
     */
    where: OrdenWhereUniqueInput;
  };

  /**
   * Orden updateMany
   */
  export type OrdenUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Ordens.
     */
    data: XOR<OrdenUpdateManyMutationInput, OrdenUncheckedUpdateManyInput>;
    /**
     * Filter which Ordens to update
     */
    where?: OrdenWhereInput;
    /**
     * Limit how many Ordens to update.
     */
    limit?: number;
  };

  /**
   * Orden upsert
   */
  export type OrdenUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Orden
     */
    select?: OrdenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Orden
     */
    omit?: OrdenOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdenInclude<ExtArgs> | null;
    /**
     * The filter to search for the Orden to update in case it exists.
     */
    where: OrdenWhereUniqueInput;
    /**
     * In case the Orden found by the `where` argument doesn't exist, create a new Orden with this data.
     */
    create: XOR<OrdenCreateInput, OrdenUncheckedCreateInput>;
    /**
     * In case the Orden was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrdenUpdateInput, OrdenUncheckedUpdateInput>;
  };

  /**
   * Orden delete
   */
  export type OrdenDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Orden
     */
    select?: OrdenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Orden
     */
    omit?: OrdenOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdenInclude<ExtArgs> | null;
    /**
     * Filter which Orden to delete.
     */
    where: OrdenWhereUniqueInput;
  };

  /**
   * Orden deleteMany
   */
  export type OrdenDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Ordens to delete
     */
    where?: OrdenWhereInput;
    /**
     * Limit how many Ordens to delete.
     */
    limit?: number;
  };

  /**
   * Orden.direccionEnvio
   */
  export type Orden$direccionEnvioArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Direccion
     */
    select?: DireccionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Direccion
     */
    omit?: DireccionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DireccionInclude<ExtArgs> | null;
    where?: DireccionWhereInput;
  };

  /**
   * Orden.direccionFacturacion
   */
  export type Orden$direccionFacturacionArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Direccion
     */
    select?: DireccionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Direccion
     */
    omit?: DireccionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DireccionInclude<ExtArgs> | null;
    where?: DireccionWhereInput;
  };

  /**
   * Orden.items
   */
  export type Orden$itemsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ItemOrden
     */
    select?: ItemOrdenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ItemOrden
     */
    omit?: ItemOrdenOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemOrdenInclude<ExtArgs> | null;
    where?: ItemOrdenWhereInput;
    orderBy?:
      | ItemOrdenOrderByWithRelationInput
      | ItemOrdenOrderByWithRelationInput[];
    cursor?: ItemOrdenWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ItemOrdenScalarFieldEnum | ItemOrdenScalarFieldEnum[];
  };

  /**
   * Orden without action
   */
  export type OrdenDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Orden
     */
    select?: OrdenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Orden
     */
    omit?: OrdenOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdenInclude<ExtArgs> | null;
  };

  /**
   * Model ItemOrden
   */

  export type AggregateItemOrden = {
    _count: ItemOrdenCountAggregateOutputType | null;
    _avg: ItemOrdenAvgAggregateOutputType | null;
    _sum: ItemOrdenSumAggregateOutputType | null;
    _min: ItemOrdenMinAggregateOutputType | null;
    _max: ItemOrdenMaxAggregateOutputType | null;
  };

  export type ItemOrdenAvgAggregateOutputType = {
    id: number | null;
    ordenId: number | null;
    refId: number | null;
    cantidad: number | null;
    precioUnitario: number | null;
  };

  export type ItemOrdenSumAggregateOutputType = {
    id: number | null;
    ordenId: number | null;
    refId: number | null;
    cantidad: number | null;
    precioUnitario: number | null;
  };

  export type ItemOrdenMinAggregateOutputType = {
    id: number | null;
    ordenId: number | null;
    tipo: $Enums.TipoItemOrden | null;
    refId: number | null;
    titulo: string | null;
    cantidad: number | null;
    precioUnitario: number | null;
  };

  export type ItemOrdenMaxAggregateOutputType = {
    id: number | null;
    ordenId: number | null;
    tipo: $Enums.TipoItemOrden | null;
    refId: number | null;
    titulo: string | null;
    cantidad: number | null;
    precioUnitario: number | null;
  };

  export type ItemOrdenCountAggregateOutputType = {
    id: number;
    ordenId: number;
    tipo: number;
    refId: number;
    titulo: number;
    cantidad: number;
    precioUnitario: number;
    _all: number;
  };

  export type ItemOrdenAvgAggregateInputType = {
    id?: true;
    ordenId?: true;
    refId?: true;
    cantidad?: true;
    precioUnitario?: true;
  };

  export type ItemOrdenSumAggregateInputType = {
    id?: true;
    ordenId?: true;
    refId?: true;
    cantidad?: true;
    precioUnitario?: true;
  };

  export type ItemOrdenMinAggregateInputType = {
    id?: true;
    ordenId?: true;
    tipo?: true;
    refId?: true;
    titulo?: true;
    cantidad?: true;
    precioUnitario?: true;
  };

  export type ItemOrdenMaxAggregateInputType = {
    id?: true;
    ordenId?: true;
    tipo?: true;
    refId?: true;
    titulo?: true;
    cantidad?: true;
    precioUnitario?: true;
  };

  export type ItemOrdenCountAggregateInputType = {
    id?: true;
    ordenId?: true;
    tipo?: true;
    refId?: true;
    titulo?: true;
    cantidad?: true;
    precioUnitario?: true;
    _all?: true;
  };

  export type ItemOrdenAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ItemOrden to aggregate.
     */
    where?: ItemOrdenWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ItemOrdens to fetch.
     */
    orderBy?:
      | ItemOrdenOrderByWithRelationInput
      | ItemOrdenOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ItemOrdenWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ItemOrdens from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ItemOrdens.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned ItemOrdens
     **/
    _count?: true | ItemOrdenCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ItemOrdenAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ItemOrdenSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ItemOrdenMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ItemOrdenMaxAggregateInputType;
  };

  export type GetItemOrdenAggregateType<T extends ItemOrdenAggregateArgs> = {
    [P in keyof T & keyof AggregateItemOrden]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItemOrden[P]>
      : GetScalarType<T[P], AggregateItemOrden[P]>;
  };

  export type ItemOrdenGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ItemOrdenWhereInput;
    orderBy?:
      | ItemOrdenOrderByWithAggregationInput
      | ItemOrdenOrderByWithAggregationInput[];
    by: ItemOrdenScalarFieldEnum[] | ItemOrdenScalarFieldEnum;
    having?: ItemOrdenScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ItemOrdenCountAggregateInputType | true;
    _avg?: ItemOrdenAvgAggregateInputType;
    _sum?: ItemOrdenSumAggregateInputType;
    _min?: ItemOrdenMinAggregateInputType;
    _max?: ItemOrdenMaxAggregateInputType;
  };

  export type ItemOrdenGroupByOutputType = {
    id: number;
    ordenId: number;
    tipo: $Enums.TipoItemOrden;
    refId: number;
    titulo: string;
    cantidad: number;
    precioUnitario: number;
    _count: ItemOrdenCountAggregateOutputType | null;
    _avg: ItemOrdenAvgAggregateOutputType | null;
    _sum: ItemOrdenSumAggregateOutputType | null;
    _min: ItemOrdenMinAggregateOutputType | null;
    _max: ItemOrdenMaxAggregateOutputType | null;
  };

  type GetItemOrdenGroupByPayload<T extends ItemOrdenGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ItemOrdenGroupByOutputType, T['by']> & {
          [P in keyof T & keyof ItemOrdenGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemOrdenGroupByOutputType[P]>
            : GetScalarType<T[P], ItemOrdenGroupByOutputType[P]>;
        }
      >
    >;

  export type ItemOrdenSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      ordenId?: boolean;
      tipo?: boolean;
      refId?: boolean;
      titulo?: boolean;
      cantidad?: boolean;
      precioUnitario?: boolean;
      orden?: boolean | OrdenDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['itemOrden']
  >;

  export type ItemOrdenSelectScalar = {
    id?: boolean;
    ordenId?: boolean;
    tipo?: boolean;
    refId?: boolean;
    titulo?: boolean;
    cantidad?: boolean;
    precioUnitario?: boolean;
  };

  export type ItemOrdenOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'ordenId'
    | 'tipo'
    | 'refId'
    | 'titulo'
    | 'cantidad'
    | 'precioUnitario',
    ExtArgs['result']['itemOrden']
  >;
  export type ItemOrdenInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    orden?: boolean | OrdenDefaultArgs<ExtArgs>;
  };

  export type $ItemOrdenPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'ItemOrden';
    objects: {
      orden: Prisma.$OrdenPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        ordenId: number;
        tipo: $Enums.TipoItemOrden;
        refId: number;
        titulo: string;
        cantidad: number;
        precioUnitario: number;
      },
      ExtArgs['result']['itemOrden']
    >;
    composites: {};
  };

  type ItemOrdenGetPayload<
    S extends boolean | null | undefined | ItemOrdenDefaultArgs,
  > = $Result.GetResult<Prisma.$ItemOrdenPayload, S>;

  type ItemOrdenCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    ItemOrdenFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: ItemOrdenCountAggregateInputType | true;
  };

  export interface ItemOrdenDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['ItemOrden'];
      meta: { name: 'ItemOrden' };
    };
    /**
     * Find zero or one ItemOrden that matches the filter.
     * @param {ItemOrdenFindUniqueArgs} args - Arguments to find a ItemOrden
     * @example
     * // Get one ItemOrden
     * const itemOrden = await prisma.itemOrden.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ItemOrdenFindUniqueArgs>(
      args: SelectSubset<T, ItemOrdenFindUniqueArgs<ExtArgs>>,
    ): Prisma__ItemOrdenClient<
      $Result.GetResult<
        Prisma.$ItemOrdenPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one ItemOrden that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ItemOrdenFindUniqueOrThrowArgs} args - Arguments to find a ItemOrden
     * @example
     * // Get one ItemOrden
     * const itemOrden = await prisma.itemOrden.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ItemOrdenFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ItemOrdenFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__ItemOrdenClient<
      $Result.GetResult<
        Prisma.$ItemOrdenPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ItemOrden that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemOrdenFindFirstArgs} args - Arguments to find a ItemOrden
     * @example
     * // Get one ItemOrden
     * const itemOrden = await prisma.itemOrden.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ItemOrdenFindFirstArgs>(
      args?: SelectSubset<T, ItemOrdenFindFirstArgs<ExtArgs>>,
    ): Prisma__ItemOrdenClient<
      $Result.GetResult<
        Prisma.$ItemOrdenPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ItemOrden that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemOrdenFindFirstOrThrowArgs} args - Arguments to find a ItemOrden
     * @example
     * // Get one ItemOrden
     * const itemOrden = await prisma.itemOrden.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ItemOrdenFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ItemOrdenFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__ItemOrdenClient<
      $Result.GetResult<
        Prisma.$ItemOrdenPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more ItemOrdens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemOrdenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ItemOrdens
     * const itemOrdens = await prisma.itemOrden.findMany()
     *
     * // Get first 10 ItemOrdens
     * const itemOrdens = await prisma.itemOrden.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const itemOrdenWithIdOnly = await prisma.itemOrden.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ItemOrdenFindManyArgs>(
      args?: SelectSubset<T, ItemOrdenFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ItemOrdenPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a ItemOrden.
     * @param {ItemOrdenCreateArgs} args - Arguments to create a ItemOrden.
     * @example
     * // Create one ItemOrden
     * const ItemOrden = await prisma.itemOrden.create({
     *   data: {
     *     // ... data to create a ItemOrden
     *   }
     * })
     *
     */
    create<T extends ItemOrdenCreateArgs>(
      args: SelectSubset<T, ItemOrdenCreateArgs<ExtArgs>>,
    ): Prisma__ItemOrdenClient<
      $Result.GetResult<
        Prisma.$ItemOrdenPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many ItemOrdens.
     * @param {ItemOrdenCreateManyArgs} args - Arguments to create many ItemOrdens.
     * @example
     * // Create many ItemOrdens
     * const itemOrden = await prisma.itemOrden.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ItemOrdenCreateManyArgs>(
      args?: SelectSubset<T, ItemOrdenCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a ItemOrden.
     * @param {ItemOrdenDeleteArgs} args - Arguments to delete one ItemOrden.
     * @example
     * // Delete one ItemOrden
     * const ItemOrden = await prisma.itemOrden.delete({
     *   where: {
     *     // ... filter to delete one ItemOrden
     *   }
     * })
     *
     */
    delete<T extends ItemOrdenDeleteArgs>(
      args: SelectSubset<T, ItemOrdenDeleteArgs<ExtArgs>>,
    ): Prisma__ItemOrdenClient<
      $Result.GetResult<
        Prisma.$ItemOrdenPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one ItemOrden.
     * @param {ItemOrdenUpdateArgs} args - Arguments to update one ItemOrden.
     * @example
     * // Update one ItemOrden
     * const itemOrden = await prisma.itemOrden.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ItemOrdenUpdateArgs>(
      args: SelectSubset<T, ItemOrdenUpdateArgs<ExtArgs>>,
    ): Prisma__ItemOrdenClient<
      $Result.GetResult<
        Prisma.$ItemOrdenPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more ItemOrdens.
     * @param {ItemOrdenDeleteManyArgs} args - Arguments to filter ItemOrdens to delete.
     * @example
     * // Delete a few ItemOrdens
     * const { count } = await prisma.itemOrden.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ItemOrdenDeleteManyArgs>(
      args?: SelectSubset<T, ItemOrdenDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ItemOrdens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemOrdenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ItemOrdens
     * const itemOrden = await prisma.itemOrden.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ItemOrdenUpdateManyArgs>(
      args: SelectSubset<T, ItemOrdenUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one ItemOrden.
     * @param {ItemOrdenUpsertArgs} args - Arguments to update or create a ItemOrden.
     * @example
     * // Update or create a ItemOrden
     * const itemOrden = await prisma.itemOrden.upsert({
     *   create: {
     *     // ... data to create a ItemOrden
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ItemOrden we want to update
     *   }
     * })
     */
    upsert<T extends ItemOrdenUpsertArgs>(
      args: SelectSubset<T, ItemOrdenUpsertArgs<ExtArgs>>,
    ): Prisma__ItemOrdenClient<
      $Result.GetResult<
        Prisma.$ItemOrdenPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of ItemOrdens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemOrdenCountArgs} args - Arguments to filter ItemOrdens to count.
     * @example
     * // Count the number of ItemOrdens
     * const count = await prisma.itemOrden.count({
     *   where: {
     *     // ... the filter for the ItemOrdens we want to count
     *   }
     * })
     **/
    count<T extends ItemOrdenCountArgs>(
      args?: Subset<T, ItemOrdenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemOrdenCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a ItemOrden.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemOrdenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ItemOrdenAggregateArgs>(
      args: Subset<T, ItemOrdenAggregateArgs>,
    ): Prisma.PrismaPromise<GetItemOrdenAggregateType<T>>;

    /**
     * Group by ItemOrden.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemOrdenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ItemOrdenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemOrdenGroupByArgs['orderBy'] }
        : { orderBy?: ItemOrdenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ItemOrdenGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetItemOrdenGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the ItemOrden model
     */
    readonly fields: ItemOrdenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ItemOrden.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemOrdenClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    orden<T extends OrdenDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, OrdenDefaultArgs<ExtArgs>>,
    ): Prisma__OrdenClient<
      | $Result.GetResult<
          Prisma.$OrdenPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the ItemOrden model
   */
  interface ItemOrdenFieldRefs {
    readonly id: FieldRef<'ItemOrden', 'Int'>;
    readonly ordenId: FieldRef<'ItemOrden', 'Int'>;
    readonly tipo: FieldRef<'ItemOrden', 'TipoItemOrden'>;
    readonly refId: FieldRef<'ItemOrden', 'Int'>;
    readonly titulo: FieldRef<'ItemOrden', 'String'>;
    readonly cantidad: FieldRef<'ItemOrden', 'Int'>;
    readonly precioUnitario: FieldRef<'ItemOrden', 'Int'>;
  }

  // Custom InputTypes
  /**
   * ItemOrden findUnique
   */
  export type ItemOrdenFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ItemOrden
     */
    select?: ItemOrdenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ItemOrden
     */
    omit?: ItemOrdenOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemOrdenInclude<ExtArgs> | null;
    /**
     * Filter, which ItemOrden to fetch.
     */
    where: ItemOrdenWhereUniqueInput;
  };

  /**
   * ItemOrden findUniqueOrThrow
   */
  export type ItemOrdenFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ItemOrden
     */
    select?: ItemOrdenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ItemOrden
     */
    omit?: ItemOrdenOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemOrdenInclude<ExtArgs> | null;
    /**
     * Filter, which ItemOrden to fetch.
     */
    where: ItemOrdenWhereUniqueInput;
  };

  /**
   * ItemOrden findFirst
   */
  export type ItemOrdenFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ItemOrden
     */
    select?: ItemOrdenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ItemOrden
     */
    omit?: ItemOrdenOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemOrdenInclude<ExtArgs> | null;
    /**
     * Filter, which ItemOrden to fetch.
     */
    where?: ItemOrdenWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ItemOrdens to fetch.
     */
    orderBy?:
      | ItemOrdenOrderByWithRelationInput
      | ItemOrdenOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ItemOrdens.
     */
    cursor?: ItemOrdenWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ItemOrdens from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ItemOrdens.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ItemOrdens.
     */
    distinct?: ItemOrdenScalarFieldEnum | ItemOrdenScalarFieldEnum[];
  };

  /**
   * ItemOrden findFirstOrThrow
   */
  export type ItemOrdenFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ItemOrden
     */
    select?: ItemOrdenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ItemOrden
     */
    omit?: ItemOrdenOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemOrdenInclude<ExtArgs> | null;
    /**
     * Filter, which ItemOrden to fetch.
     */
    where?: ItemOrdenWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ItemOrdens to fetch.
     */
    orderBy?:
      | ItemOrdenOrderByWithRelationInput
      | ItemOrdenOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ItemOrdens.
     */
    cursor?: ItemOrdenWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ItemOrdens from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ItemOrdens.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ItemOrdens.
     */
    distinct?: ItemOrdenScalarFieldEnum | ItemOrdenScalarFieldEnum[];
  };

  /**
   * ItemOrden findMany
   */
  export type ItemOrdenFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ItemOrden
     */
    select?: ItemOrdenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ItemOrden
     */
    omit?: ItemOrdenOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemOrdenInclude<ExtArgs> | null;
    /**
     * Filter, which ItemOrdens to fetch.
     */
    where?: ItemOrdenWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ItemOrdens to fetch.
     */
    orderBy?:
      | ItemOrdenOrderByWithRelationInput
      | ItemOrdenOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing ItemOrdens.
     */
    cursor?: ItemOrdenWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ItemOrdens from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ItemOrdens.
     */
    skip?: number;
    distinct?: ItemOrdenScalarFieldEnum | ItemOrdenScalarFieldEnum[];
  };

  /**
   * ItemOrden create
   */
  export type ItemOrdenCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ItemOrden
     */
    select?: ItemOrdenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ItemOrden
     */
    omit?: ItemOrdenOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemOrdenInclude<ExtArgs> | null;
    /**
     * The data needed to create a ItemOrden.
     */
    data: XOR<ItemOrdenCreateInput, ItemOrdenUncheckedCreateInput>;
  };

  /**
   * ItemOrden createMany
   */
  export type ItemOrdenCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many ItemOrdens.
     */
    data: ItemOrdenCreateManyInput | ItemOrdenCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * ItemOrden update
   */
  export type ItemOrdenUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ItemOrden
     */
    select?: ItemOrdenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ItemOrden
     */
    omit?: ItemOrdenOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemOrdenInclude<ExtArgs> | null;
    /**
     * The data needed to update a ItemOrden.
     */
    data: XOR<ItemOrdenUpdateInput, ItemOrdenUncheckedUpdateInput>;
    /**
     * Choose, which ItemOrden to update.
     */
    where: ItemOrdenWhereUniqueInput;
  };

  /**
   * ItemOrden updateMany
   */
  export type ItemOrdenUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update ItemOrdens.
     */
    data: XOR<
      ItemOrdenUpdateManyMutationInput,
      ItemOrdenUncheckedUpdateManyInput
    >;
    /**
     * Filter which ItemOrdens to update
     */
    where?: ItemOrdenWhereInput;
    /**
     * Limit how many ItemOrdens to update.
     */
    limit?: number;
  };

  /**
   * ItemOrden upsert
   */
  export type ItemOrdenUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ItemOrden
     */
    select?: ItemOrdenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ItemOrden
     */
    omit?: ItemOrdenOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemOrdenInclude<ExtArgs> | null;
    /**
     * The filter to search for the ItemOrden to update in case it exists.
     */
    where: ItemOrdenWhereUniqueInput;
    /**
     * In case the ItemOrden found by the `where` argument doesn't exist, create a new ItemOrden with this data.
     */
    create: XOR<ItemOrdenCreateInput, ItemOrdenUncheckedCreateInput>;
    /**
     * In case the ItemOrden was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemOrdenUpdateInput, ItemOrdenUncheckedUpdateInput>;
  };

  /**
   * ItemOrden delete
   */
  export type ItemOrdenDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ItemOrden
     */
    select?: ItemOrdenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ItemOrden
     */
    omit?: ItemOrdenOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemOrdenInclude<ExtArgs> | null;
    /**
     * Filter which ItemOrden to delete.
     */
    where: ItemOrdenWhereUniqueInput;
  };

  /**
   * ItemOrden deleteMany
   */
  export type ItemOrdenDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ItemOrdens to delete
     */
    where?: ItemOrdenWhereInput;
    /**
     * Limit how many ItemOrdens to delete.
     */
    limit?: number;
  };

  /**
   * ItemOrden without action
   */
  export type ItemOrdenDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ItemOrden
     */
    select?: ItemOrdenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ItemOrden
     */
    omit?: ItemOrdenOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemOrdenInclude<ExtArgs> | null;
  };

  /**
   * Model PagoSuscripcion
   */

  export type AggregatePagoSuscripcion = {
    _count: PagoSuscripcionCountAggregateOutputType | null;
    _avg: PagoSuscripcionAvgAggregateOutputType | null;
    _sum: PagoSuscripcionSumAggregateOutputType | null;
    _min: PagoSuscripcionMinAggregateOutputType | null;
    _max: PagoSuscripcionMaxAggregateOutputType | null;
  };

  export type PagoSuscripcionAvgAggregateOutputType = {
    id: number | null;
    ordenId: number | null;
    usuarioId: number | null;
    monto: Decimal | null;
  };

  export type PagoSuscripcionSumAggregateOutputType = {
    id: number | null;
    ordenId: number | null;
    usuarioId: number | null;
    monto: Decimal | null;
  };

  export type PagoSuscripcionMinAggregateOutputType = {
    id: number | null;
    ordenId: number | null;
    usuarioId: number | null;
    referenciaPago: string | null;
    monto: Decimal | null;
    estado: string | null;
    creadoEn: Date | null;
    actualizadoEn: Date | null;
  };

  export type PagoSuscripcionMaxAggregateOutputType = {
    id: number | null;
    ordenId: number | null;
    usuarioId: number | null;
    referenciaPago: string | null;
    monto: Decimal | null;
    estado: string | null;
    creadoEn: Date | null;
    actualizadoEn: Date | null;
  };

  export type PagoSuscripcionCountAggregateOutputType = {
    id: number;
    ordenId: number;
    usuarioId: number;
    referenciaPago: number;
    monto: number;
    estado: number;
    metadatos: number;
    creadoEn: number;
    actualizadoEn: number;
    _all: number;
  };

  export type PagoSuscripcionAvgAggregateInputType = {
    id?: true;
    ordenId?: true;
    usuarioId?: true;
    monto?: true;
  };

  export type PagoSuscripcionSumAggregateInputType = {
    id?: true;
    ordenId?: true;
    usuarioId?: true;
    monto?: true;
  };

  export type PagoSuscripcionMinAggregateInputType = {
    id?: true;
    ordenId?: true;
    usuarioId?: true;
    referenciaPago?: true;
    monto?: true;
    estado?: true;
    creadoEn?: true;
    actualizadoEn?: true;
  };

  export type PagoSuscripcionMaxAggregateInputType = {
    id?: true;
    ordenId?: true;
    usuarioId?: true;
    referenciaPago?: true;
    monto?: true;
    estado?: true;
    creadoEn?: true;
    actualizadoEn?: true;
  };

  export type PagoSuscripcionCountAggregateInputType = {
    id?: true;
    ordenId?: true;
    usuarioId?: true;
    referenciaPago?: true;
    monto?: true;
    estado?: true;
    metadatos?: true;
    creadoEn?: true;
    actualizadoEn?: true;
    _all?: true;
  };

  export type PagoSuscripcionAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which PagoSuscripcion to aggregate.
     */
    where?: PagoSuscripcionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PagoSuscripcions to fetch.
     */
    orderBy?:
      | PagoSuscripcionOrderByWithRelationInput
      | PagoSuscripcionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: PagoSuscripcionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PagoSuscripcions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PagoSuscripcions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned PagoSuscripcions
     **/
    _count?: true | PagoSuscripcionCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: PagoSuscripcionAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: PagoSuscripcionSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: PagoSuscripcionMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: PagoSuscripcionMaxAggregateInputType;
  };

  export type GetPagoSuscripcionAggregateType<
    T extends PagoSuscripcionAggregateArgs,
  > = {
    [P in keyof T & keyof AggregatePagoSuscripcion]: P extends
      | '_count'
      | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePagoSuscripcion[P]>
      : GetScalarType<T[P], AggregatePagoSuscripcion[P]>;
  };

  export type PagoSuscripcionGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: PagoSuscripcionWhereInput;
    orderBy?:
      | PagoSuscripcionOrderByWithAggregationInput
      | PagoSuscripcionOrderByWithAggregationInput[];
    by: PagoSuscripcionScalarFieldEnum[] | PagoSuscripcionScalarFieldEnum;
    having?: PagoSuscripcionScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: PagoSuscripcionCountAggregateInputType | true;
    _avg?: PagoSuscripcionAvgAggregateInputType;
    _sum?: PagoSuscripcionSumAggregateInputType;
    _min?: PagoSuscripcionMinAggregateInputType;
    _max?: PagoSuscripcionMaxAggregateInputType;
  };

  export type PagoSuscripcionGroupByOutputType = {
    id: number;
    ordenId: number;
    usuarioId: number;
    referenciaPago: string;
    monto: Decimal;
    estado: string;
    metadatos: JsonValue | null;
    creadoEn: Date;
    actualizadoEn: Date;
    _count: PagoSuscripcionCountAggregateOutputType | null;
    _avg: PagoSuscripcionAvgAggregateOutputType | null;
    _sum: PagoSuscripcionSumAggregateOutputType | null;
    _min: PagoSuscripcionMinAggregateOutputType | null;
    _max: PagoSuscripcionMaxAggregateOutputType | null;
  };

  type GetPagoSuscripcionGroupByPayload<T extends PagoSuscripcionGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<PagoSuscripcionGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof PagoSuscripcionGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PagoSuscripcionGroupByOutputType[P]>
            : GetScalarType<T[P], PagoSuscripcionGroupByOutputType[P]>;
        }
      >
    >;

  export type PagoSuscripcionSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      ordenId?: boolean;
      usuarioId?: boolean;
      referenciaPago?: boolean;
      monto?: boolean;
      estado?: boolean;
      metadatos?: boolean;
      creadoEn?: boolean;
      actualizadoEn?: boolean;
    },
    ExtArgs['result']['pagoSuscripcion']
  >;

  export type PagoSuscripcionSelectScalar = {
    id?: boolean;
    ordenId?: boolean;
    usuarioId?: boolean;
    referenciaPago?: boolean;
    monto?: boolean;
    estado?: boolean;
    metadatos?: boolean;
    creadoEn?: boolean;
    actualizadoEn?: boolean;
  };

  export type PagoSuscripcionOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'ordenId'
    | 'usuarioId'
    | 'referenciaPago'
    | 'monto'
    | 'estado'
    | 'metadatos'
    | 'creadoEn'
    | 'actualizadoEn',
    ExtArgs['result']['pagoSuscripcion']
  >;

  export type $PagoSuscripcionPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'PagoSuscripcion';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        ordenId: number;
        usuarioId: number;
        referenciaPago: string;
        monto: Prisma.Decimal;
        estado: string;
        metadatos: Prisma.JsonValue | null;
        creadoEn: Date;
        actualizadoEn: Date;
      },
      ExtArgs['result']['pagoSuscripcion']
    >;
    composites: {};
  };

  type PagoSuscripcionGetPayload<
    S extends boolean | null | undefined | PagoSuscripcionDefaultArgs,
  > = $Result.GetResult<Prisma.$PagoSuscripcionPayload, S>;

  type PagoSuscripcionCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    PagoSuscripcionFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: PagoSuscripcionCountAggregateInputType | true;
  };

  export interface PagoSuscripcionDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['PagoSuscripcion'];
      meta: { name: 'PagoSuscripcion' };
    };
    /**
     * Find zero or one PagoSuscripcion that matches the filter.
     * @param {PagoSuscripcionFindUniqueArgs} args - Arguments to find a PagoSuscripcion
     * @example
     * // Get one PagoSuscripcion
     * const pagoSuscripcion = await prisma.pagoSuscripcion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PagoSuscripcionFindUniqueArgs>(
      args: SelectSubset<T, PagoSuscripcionFindUniqueArgs<ExtArgs>>,
    ): Prisma__PagoSuscripcionClient<
      $Result.GetResult<
        Prisma.$PagoSuscripcionPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one PagoSuscripcion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PagoSuscripcionFindUniqueOrThrowArgs} args - Arguments to find a PagoSuscripcion
     * @example
     * // Get one PagoSuscripcion
     * const pagoSuscripcion = await prisma.pagoSuscripcion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PagoSuscripcionFindUniqueOrThrowArgs>(
      args: SelectSubset<T, PagoSuscripcionFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__PagoSuscripcionClient<
      $Result.GetResult<
        Prisma.$PagoSuscripcionPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first PagoSuscripcion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagoSuscripcionFindFirstArgs} args - Arguments to find a PagoSuscripcion
     * @example
     * // Get one PagoSuscripcion
     * const pagoSuscripcion = await prisma.pagoSuscripcion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PagoSuscripcionFindFirstArgs>(
      args?: SelectSubset<T, PagoSuscripcionFindFirstArgs<ExtArgs>>,
    ): Prisma__PagoSuscripcionClient<
      $Result.GetResult<
        Prisma.$PagoSuscripcionPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first PagoSuscripcion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagoSuscripcionFindFirstOrThrowArgs} args - Arguments to find a PagoSuscripcion
     * @example
     * // Get one PagoSuscripcion
     * const pagoSuscripcion = await prisma.pagoSuscripcion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PagoSuscripcionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PagoSuscripcionFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__PagoSuscripcionClient<
      $Result.GetResult<
        Prisma.$PagoSuscripcionPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more PagoSuscripcions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagoSuscripcionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PagoSuscripcions
     * const pagoSuscripcions = await prisma.pagoSuscripcion.findMany()
     *
     * // Get first 10 PagoSuscripcions
     * const pagoSuscripcions = await prisma.pagoSuscripcion.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const pagoSuscripcionWithIdOnly = await prisma.pagoSuscripcion.findMany({ select: { id: true } })
     *
     */
    findMany<T extends PagoSuscripcionFindManyArgs>(
      args?: SelectSubset<T, PagoSuscripcionFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$PagoSuscripcionPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a PagoSuscripcion.
     * @param {PagoSuscripcionCreateArgs} args - Arguments to create a PagoSuscripcion.
     * @example
     * // Create one PagoSuscripcion
     * const PagoSuscripcion = await prisma.pagoSuscripcion.create({
     *   data: {
     *     // ... data to create a PagoSuscripcion
     *   }
     * })
     *
     */
    create<T extends PagoSuscripcionCreateArgs>(
      args: SelectSubset<T, PagoSuscripcionCreateArgs<ExtArgs>>,
    ): Prisma__PagoSuscripcionClient<
      $Result.GetResult<
        Prisma.$PagoSuscripcionPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many PagoSuscripcions.
     * @param {PagoSuscripcionCreateManyArgs} args - Arguments to create many PagoSuscripcions.
     * @example
     * // Create many PagoSuscripcions
     * const pagoSuscripcion = await prisma.pagoSuscripcion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends PagoSuscripcionCreateManyArgs>(
      args?: SelectSubset<T, PagoSuscripcionCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a PagoSuscripcion.
     * @param {PagoSuscripcionDeleteArgs} args - Arguments to delete one PagoSuscripcion.
     * @example
     * // Delete one PagoSuscripcion
     * const PagoSuscripcion = await prisma.pagoSuscripcion.delete({
     *   where: {
     *     // ... filter to delete one PagoSuscripcion
     *   }
     * })
     *
     */
    delete<T extends PagoSuscripcionDeleteArgs>(
      args: SelectSubset<T, PagoSuscripcionDeleteArgs<ExtArgs>>,
    ): Prisma__PagoSuscripcionClient<
      $Result.GetResult<
        Prisma.$PagoSuscripcionPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one PagoSuscripcion.
     * @param {PagoSuscripcionUpdateArgs} args - Arguments to update one PagoSuscripcion.
     * @example
     * // Update one PagoSuscripcion
     * const pagoSuscripcion = await prisma.pagoSuscripcion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends PagoSuscripcionUpdateArgs>(
      args: SelectSubset<T, PagoSuscripcionUpdateArgs<ExtArgs>>,
    ): Prisma__PagoSuscripcionClient<
      $Result.GetResult<
        Prisma.$PagoSuscripcionPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more PagoSuscripcions.
     * @param {PagoSuscripcionDeleteManyArgs} args - Arguments to filter PagoSuscripcions to delete.
     * @example
     * // Delete a few PagoSuscripcions
     * const { count } = await prisma.pagoSuscripcion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends PagoSuscripcionDeleteManyArgs>(
      args?: SelectSubset<T, PagoSuscripcionDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more PagoSuscripcions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagoSuscripcionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PagoSuscripcions
     * const pagoSuscripcion = await prisma.pagoSuscripcion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends PagoSuscripcionUpdateManyArgs>(
      args: SelectSubset<T, PagoSuscripcionUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one PagoSuscripcion.
     * @param {PagoSuscripcionUpsertArgs} args - Arguments to update or create a PagoSuscripcion.
     * @example
     * // Update or create a PagoSuscripcion
     * const pagoSuscripcion = await prisma.pagoSuscripcion.upsert({
     *   create: {
     *     // ... data to create a PagoSuscripcion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PagoSuscripcion we want to update
     *   }
     * })
     */
    upsert<T extends PagoSuscripcionUpsertArgs>(
      args: SelectSubset<T, PagoSuscripcionUpsertArgs<ExtArgs>>,
    ): Prisma__PagoSuscripcionClient<
      $Result.GetResult<
        Prisma.$PagoSuscripcionPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of PagoSuscripcions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagoSuscripcionCountArgs} args - Arguments to filter PagoSuscripcions to count.
     * @example
     * // Count the number of PagoSuscripcions
     * const count = await prisma.pagoSuscripcion.count({
     *   where: {
     *     // ... the filter for the PagoSuscripcions we want to count
     *   }
     * })
     **/
    count<T extends PagoSuscripcionCountArgs>(
      args?: Subset<T, PagoSuscripcionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PagoSuscripcionCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a PagoSuscripcion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagoSuscripcionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends PagoSuscripcionAggregateArgs>(
      args: Subset<T, PagoSuscripcionAggregateArgs>,
    ): Prisma.PrismaPromise<GetPagoSuscripcionAggregateType<T>>;

    /**
     * Group by PagoSuscripcion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagoSuscripcionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends PagoSuscripcionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PagoSuscripcionGroupByArgs['orderBy'] }
        : { orderBy?: PagoSuscripcionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, PagoSuscripcionGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetPagoSuscripcionGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the PagoSuscripcion model
     */
    readonly fields: PagoSuscripcionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PagoSuscripcion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PagoSuscripcionClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the PagoSuscripcion model
   */
  interface PagoSuscripcionFieldRefs {
    readonly id: FieldRef<'PagoSuscripcion', 'Int'>;
    readonly ordenId: FieldRef<'PagoSuscripcion', 'Int'>;
    readonly usuarioId: FieldRef<'PagoSuscripcion', 'Int'>;
    readonly referenciaPago: FieldRef<'PagoSuscripcion', 'String'>;
    readonly monto: FieldRef<'PagoSuscripcion', 'Decimal'>;
    readonly estado: FieldRef<'PagoSuscripcion', 'String'>;
    readonly metadatos: FieldRef<'PagoSuscripcion', 'Json'>;
    readonly creadoEn: FieldRef<'PagoSuscripcion', 'DateTime'>;
    readonly actualizadoEn: FieldRef<'PagoSuscripcion', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * PagoSuscripcion findUnique
   */
  export type PagoSuscripcionFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PagoSuscripcion
     */
    select?: PagoSuscripcionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PagoSuscripcion
     */
    omit?: PagoSuscripcionOmit<ExtArgs> | null;
    /**
     * Filter, which PagoSuscripcion to fetch.
     */
    where: PagoSuscripcionWhereUniqueInput;
  };

  /**
   * PagoSuscripcion findUniqueOrThrow
   */
  export type PagoSuscripcionFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PagoSuscripcion
     */
    select?: PagoSuscripcionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PagoSuscripcion
     */
    omit?: PagoSuscripcionOmit<ExtArgs> | null;
    /**
     * Filter, which PagoSuscripcion to fetch.
     */
    where: PagoSuscripcionWhereUniqueInput;
  };

  /**
   * PagoSuscripcion findFirst
   */
  export type PagoSuscripcionFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PagoSuscripcion
     */
    select?: PagoSuscripcionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PagoSuscripcion
     */
    omit?: PagoSuscripcionOmit<ExtArgs> | null;
    /**
     * Filter, which PagoSuscripcion to fetch.
     */
    where?: PagoSuscripcionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PagoSuscripcions to fetch.
     */
    orderBy?:
      | PagoSuscripcionOrderByWithRelationInput
      | PagoSuscripcionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for PagoSuscripcions.
     */
    cursor?: PagoSuscripcionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PagoSuscripcions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PagoSuscripcions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of PagoSuscripcions.
     */
    distinct?:
      | PagoSuscripcionScalarFieldEnum
      | PagoSuscripcionScalarFieldEnum[];
  };

  /**
   * PagoSuscripcion findFirstOrThrow
   */
  export type PagoSuscripcionFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PagoSuscripcion
     */
    select?: PagoSuscripcionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PagoSuscripcion
     */
    omit?: PagoSuscripcionOmit<ExtArgs> | null;
    /**
     * Filter, which PagoSuscripcion to fetch.
     */
    where?: PagoSuscripcionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PagoSuscripcions to fetch.
     */
    orderBy?:
      | PagoSuscripcionOrderByWithRelationInput
      | PagoSuscripcionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for PagoSuscripcions.
     */
    cursor?: PagoSuscripcionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PagoSuscripcions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PagoSuscripcions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of PagoSuscripcions.
     */
    distinct?:
      | PagoSuscripcionScalarFieldEnum
      | PagoSuscripcionScalarFieldEnum[];
  };

  /**
   * PagoSuscripcion findMany
   */
  export type PagoSuscripcionFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PagoSuscripcion
     */
    select?: PagoSuscripcionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PagoSuscripcion
     */
    omit?: PagoSuscripcionOmit<ExtArgs> | null;
    /**
     * Filter, which PagoSuscripcions to fetch.
     */
    where?: PagoSuscripcionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PagoSuscripcions to fetch.
     */
    orderBy?:
      | PagoSuscripcionOrderByWithRelationInput
      | PagoSuscripcionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing PagoSuscripcions.
     */
    cursor?: PagoSuscripcionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PagoSuscripcions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PagoSuscripcions.
     */
    skip?: number;
    distinct?:
      | PagoSuscripcionScalarFieldEnum
      | PagoSuscripcionScalarFieldEnum[];
  };

  /**
   * PagoSuscripcion create
   */
  export type PagoSuscripcionCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PagoSuscripcion
     */
    select?: PagoSuscripcionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PagoSuscripcion
     */
    omit?: PagoSuscripcionOmit<ExtArgs> | null;
    /**
     * The data needed to create a PagoSuscripcion.
     */
    data: XOR<PagoSuscripcionCreateInput, PagoSuscripcionUncheckedCreateInput>;
  };

  /**
   * PagoSuscripcion createMany
   */
  export type PagoSuscripcionCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many PagoSuscripcions.
     */
    data: PagoSuscripcionCreateManyInput | PagoSuscripcionCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * PagoSuscripcion update
   */
  export type PagoSuscripcionUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PagoSuscripcion
     */
    select?: PagoSuscripcionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PagoSuscripcion
     */
    omit?: PagoSuscripcionOmit<ExtArgs> | null;
    /**
     * The data needed to update a PagoSuscripcion.
     */
    data: XOR<PagoSuscripcionUpdateInput, PagoSuscripcionUncheckedUpdateInput>;
    /**
     * Choose, which PagoSuscripcion to update.
     */
    where: PagoSuscripcionWhereUniqueInput;
  };

  /**
   * PagoSuscripcion updateMany
   */
  export type PagoSuscripcionUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update PagoSuscripcions.
     */
    data: XOR<
      PagoSuscripcionUpdateManyMutationInput,
      PagoSuscripcionUncheckedUpdateManyInput
    >;
    /**
     * Filter which PagoSuscripcions to update
     */
    where?: PagoSuscripcionWhereInput;
    /**
     * Limit how many PagoSuscripcions to update.
     */
    limit?: number;
  };

  /**
   * PagoSuscripcion upsert
   */
  export type PagoSuscripcionUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PagoSuscripcion
     */
    select?: PagoSuscripcionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PagoSuscripcion
     */
    omit?: PagoSuscripcionOmit<ExtArgs> | null;
    /**
     * The filter to search for the PagoSuscripcion to update in case it exists.
     */
    where: PagoSuscripcionWhereUniqueInput;
    /**
     * In case the PagoSuscripcion found by the `where` argument doesn't exist, create a new PagoSuscripcion with this data.
     */
    create: XOR<
      PagoSuscripcionCreateInput,
      PagoSuscripcionUncheckedCreateInput
    >;
    /**
     * In case the PagoSuscripcion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      PagoSuscripcionUpdateInput,
      PagoSuscripcionUncheckedUpdateInput
    >;
  };

  /**
   * PagoSuscripcion delete
   */
  export type PagoSuscripcionDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PagoSuscripcion
     */
    select?: PagoSuscripcionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PagoSuscripcion
     */
    omit?: PagoSuscripcionOmit<ExtArgs> | null;
    /**
     * Filter which PagoSuscripcion to delete.
     */
    where: PagoSuscripcionWhereUniqueInput;
  };

  /**
   * PagoSuscripcion deleteMany
   */
  export type PagoSuscripcionDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which PagoSuscripcions to delete
     */
    where?: PagoSuscripcionWhereInput;
    /**
     * Limit how many PagoSuscripcions to delete.
     */
    limit?: number;
  };

  /**
   * PagoSuscripcion without action
   */
  export type PagoSuscripcionDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PagoSuscripcion
     */
    select?: PagoSuscripcionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PagoSuscripcion
     */
    omit?: PagoSuscripcionOmit<ExtArgs> | null;
  };

  /**
   * Model Direccion
   */

  export type AggregateDireccion = {
    _count: DireccionCountAggregateOutputType | null;
    _avg: DireccionAvgAggregateOutputType | null;
    _sum: DireccionSumAggregateOutputType | null;
    _min: DireccionMinAggregateOutputType | null;
    _max: DireccionMaxAggregateOutputType | null;
  };

  export type DireccionAvgAggregateOutputType = {
    id: number | null;
    usuarioId: number | null;
  };

  export type DireccionSumAggregateOutputType = {
    id: number | null;
    usuarioId: number | null;
  };

  export type DireccionMinAggregateOutputType = {
    id: number | null;
    usuarioId: number | null;
    etiqueta: string | null;
    nombre: string | null;
    telefono: string | null;
    calle: string | null;
    numero: string | null;
    pisoDepto: string | null;
    ciudad: string | null;
    provincia: string | null;
    cp: string | null;
    pais: string | null;
    predeterminada: boolean | null;
    creadoEn: Date | null;
    actualizadoEn: Date | null;
  };

  export type DireccionMaxAggregateOutputType = {
    id: number | null;
    usuarioId: number | null;
    etiqueta: string | null;
    nombre: string | null;
    telefono: string | null;
    calle: string | null;
    numero: string | null;
    pisoDepto: string | null;
    ciudad: string | null;
    provincia: string | null;
    cp: string | null;
    pais: string | null;
    predeterminada: boolean | null;
    creadoEn: Date | null;
    actualizadoEn: Date | null;
  };

  export type DireccionCountAggregateOutputType = {
    id: number;
    usuarioId: number;
    etiqueta: number;
    nombre: number;
    telefono: number;
    calle: number;
    numero: number;
    pisoDepto: number;
    ciudad: number;
    provincia: number;
    cp: number;
    pais: number;
    predeterminada: number;
    creadoEn: number;
    actualizadoEn: number;
    _all: number;
  };

  export type DireccionAvgAggregateInputType = {
    id?: true;
    usuarioId?: true;
  };

  export type DireccionSumAggregateInputType = {
    id?: true;
    usuarioId?: true;
  };

  export type DireccionMinAggregateInputType = {
    id?: true;
    usuarioId?: true;
    etiqueta?: true;
    nombre?: true;
    telefono?: true;
    calle?: true;
    numero?: true;
    pisoDepto?: true;
    ciudad?: true;
    provincia?: true;
    cp?: true;
    pais?: true;
    predeterminada?: true;
    creadoEn?: true;
    actualizadoEn?: true;
  };

  export type DireccionMaxAggregateInputType = {
    id?: true;
    usuarioId?: true;
    etiqueta?: true;
    nombre?: true;
    telefono?: true;
    calle?: true;
    numero?: true;
    pisoDepto?: true;
    ciudad?: true;
    provincia?: true;
    cp?: true;
    pais?: true;
    predeterminada?: true;
    creadoEn?: true;
    actualizadoEn?: true;
  };

  export type DireccionCountAggregateInputType = {
    id?: true;
    usuarioId?: true;
    etiqueta?: true;
    nombre?: true;
    telefono?: true;
    calle?: true;
    numero?: true;
    pisoDepto?: true;
    ciudad?: true;
    provincia?: true;
    cp?: true;
    pais?: true;
    predeterminada?: true;
    creadoEn?: true;
    actualizadoEn?: true;
    _all?: true;
  };

  export type DireccionAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Direccion to aggregate.
     */
    where?: DireccionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Direccions to fetch.
     */
    orderBy?:
      | DireccionOrderByWithRelationInput
      | DireccionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: DireccionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Direccions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Direccions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Direccions
     **/
    _count?: true | DireccionCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: DireccionAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: DireccionSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: DireccionMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: DireccionMaxAggregateInputType;
  };

  export type GetDireccionAggregateType<T extends DireccionAggregateArgs> = {
    [P in keyof T & keyof AggregateDireccion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDireccion[P]>
      : GetScalarType<T[P], AggregateDireccion[P]>;
  };

  export type DireccionGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: DireccionWhereInput;
    orderBy?:
      | DireccionOrderByWithAggregationInput
      | DireccionOrderByWithAggregationInput[];
    by: DireccionScalarFieldEnum[] | DireccionScalarFieldEnum;
    having?: DireccionScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: DireccionCountAggregateInputType | true;
    _avg?: DireccionAvgAggregateInputType;
    _sum?: DireccionSumAggregateInputType;
    _min?: DireccionMinAggregateInputType;
    _max?: DireccionMaxAggregateInputType;
  };

  export type DireccionGroupByOutputType = {
    id: number;
    usuarioId: number;
    etiqueta: string | null;
    nombre: string;
    telefono: string | null;
    calle: string;
    numero: string | null;
    pisoDepto: string | null;
    ciudad: string;
    provincia: string;
    cp: string;
    pais: string;
    predeterminada: boolean;
    creadoEn: Date;
    actualizadoEn: Date;
    _count: DireccionCountAggregateOutputType | null;
    _avg: DireccionAvgAggregateOutputType | null;
    _sum: DireccionSumAggregateOutputType | null;
    _min: DireccionMinAggregateOutputType | null;
    _max: DireccionMaxAggregateOutputType | null;
  };

  type GetDireccionGroupByPayload<T extends DireccionGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<DireccionGroupByOutputType, T['by']> & {
          [P in keyof T & keyof DireccionGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DireccionGroupByOutputType[P]>
            : GetScalarType<T[P], DireccionGroupByOutputType[P]>;
        }
      >
    >;

  export type DireccionSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      usuarioId?: boolean;
      etiqueta?: boolean;
      nombre?: boolean;
      telefono?: boolean;
      calle?: boolean;
      numero?: boolean;
      pisoDepto?: boolean;
      ciudad?: boolean;
      provincia?: boolean;
      cp?: boolean;
      pais?: boolean;
      predeterminada?: boolean;
      creadoEn?: boolean;
      actualizadoEn?: boolean;
      ordenesEnvio?: boolean | Direccion$ordenesEnvioArgs<ExtArgs>;
      ordenesFacturacion?: boolean | Direccion$ordenesFacturacionArgs<ExtArgs>;
      _count?: boolean | DireccionCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['direccion']
  >;

  export type DireccionSelectScalar = {
    id?: boolean;
    usuarioId?: boolean;
    etiqueta?: boolean;
    nombre?: boolean;
    telefono?: boolean;
    calle?: boolean;
    numero?: boolean;
    pisoDepto?: boolean;
    ciudad?: boolean;
    provincia?: boolean;
    cp?: boolean;
    pais?: boolean;
    predeterminada?: boolean;
    creadoEn?: boolean;
    actualizadoEn?: boolean;
  };

  export type DireccionOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'usuarioId'
    | 'etiqueta'
    | 'nombre'
    | 'telefono'
    | 'calle'
    | 'numero'
    | 'pisoDepto'
    | 'ciudad'
    | 'provincia'
    | 'cp'
    | 'pais'
    | 'predeterminada'
    | 'creadoEn'
    | 'actualizadoEn',
    ExtArgs['result']['direccion']
  >;
  export type DireccionInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    ordenesEnvio?: boolean | Direccion$ordenesEnvioArgs<ExtArgs>;
    ordenesFacturacion?: boolean | Direccion$ordenesFacturacionArgs<ExtArgs>;
    _count?: boolean | DireccionCountOutputTypeDefaultArgs<ExtArgs>;
  };

  export type $DireccionPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Direccion';
    objects: {
      ordenesEnvio: Prisma.$OrdenPayload<ExtArgs>[];
      ordenesFacturacion: Prisma.$OrdenPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        usuarioId: number;
        etiqueta: string | null;
        nombre: string;
        telefono: string | null;
        calle: string;
        numero: string | null;
        pisoDepto: string | null;
        ciudad: string;
        provincia: string;
        cp: string;
        pais: string;
        predeterminada: boolean;
        creadoEn: Date;
        actualizadoEn: Date;
      },
      ExtArgs['result']['direccion']
    >;
    composites: {};
  };

  type DireccionGetPayload<
    S extends boolean | null | undefined | DireccionDefaultArgs,
  > = $Result.GetResult<Prisma.$DireccionPayload, S>;

  type DireccionCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    DireccionFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: DireccionCountAggregateInputType | true;
  };

  export interface DireccionDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Direccion'];
      meta: { name: 'Direccion' };
    };
    /**
     * Find zero or one Direccion that matches the filter.
     * @param {DireccionFindUniqueArgs} args - Arguments to find a Direccion
     * @example
     * // Get one Direccion
     * const direccion = await prisma.direccion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DireccionFindUniqueArgs>(
      args: SelectSubset<T, DireccionFindUniqueArgs<ExtArgs>>,
    ): Prisma__DireccionClient<
      $Result.GetResult<
        Prisma.$DireccionPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Direccion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DireccionFindUniqueOrThrowArgs} args - Arguments to find a Direccion
     * @example
     * // Get one Direccion
     * const direccion = await prisma.direccion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DireccionFindUniqueOrThrowArgs>(
      args: SelectSubset<T, DireccionFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__DireccionClient<
      $Result.GetResult<
        Prisma.$DireccionPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Direccion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DireccionFindFirstArgs} args - Arguments to find a Direccion
     * @example
     * // Get one Direccion
     * const direccion = await prisma.direccion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DireccionFindFirstArgs>(
      args?: SelectSubset<T, DireccionFindFirstArgs<ExtArgs>>,
    ): Prisma__DireccionClient<
      $Result.GetResult<
        Prisma.$DireccionPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Direccion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DireccionFindFirstOrThrowArgs} args - Arguments to find a Direccion
     * @example
     * // Get one Direccion
     * const direccion = await prisma.direccion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DireccionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DireccionFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__DireccionClient<
      $Result.GetResult<
        Prisma.$DireccionPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Direccions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DireccionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Direccions
     * const direccions = await prisma.direccion.findMany()
     *
     * // Get first 10 Direccions
     * const direccions = await prisma.direccion.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const direccionWithIdOnly = await prisma.direccion.findMany({ select: { id: true } })
     *
     */
    findMany<T extends DireccionFindManyArgs>(
      args?: SelectSubset<T, DireccionFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$DireccionPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Direccion.
     * @param {DireccionCreateArgs} args - Arguments to create a Direccion.
     * @example
     * // Create one Direccion
     * const Direccion = await prisma.direccion.create({
     *   data: {
     *     // ... data to create a Direccion
     *   }
     * })
     *
     */
    create<T extends DireccionCreateArgs>(
      args: SelectSubset<T, DireccionCreateArgs<ExtArgs>>,
    ): Prisma__DireccionClient<
      $Result.GetResult<
        Prisma.$DireccionPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Direccions.
     * @param {DireccionCreateManyArgs} args - Arguments to create many Direccions.
     * @example
     * // Create many Direccions
     * const direccion = await prisma.direccion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends DireccionCreateManyArgs>(
      args?: SelectSubset<T, DireccionCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Direccion.
     * @param {DireccionDeleteArgs} args - Arguments to delete one Direccion.
     * @example
     * // Delete one Direccion
     * const Direccion = await prisma.direccion.delete({
     *   where: {
     *     // ... filter to delete one Direccion
     *   }
     * })
     *
     */
    delete<T extends DireccionDeleteArgs>(
      args: SelectSubset<T, DireccionDeleteArgs<ExtArgs>>,
    ): Prisma__DireccionClient<
      $Result.GetResult<
        Prisma.$DireccionPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Direccion.
     * @param {DireccionUpdateArgs} args - Arguments to update one Direccion.
     * @example
     * // Update one Direccion
     * const direccion = await prisma.direccion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends DireccionUpdateArgs>(
      args: SelectSubset<T, DireccionUpdateArgs<ExtArgs>>,
    ): Prisma__DireccionClient<
      $Result.GetResult<
        Prisma.$DireccionPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Direccions.
     * @param {DireccionDeleteManyArgs} args - Arguments to filter Direccions to delete.
     * @example
     * // Delete a few Direccions
     * const { count } = await prisma.direccion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends DireccionDeleteManyArgs>(
      args?: SelectSubset<T, DireccionDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Direccions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DireccionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Direccions
     * const direccion = await prisma.direccion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends DireccionUpdateManyArgs>(
      args: SelectSubset<T, DireccionUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Direccion.
     * @param {DireccionUpsertArgs} args - Arguments to update or create a Direccion.
     * @example
     * // Update or create a Direccion
     * const direccion = await prisma.direccion.upsert({
     *   create: {
     *     // ... data to create a Direccion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Direccion we want to update
     *   }
     * })
     */
    upsert<T extends DireccionUpsertArgs>(
      args: SelectSubset<T, DireccionUpsertArgs<ExtArgs>>,
    ): Prisma__DireccionClient<
      $Result.GetResult<
        Prisma.$DireccionPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Direccions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DireccionCountArgs} args - Arguments to filter Direccions to count.
     * @example
     * // Count the number of Direccions
     * const count = await prisma.direccion.count({
     *   where: {
     *     // ... the filter for the Direccions we want to count
     *   }
     * })
     **/
    count<T extends DireccionCountArgs>(
      args?: Subset<T, DireccionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DireccionCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Direccion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DireccionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends DireccionAggregateArgs>(
      args: Subset<T, DireccionAggregateArgs>,
    ): Prisma.PrismaPromise<GetDireccionAggregateType<T>>;

    /**
     * Group by Direccion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DireccionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends DireccionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DireccionGroupByArgs['orderBy'] }
        : { orderBy?: DireccionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, DireccionGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetDireccionGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Direccion model
     */
    readonly fields: DireccionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Direccion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DireccionClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    ordenesEnvio<T extends Direccion$ordenesEnvioArgs<ExtArgs> = {}>(
      args?: Subset<T, Direccion$ordenesEnvioArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$OrdenPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    ordenesFacturacion<
      T extends Direccion$ordenesFacturacionArgs<ExtArgs> = {},
    >(
      args?: Subset<T, Direccion$ordenesFacturacionArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$OrdenPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Direccion model
   */
  interface DireccionFieldRefs {
    readonly id: FieldRef<'Direccion', 'Int'>;
    readonly usuarioId: FieldRef<'Direccion', 'Int'>;
    readonly etiqueta: FieldRef<'Direccion', 'String'>;
    readonly nombre: FieldRef<'Direccion', 'String'>;
    readonly telefono: FieldRef<'Direccion', 'String'>;
    readonly calle: FieldRef<'Direccion', 'String'>;
    readonly numero: FieldRef<'Direccion', 'String'>;
    readonly pisoDepto: FieldRef<'Direccion', 'String'>;
    readonly ciudad: FieldRef<'Direccion', 'String'>;
    readonly provincia: FieldRef<'Direccion', 'String'>;
    readonly cp: FieldRef<'Direccion', 'String'>;
    readonly pais: FieldRef<'Direccion', 'String'>;
    readonly predeterminada: FieldRef<'Direccion', 'Boolean'>;
    readonly creadoEn: FieldRef<'Direccion', 'DateTime'>;
    readonly actualizadoEn: FieldRef<'Direccion', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Direccion findUnique
   */
  export type DireccionFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Direccion
     */
    select?: DireccionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Direccion
     */
    omit?: DireccionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DireccionInclude<ExtArgs> | null;
    /**
     * Filter, which Direccion to fetch.
     */
    where: DireccionWhereUniqueInput;
  };

  /**
   * Direccion findUniqueOrThrow
   */
  export type DireccionFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Direccion
     */
    select?: DireccionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Direccion
     */
    omit?: DireccionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DireccionInclude<ExtArgs> | null;
    /**
     * Filter, which Direccion to fetch.
     */
    where: DireccionWhereUniqueInput;
  };

  /**
   * Direccion findFirst
   */
  export type DireccionFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Direccion
     */
    select?: DireccionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Direccion
     */
    omit?: DireccionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DireccionInclude<ExtArgs> | null;
    /**
     * Filter, which Direccion to fetch.
     */
    where?: DireccionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Direccions to fetch.
     */
    orderBy?:
      | DireccionOrderByWithRelationInput
      | DireccionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Direccions.
     */
    cursor?: DireccionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Direccions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Direccions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Direccions.
     */
    distinct?: DireccionScalarFieldEnum | DireccionScalarFieldEnum[];
  };

  /**
   * Direccion findFirstOrThrow
   */
  export type DireccionFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Direccion
     */
    select?: DireccionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Direccion
     */
    omit?: DireccionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DireccionInclude<ExtArgs> | null;
    /**
     * Filter, which Direccion to fetch.
     */
    where?: DireccionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Direccions to fetch.
     */
    orderBy?:
      | DireccionOrderByWithRelationInput
      | DireccionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Direccions.
     */
    cursor?: DireccionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Direccions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Direccions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Direccions.
     */
    distinct?: DireccionScalarFieldEnum | DireccionScalarFieldEnum[];
  };

  /**
   * Direccion findMany
   */
  export type DireccionFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Direccion
     */
    select?: DireccionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Direccion
     */
    omit?: DireccionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DireccionInclude<ExtArgs> | null;
    /**
     * Filter, which Direccions to fetch.
     */
    where?: DireccionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Direccions to fetch.
     */
    orderBy?:
      | DireccionOrderByWithRelationInput
      | DireccionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Direccions.
     */
    cursor?: DireccionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Direccions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Direccions.
     */
    skip?: number;
    distinct?: DireccionScalarFieldEnum | DireccionScalarFieldEnum[];
  };

  /**
   * Direccion create
   */
  export type DireccionCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Direccion
     */
    select?: DireccionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Direccion
     */
    omit?: DireccionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DireccionInclude<ExtArgs> | null;
    /**
     * The data needed to create a Direccion.
     */
    data: XOR<DireccionCreateInput, DireccionUncheckedCreateInput>;
  };

  /**
   * Direccion createMany
   */
  export type DireccionCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Direccions.
     */
    data: DireccionCreateManyInput | DireccionCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Direccion update
   */
  export type DireccionUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Direccion
     */
    select?: DireccionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Direccion
     */
    omit?: DireccionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DireccionInclude<ExtArgs> | null;
    /**
     * The data needed to update a Direccion.
     */
    data: XOR<DireccionUpdateInput, DireccionUncheckedUpdateInput>;
    /**
     * Choose, which Direccion to update.
     */
    where: DireccionWhereUniqueInput;
  };

  /**
   * Direccion updateMany
   */
  export type DireccionUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Direccions.
     */
    data: XOR<
      DireccionUpdateManyMutationInput,
      DireccionUncheckedUpdateManyInput
    >;
    /**
     * Filter which Direccions to update
     */
    where?: DireccionWhereInput;
    /**
     * Limit how many Direccions to update.
     */
    limit?: number;
  };

  /**
   * Direccion upsert
   */
  export type DireccionUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Direccion
     */
    select?: DireccionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Direccion
     */
    omit?: DireccionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DireccionInclude<ExtArgs> | null;
    /**
     * The filter to search for the Direccion to update in case it exists.
     */
    where: DireccionWhereUniqueInput;
    /**
     * In case the Direccion found by the `where` argument doesn't exist, create a new Direccion with this data.
     */
    create: XOR<DireccionCreateInput, DireccionUncheckedCreateInput>;
    /**
     * In case the Direccion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DireccionUpdateInput, DireccionUncheckedUpdateInput>;
  };

  /**
   * Direccion delete
   */
  export type DireccionDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Direccion
     */
    select?: DireccionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Direccion
     */
    omit?: DireccionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DireccionInclude<ExtArgs> | null;
    /**
     * Filter which Direccion to delete.
     */
    where: DireccionWhereUniqueInput;
  };

  /**
   * Direccion deleteMany
   */
  export type DireccionDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Direccions to delete
     */
    where?: DireccionWhereInput;
    /**
     * Limit how many Direccions to delete.
     */
    limit?: number;
  };

  /**
   * Direccion.ordenesEnvio
   */
  export type Direccion$ordenesEnvioArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Orden
     */
    select?: OrdenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Orden
     */
    omit?: OrdenOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdenInclude<ExtArgs> | null;
    where?: OrdenWhereInput;
    orderBy?: OrdenOrderByWithRelationInput | OrdenOrderByWithRelationInput[];
    cursor?: OrdenWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: OrdenScalarFieldEnum | OrdenScalarFieldEnum[];
  };

  /**
   * Direccion.ordenesFacturacion
   */
  export type Direccion$ordenesFacturacionArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Orden
     */
    select?: OrdenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Orden
     */
    omit?: OrdenOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdenInclude<ExtArgs> | null;
    where?: OrdenWhereInput;
    orderBy?: OrdenOrderByWithRelationInput | OrdenOrderByWithRelationInput[];
    cursor?: OrdenWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: OrdenScalarFieldEnum | OrdenScalarFieldEnum[];
  };

  /**
   * Direccion without action
   */
  export type DireccionDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Direccion
     */
    select?: DireccionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Direccion
     */
    omit?: DireccionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DireccionInclude<ExtArgs> | null;
  };

  /**
   * Model Slider
   */

  export type AggregateSlider = {
    _count: SliderCountAggregateOutputType | null;
    _avg: SliderAvgAggregateOutputType | null;
    _sum: SliderSumAggregateOutputType | null;
    _min: SliderMinAggregateOutputType | null;
    _max: SliderMaxAggregateOutputType | null;
  };

  export type SliderAvgAggregateOutputType = {
    id: number | null;
    orden: number | null;
  };

  export type SliderSumAggregateOutputType = {
    id: number | null;
    orden: number | null;
  };

  export type SliderMinAggregateOutputType = {
    id: number | null;
    titulo: string | null;
    alt: string | null;
    archivo: string | null;
    activa: boolean | null;
    orden: number | null;
    creadoEn: Date | null;
    actualizadoEn: Date | null;
    ctaPrimarioHref: string | null;
    ctaPrimarioTexto: string | null;
    ctaSecundarioHref: string | null;
    ctaSecundarioTexto: string | null;
    descripcion: string | null;
    etiqueta: string | null;
    subtitulo: string | null;
  };

  export type SliderMaxAggregateOutputType = {
    id: number | null;
    titulo: string | null;
    alt: string | null;
    archivo: string | null;
    activa: boolean | null;
    orden: number | null;
    creadoEn: Date | null;
    actualizadoEn: Date | null;
    ctaPrimarioHref: string | null;
    ctaPrimarioTexto: string | null;
    ctaSecundarioHref: string | null;
    ctaSecundarioTexto: string | null;
    descripcion: string | null;
    etiqueta: string | null;
    subtitulo: string | null;
  };

  export type SliderCountAggregateOutputType = {
    id: number;
    titulo: number;
    alt: number;
    archivo: number;
    activa: number;
    orden: number;
    creadoEn: number;
    actualizadoEn: number;
    ctaPrimarioHref: number;
    ctaPrimarioTexto: number;
    ctaSecundarioHref: number;
    ctaSecundarioTexto: number;
    descripcion: number;
    etiqueta: number;
    subtitulo: number;
    _all: number;
  };

  export type SliderAvgAggregateInputType = {
    id?: true;
    orden?: true;
  };

  export type SliderSumAggregateInputType = {
    id?: true;
    orden?: true;
  };

  export type SliderMinAggregateInputType = {
    id?: true;
    titulo?: true;
    alt?: true;
    archivo?: true;
    activa?: true;
    orden?: true;
    creadoEn?: true;
    actualizadoEn?: true;
    ctaPrimarioHref?: true;
    ctaPrimarioTexto?: true;
    ctaSecundarioHref?: true;
    ctaSecundarioTexto?: true;
    descripcion?: true;
    etiqueta?: true;
    subtitulo?: true;
  };

  export type SliderMaxAggregateInputType = {
    id?: true;
    titulo?: true;
    alt?: true;
    archivo?: true;
    activa?: true;
    orden?: true;
    creadoEn?: true;
    actualizadoEn?: true;
    ctaPrimarioHref?: true;
    ctaPrimarioTexto?: true;
    ctaSecundarioHref?: true;
    ctaSecundarioTexto?: true;
    descripcion?: true;
    etiqueta?: true;
    subtitulo?: true;
  };

  export type SliderCountAggregateInputType = {
    id?: true;
    titulo?: true;
    alt?: true;
    archivo?: true;
    activa?: true;
    orden?: true;
    creadoEn?: true;
    actualizadoEn?: true;
    ctaPrimarioHref?: true;
    ctaPrimarioTexto?: true;
    ctaSecundarioHref?: true;
    ctaSecundarioTexto?: true;
    descripcion?: true;
    etiqueta?: true;
    subtitulo?: true;
    _all?: true;
  };

  export type SliderAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Slider to aggregate.
     */
    where?: SliderWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Sliders to fetch.
     */
    orderBy?: SliderOrderByWithRelationInput | SliderOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: SliderWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Sliders from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Sliders.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Sliders
     **/
    _count?: true | SliderCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: SliderAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: SliderSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: SliderMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: SliderMaxAggregateInputType;
  };

  export type GetSliderAggregateType<T extends SliderAggregateArgs> = {
    [P in keyof T & keyof AggregateSlider]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSlider[P]>
      : GetScalarType<T[P], AggregateSlider[P]>;
  };

  export type SliderGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: SliderWhereInput;
    orderBy?:
      | SliderOrderByWithAggregationInput
      | SliderOrderByWithAggregationInput[];
    by: SliderScalarFieldEnum[] | SliderScalarFieldEnum;
    having?: SliderScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: SliderCountAggregateInputType | true;
    _avg?: SliderAvgAggregateInputType;
    _sum?: SliderSumAggregateInputType;
    _min?: SliderMinAggregateInputType;
    _max?: SliderMaxAggregateInputType;
  };

  export type SliderGroupByOutputType = {
    id: number;
    titulo: string;
    alt: string;
    archivo: string;
    activa: boolean;
    orden: number;
    creadoEn: Date;
    actualizadoEn: Date;
    ctaPrimarioHref: string | null;
    ctaPrimarioTexto: string | null;
    ctaSecundarioHref: string | null;
    ctaSecundarioTexto: string | null;
    descripcion: string | null;
    etiqueta: string | null;
    subtitulo: string | null;
    _count: SliderCountAggregateOutputType | null;
    _avg: SliderAvgAggregateOutputType | null;
    _sum: SliderSumAggregateOutputType | null;
    _min: SliderMinAggregateOutputType | null;
    _max: SliderMaxAggregateOutputType | null;
  };

  type GetSliderGroupByPayload<T extends SliderGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<SliderGroupByOutputType, T['by']> & {
          [P in keyof T & keyof SliderGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SliderGroupByOutputType[P]>
            : GetScalarType<T[P], SliderGroupByOutputType[P]>;
        }
      >
    >;

  export type SliderSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      titulo?: boolean;
      alt?: boolean;
      archivo?: boolean;
      activa?: boolean;
      orden?: boolean;
      creadoEn?: boolean;
      actualizadoEn?: boolean;
      ctaPrimarioHref?: boolean;
      ctaPrimarioTexto?: boolean;
      ctaSecundarioHref?: boolean;
      ctaSecundarioTexto?: boolean;
      descripcion?: boolean;
      etiqueta?: boolean;
      subtitulo?: boolean;
    },
    ExtArgs['result']['slider']
  >;

  export type SliderSelectScalar = {
    id?: boolean;
    titulo?: boolean;
    alt?: boolean;
    archivo?: boolean;
    activa?: boolean;
    orden?: boolean;
    creadoEn?: boolean;
    actualizadoEn?: boolean;
    ctaPrimarioHref?: boolean;
    ctaPrimarioTexto?: boolean;
    ctaSecundarioHref?: boolean;
    ctaSecundarioTexto?: boolean;
    descripcion?: boolean;
    etiqueta?: boolean;
    subtitulo?: boolean;
  };

  export type SliderOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'titulo'
    | 'alt'
    | 'archivo'
    | 'activa'
    | 'orden'
    | 'creadoEn'
    | 'actualizadoEn'
    | 'ctaPrimarioHref'
    | 'ctaPrimarioTexto'
    | 'ctaSecundarioHref'
    | 'ctaSecundarioTexto'
    | 'descripcion'
    | 'etiqueta'
    | 'subtitulo',
    ExtArgs['result']['slider']
  >;

  export type $SliderPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Slider';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        titulo: string;
        alt: string;
        archivo: string;
        activa: boolean;
        orden: number;
        creadoEn: Date;
        actualizadoEn: Date;
        ctaPrimarioHref: string | null;
        ctaPrimarioTexto: string | null;
        ctaSecundarioHref: string | null;
        ctaSecundarioTexto: string | null;
        descripcion: string | null;
        etiqueta: string | null;
        subtitulo: string | null;
      },
      ExtArgs['result']['slider']
    >;
    composites: {};
  };

  type SliderGetPayload<
    S extends boolean | null | undefined | SliderDefaultArgs,
  > = $Result.GetResult<Prisma.$SliderPayload, S>;

  type SliderCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<SliderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: SliderCountAggregateInputType | true;
  };

  export interface SliderDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Slider'];
      meta: { name: 'Slider' };
    };
    /**
     * Find zero or one Slider that matches the filter.
     * @param {SliderFindUniqueArgs} args - Arguments to find a Slider
     * @example
     * // Get one Slider
     * const slider = await prisma.slider.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SliderFindUniqueArgs>(
      args: SelectSubset<T, SliderFindUniqueArgs<ExtArgs>>,
    ): Prisma__SliderClient<
      $Result.GetResult<
        Prisma.$SliderPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Slider that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SliderFindUniqueOrThrowArgs} args - Arguments to find a Slider
     * @example
     * // Get one Slider
     * const slider = await prisma.slider.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SliderFindUniqueOrThrowArgs>(
      args: SelectSubset<T, SliderFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__SliderClient<
      $Result.GetResult<
        Prisma.$SliderPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Slider that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SliderFindFirstArgs} args - Arguments to find a Slider
     * @example
     * // Get one Slider
     * const slider = await prisma.slider.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SliderFindFirstArgs>(
      args?: SelectSubset<T, SliderFindFirstArgs<ExtArgs>>,
    ): Prisma__SliderClient<
      $Result.GetResult<
        Prisma.$SliderPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Slider that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SliderFindFirstOrThrowArgs} args - Arguments to find a Slider
     * @example
     * // Get one Slider
     * const slider = await prisma.slider.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SliderFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SliderFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__SliderClient<
      $Result.GetResult<
        Prisma.$SliderPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Sliders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SliderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sliders
     * const sliders = await prisma.slider.findMany()
     *
     * // Get first 10 Sliders
     * const sliders = await prisma.slider.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const sliderWithIdOnly = await prisma.slider.findMany({ select: { id: true } })
     *
     */
    findMany<T extends SliderFindManyArgs>(
      args?: SelectSubset<T, SliderFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SliderPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Slider.
     * @param {SliderCreateArgs} args - Arguments to create a Slider.
     * @example
     * // Create one Slider
     * const Slider = await prisma.slider.create({
     *   data: {
     *     // ... data to create a Slider
     *   }
     * })
     *
     */
    create<T extends SliderCreateArgs>(
      args: SelectSubset<T, SliderCreateArgs<ExtArgs>>,
    ): Prisma__SliderClient<
      $Result.GetResult<
        Prisma.$SliderPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Sliders.
     * @param {SliderCreateManyArgs} args - Arguments to create many Sliders.
     * @example
     * // Create many Sliders
     * const slider = await prisma.slider.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends SliderCreateManyArgs>(
      args?: SelectSubset<T, SliderCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Slider.
     * @param {SliderDeleteArgs} args - Arguments to delete one Slider.
     * @example
     * // Delete one Slider
     * const Slider = await prisma.slider.delete({
     *   where: {
     *     // ... filter to delete one Slider
     *   }
     * })
     *
     */
    delete<T extends SliderDeleteArgs>(
      args: SelectSubset<T, SliderDeleteArgs<ExtArgs>>,
    ): Prisma__SliderClient<
      $Result.GetResult<
        Prisma.$SliderPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Slider.
     * @param {SliderUpdateArgs} args - Arguments to update one Slider.
     * @example
     * // Update one Slider
     * const slider = await prisma.slider.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends SliderUpdateArgs>(
      args: SelectSubset<T, SliderUpdateArgs<ExtArgs>>,
    ): Prisma__SliderClient<
      $Result.GetResult<
        Prisma.$SliderPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Sliders.
     * @param {SliderDeleteManyArgs} args - Arguments to filter Sliders to delete.
     * @example
     * // Delete a few Sliders
     * const { count } = await prisma.slider.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends SliderDeleteManyArgs>(
      args?: SelectSubset<T, SliderDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Sliders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SliderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sliders
     * const slider = await prisma.slider.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends SliderUpdateManyArgs>(
      args: SelectSubset<T, SliderUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Slider.
     * @param {SliderUpsertArgs} args - Arguments to update or create a Slider.
     * @example
     * // Update or create a Slider
     * const slider = await prisma.slider.upsert({
     *   create: {
     *     // ... data to create a Slider
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Slider we want to update
     *   }
     * })
     */
    upsert<T extends SliderUpsertArgs>(
      args: SelectSubset<T, SliderUpsertArgs<ExtArgs>>,
    ): Prisma__SliderClient<
      $Result.GetResult<
        Prisma.$SliderPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Sliders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SliderCountArgs} args - Arguments to filter Sliders to count.
     * @example
     * // Count the number of Sliders
     * const count = await prisma.slider.count({
     *   where: {
     *     // ... the filter for the Sliders we want to count
     *   }
     * })
     **/
    count<T extends SliderCountArgs>(
      args?: Subset<T, SliderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SliderCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Slider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SliderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends SliderAggregateArgs>(
      args: Subset<T, SliderAggregateArgs>,
    ): Prisma.PrismaPromise<GetSliderAggregateType<T>>;

    /**
     * Group by Slider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SliderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends SliderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SliderGroupByArgs['orderBy'] }
        : { orderBy?: SliderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, SliderGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetSliderGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Slider model
     */
    readonly fields: SliderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Slider.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SliderClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Slider model
   */
  interface SliderFieldRefs {
    readonly id: FieldRef<'Slider', 'Int'>;
    readonly titulo: FieldRef<'Slider', 'String'>;
    readonly alt: FieldRef<'Slider', 'String'>;
    readonly archivo: FieldRef<'Slider', 'String'>;
    readonly activa: FieldRef<'Slider', 'Boolean'>;
    readonly orden: FieldRef<'Slider', 'Int'>;
    readonly creadoEn: FieldRef<'Slider', 'DateTime'>;
    readonly actualizadoEn: FieldRef<'Slider', 'DateTime'>;
    readonly ctaPrimarioHref: FieldRef<'Slider', 'String'>;
    readonly ctaPrimarioTexto: FieldRef<'Slider', 'String'>;
    readonly ctaSecundarioHref: FieldRef<'Slider', 'String'>;
    readonly ctaSecundarioTexto: FieldRef<'Slider', 'String'>;
    readonly descripcion: FieldRef<'Slider', 'String'>;
    readonly etiqueta: FieldRef<'Slider', 'String'>;
    readonly subtitulo: FieldRef<'Slider', 'String'>;
  }

  // Custom InputTypes
  /**
   * Slider findUnique
   */
  export type SliderFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Slider
     */
    select?: SliderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Slider
     */
    omit?: SliderOmit<ExtArgs> | null;
    /**
     * Filter, which Slider to fetch.
     */
    where: SliderWhereUniqueInput;
  };

  /**
   * Slider findUniqueOrThrow
   */
  export type SliderFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Slider
     */
    select?: SliderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Slider
     */
    omit?: SliderOmit<ExtArgs> | null;
    /**
     * Filter, which Slider to fetch.
     */
    where: SliderWhereUniqueInput;
  };

  /**
   * Slider findFirst
   */
  export type SliderFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Slider
     */
    select?: SliderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Slider
     */
    omit?: SliderOmit<ExtArgs> | null;
    /**
     * Filter, which Slider to fetch.
     */
    where?: SliderWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Sliders to fetch.
     */
    orderBy?: SliderOrderByWithRelationInput | SliderOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Sliders.
     */
    cursor?: SliderWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Sliders from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Sliders.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Sliders.
     */
    distinct?: SliderScalarFieldEnum | SliderScalarFieldEnum[];
  };

  /**
   * Slider findFirstOrThrow
   */
  export type SliderFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Slider
     */
    select?: SliderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Slider
     */
    omit?: SliderOmit<ExtArgs> | null;
    /**
     * Filter, which Slider to fetch.
     */
    where?: SliderWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Sliders to fetch.
     */
    orderBy?: SliderOrderByWithRelationInput | SliderOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Sliders.
     */
    cursor?: SliderWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Sliders from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Sliders.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Sliders.
     */
    distinct?: SliderScalarFieldEnum | SliderScalarFieldEnum[];
  };

  /**
   * Slider findMany
   */
  export type SliderFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Slider
     */
    select?: SliderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Slider
     */
    omit?: SliderOmit<ExtArgs> | null;
    /**
     * Filter, which Sliders to fetch.
     */
    where?: SliderWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Sliders to fetch.
     */
    orderBy?: SliderOrderByWithRelationInput | SliderOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Sliders.
     */
    cursor?: SliderWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Sliders from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Sliders.
     */
    skip?: number;
    distinct?: SliderScalarFieldEnum | SliderScalarFieldEnum[];
  };

  /**
   * Slider create
   */
  export type SliderCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Slider
     */
    select?: SliderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Slider
     */
    omit?: SliderOmit<ExtArgs> | null;
    /**
     * The data needed to create a Slider.
     */
    data: XOR<SliderCreateInput, SliderUncheckedCreateInput>;
  };

  /**
   * Slider createMany
   */
  export type SliderCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Sliders.
     */
    data: SliderCreateManyInput | SliderCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Slider update
   */
  export type SliderUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Slider
     */
    select?: SliderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Slider
     */
    omit?: SliderOmit<ExtArgs> | null;
    /**
     * The data needed to update a Slider.
     */
    data: XOR<SliderUpdateInput, SliderUncheckedUpdateInput>;
    /**
     * Choose, which Slider to update.
     */
    where: SliderWhereUniqueInput;
  };

  /**
   * Slider updateMany
   */
  export type SliderUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Sliders.
     */
    data: XOR<SliderUpdateManyMutationInput, SliderUncheckedUpdateManyInput>;
    /**
     * Filter which Sliders to update
     */
    where?: SliderWhereInput;
    /**
     * Limit how many Sliders to update.
     */
    limit?: number;
  };

  /**
   * Slider upsert
   */
  export type SliderUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Slider
     */
    select?: SliderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Slider
     */
    omit?: SliderOmit<ExtArgs> | null;
    /**
     * The filter to search for the Slider to update in case it exists.
     */
    where: SliderWhereUniqueInput;
    /**
     * In case the Slider found by the `where` argument doesn't exist, create a new Slider with this data.
     */
    create: XOR<SliderCreateInput, SliderUncheckedCreateInput>;
    /**
     * In case the Slider was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SliderUpdateInput, SliderUncheckedUpdateInput>;
  };

  /**
   * Slider delete
   */
  export type SliderDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Slider
     */
    select?: SliderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Slider
     */
    omit?: SliderOmit<ExtArgs> | null;
    /**
     * Filter which Slider to delete.
     */
    where: SliderWhereUniqueInput;
  };

  /**
   * Slider deleteMany
   */
  export type SliderDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Sliders to delete
     */
    where?: SliderWhereInput;
    /**
     * Limit how many Sliders to delete.
     */
    limit?: number;
  };

  /**
   * Slider without action
   */
  export type SliderDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Slider
     */
    select?: SliderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Slider
     */
    omit?: SliderOmit<ExtArgs> | null;
  };

  /**
   * Model Resena
   */

  export type AggregateResena = {
    _count: ResenaCountAggregateOutputType | null;
    _avg: ResenaAvgAggregateOutputType | null;
    _sum: ResenaSumAggregateOutputType | null;
    _min: ResenaMinAggregateOutputType | null;
    _max: ResenaMaxAggregateOutputType | null;
  };

  export type ResenaAvgAggregateOutputType = {
    id: number | null;
    cursoId: number | null;
    productoId: number | null;
    usuarioId: number | null;
    puntaje: number | null;
  };

  export type ResenaSumAggregateOutputType = {
    id: number | null;
    cursoId: number | null;
    productoId: number | null;
    usuarioId: number | null;
    puntaje: number | null;
  };

  export type ResenaMinAggregateOutputType = {
    id: number | null;
    cursoId: number | null;
    productoId: number | null;
    usuarioId: number | null;
    puntaje: number | null;
    comentario: string | null;
    creadoEn: Date | null;
  };

  export type ResenaMaxAggregateOutputType = {
    id: number | null;
    cursoId: number | null;
    productoId: number | null;
    usuarioId: number | null;
    puntaje: number | null;
    comentario: string | null;
    creadoEn: Date | null;
  };

  export type ResenaCountAggregateOutputType = {
    id: number;
    cursoId: number;
    productoId: number;
    usuarioId: number;
    puntaje: number;
    comentario: number;
    creadoEn: number;
    _all: number;
  };

  export type ResenaAvgAggregateInputType = {
    id?: true;
    cursoId?: true;
    productoId?: true;
    usuarioId?: true;
    puntaje?: true;
  };

  export type ResenaSumAggregateInputType = {
    id?: true;
    cursoId?: true;
    productoId?: true;
    usuarioId?: true;
    puntaje?: true;
  };

  export type ResenaMinAggregateInputType = {
    id?: true;
    cursoId?: true;
    productoId?: true;
    usuarioId?: true;
    puntaje?: true;
    comentario?: true;
    creadoEn?: true;
  };

  export type ResenaMaxAggregateInputType = {
    id?: true;
    cursoId?: true;
    productoId?: true;
    usuarioId?: true;
    puntaje?: true;
    comentario?: true;
    creadoEn?: true;
  };

  export type ResenaCountAggregateInputType = {
    id?: true;
    cursoId?: true;
    productoId?: true;
    usuarioId?: true;
    puntaje?: true;
    comentario?: true;
    creadoEn?: true;
    _all?: true;
  };

  export type ResenaAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Resena to aggregate.
     */
    where?: ResenaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Resenas to fetch.
     */
    orderBy?: ResenaOrderByWithRelationInput | ResenaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ResenaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Resenas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Resenas.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Resenas
     **/
    _count?: true | ResenaCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ResenaAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ResenaSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ResenaMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ResenaMaxAggregateInputType;
  };

  export type GetResenaAggregateType<T extends ResenaAggregateArgs> = {
    [P in keyof T & keyof AggregateResena]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResena[P]>
      : GetScalarType<T[P], AggregateResena[P]>;
  };

  export type ResenaGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ResenaWhereInput;
    orderBy?:
      | ResenaOrderByWithAggregationInput
      | ResenaOrderByWithAggregationInput[];
    by: ResenaScalarFieldEnum[] | ResenaScalarFieldEnum;
    having?: ResenaScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ResenaCountAggregateInputType | true;
    _avg?: ResenaAvgAggregateInputType;
    _sum?: ResenaSumAggregateInputType;
    _min?: ResenaMinAggregateInputType;
    _max?: ResenaMaxAggregateInputType;
  };

  export type ResenaGroupByOutputType = {
    id: number;
    cursoId: number | null;
    productoId: number | null;
    usuarioId: number;
    puntaje: number;
    comentario: string | null;
    creadoEn: Date;
    _count: ResenaCountAggregateOutputType | null;
    _avg: ResenaAvgAggregateOutputType | null;
    _sum: ResenaSumAggregateOutputType | null;
    _min: ResenaMinAggregateOutputType | null;
    _max: ResenaMaxAggregateOutputType | null;
  };

  type GetResenaGroupByPayload<T extends ResenaGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ResenaGroupByOutputType, T['by']> & {
          [P in keyof T & keyof ResenaGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResenaGroupByOutputType[P]>
            : GetScalarType<T[P], ResenaGroupByOutputType[P]>;
        }
      >
    >;

  export type ResenaSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      cursoId?: boolean;
      productoId?: boolean;
      usuarioId?: boolean;
      puntaje?: boolean;
      comentario?: boolean;
      creadoEn?: boolean;
      curso?: boolean | Resena$cursoArgs<ExtArgs>;
      producto?: boolean | Resena$productoArgs<ExtArgs>;
      usuario?: boolean | UsuarioDefaultArgs<ExtArgs>;
      respuestas?: boolean | Resena$respuestasArgs<ExtArgs>;
      likes?: boolean | Resena$likesArgs<ExtArgs>;
      _count?: boolean | ResenaCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['resena']
  >;

  export type ResenaSelectScalar = {
    id?: boolean;
    cursoId?: boolean;
    productoId?: boolean;
    usuarioId?: boolean;
    puntaje?: boolean;
    comentario?: boolean;
    creadoEn?: boolean;
  };

  export type ResenaOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'cursoId'
    | 'productoId'
    | 'usuarioId'
    | 'puntaje'
    | 'comentario'
    | 'creadoEn',
    ExtArgs['result']['resena']
  >;
  export type ResenaInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    curso?: boolean | Resena$cursoArgs<ExtArgs>;
    producto?: boolean | Resena$productoArgs<ExtArgs>;
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>;
    respuestas?: boolean | Resena$respuestasArgs<ExtArgs>;
    likes?: boolean | Resena$likesArgs<ExtArgs>;
    _count?: boolean | ResenaCountOutputTypeDefaultArgs<ExtArgs>;
  };

  export type $ResenaPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Resena';
    objects: {
      curso: Prisma.$CursoPayload<ExtArgs> | null;
      producto: Prisma.$ProductoPayload<ExtArgs> | null;
      usuario: Prisma.$UsuarioPayload<ExtArgs>;
      respuestas: Prisma.$ResenaRespuestaPayload<ExtArgs>[];
      likes: Prisma.$ResenaLikePayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        cursoId: number | null;
        productoId: number | null;
        usuarioId: number;
        puntaje: number;
        comentario: string | null;
        creadoEn: Date;
      },
      ExtArgs['result']['resena']
    >;
    composites: {};
  };

  type ResenaGetPayload<
    S extends boolean | null | undefined | ResenaDefaultArgs,
  > = $Result.GetResult<Prisma.$ResenaPayload, S>;

  type ResenaCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<ResenaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: ResenaCountAggregateInputType | true;
  };

  export interface ResenaDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Resena'];
      meta: { name: 'Resena' };
    };
    /**
     * Find zero or one Resena that matches the filter.
     * @param {ResenaFindUniqueArgs} args - Arguments to find a Resena
     * @example
     * // Get one Resena
     * const resena = await prisma.resena.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResenaFindUniqueArgs>(
      args: SelectSubset<T, ResenaFindUniqueArgs<ExtArgs>>,
    ): Prisma__ResenaClient<
      $Result.GetResult<
        Prisma.$ResenaPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Resena that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ResenaFindUniqueOrThrowArgs} args - Arguments to find a Resena
     * @example
     * // Get one Resena
     * const resena = await prisma.resena.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResenaFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ResenaFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__ResenaClient<
      $Result.GetResult<
        Prisma.$ResenaPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Resena that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResenaFindFirstArgs} args - Arguments to find a Resena
     * @example
     * // Get one Resena
     * const resena = await prisma.resena.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResenaFindFirstArgs>(
      args?: SelectSubset<T, ResenaFindFirstArgs<ExtArgs>>,
    ): Prisma__ResenaClient<
      $Result.GetResult<
        Prisma.$ResenaPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Resena that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResenaFindFirstOrThrowArgs} args - Arguments to find a Resena
     * @example
     * // Get one Resena
     * const resena = await prisma.resena.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResenaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ResenaFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__ResenaClient<
      $Result.GetResult<
        Prisma.$ResenaPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Resenas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResenaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Resenas
     * const resenas = await prisma.resena.findMany()
     *
     * // Get first 10 Resenas
     * const resenas = await prisma.resena.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const resenaWithIdOnly = await prisma.resena.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ResenaFindManyArgs>(
      args?: SelectSubset<T, ResenaFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ResenaPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Resena.
     * @param {ResenaCreateArgs} args - Arguments to create a Resena.
     * @example
     * // Create one Resena
     * const Resena = await prisma.resena.create({
     *   data: {
     *     // ... data to create a Resena
     *   }
     * })
     *
     */
    create<T extends ResenaCreateArgs>(
      args: SelectSubset<T, ResenaCreateArgs<ExtArgs>>,
    ): Prisma__ResenaClient<
      $Result.GetResult<
        Prisma.$ResenaPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Resenas.
     * @param {ResenaCreateManyArgs} args - Arguments to create many Resenas.
     * @example
     * // Create many Resenas
     * const resena = await prisma.resena.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ResenaCreateManyArgs>(
      args?: SelectSubset<T, ResenaCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Resena.
     * @param {ResenaDeleteArgs} args - Arguments to delete one Resena.
     * @example
     * // Delete one Resena
     * const Resena = await prisma.resena.delete({
     *   where: {
     *     // ... filter to delete one Resena
     *   }
     * })
     *
     */
    delete<T extends ResenaDeleteArgs>(
      args: SelectSubset<T, ResenaDeleteArgs<ExtArgs>>,
    ): Prisma__ResenaClient<
      $Result.GetResult<
        Prisma.$ResenaPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Resena.
     * @param {ResenaUpdateArgs} args - Arguments to update one Resena.
     * @example
     * // Update one Resena
     * const resena = await prisma.resena.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ResenaUpdateArgs>(
      args: SelectSubset<T, ResenaUpdateArgs<ExtArgs>>,
    ): Prisma__ResenaClient<
      $Result.GetResult<
        Prisma.$ResenaPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Resenas.
     * @param {ResenaDeleteManyArgs} args - Arguments to filter Resenas to delete.
     * @example
     * // Delete a few Resenas
     * const { count } = await prisma.resena.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ResenaDeleteManyArgs>(
      args?: SelectSubset<T, ResenaDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Resenas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResenaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Resenas
     * const resena = await prisma.resena.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ResenaUpdateManyArgs>(
      args: SelectSubset<T, ResenaUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Resena.
     * @param {ResenaUpsertArgs} args - Arguments to update or create a Resena.
     * @example
     * // Update or create a Resena
     * const resena = await prisma.resena.upsert({
     *   create: {
     *     // ... data to create a Resena
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Resena we want to update
     *   }
     * })
     */
    upsert<T extends ResenaUpsertArgs>(
      args: SelectSubset<T, ResenaUpsertArgs<ExtArgs>>,
    ): Prisma__ResenaClient<
      $Result.GetResult<
        Prisma.$ResenaPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Resenas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResenaCountArgs} args - Arguments to filter Resenas to count.
     * @example
     * // Count the number of Resenas
     * const count = await prisma.resena.count({
     *   where: {
     *     // ... the filter for the Resenas we want to count
     *   }
     * })
     **/
    count<T extends ResenaCountArgs>(
      args?: Subset<T, ResenaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResenaCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Resena.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResenaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ResenaAggregateArgs>(
      args: Subset<T, ResenaAggregateArgs>,
    ): Prisma.PrismaPromise<GetResenaAggregateType<T>>;

    /**
     * Group by Resena.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResenaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ResenaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResenaGroupByArgs['orderBy'] }
        : { orderBy?: ResenaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ResenaGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetResenaGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Resena model
     */
    readonly fields: ResenaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Resena.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResenaClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    curso<T extends Resena$cursoArgs<ExtArgs> = {}>(
      args?: Subset<T, Resena$cursoArgs<ExtArgs>>,
    ): Prisma__CursoClient<
      $Result.GetResult<
        Prisma.$CursoPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    producto<T extends Resena$productoArgs<ExtArgs> = {}>(
      args?: Subset<T, Resena$productoArgs<ExtArgs>>,
    ): Prisma__ProductoClient<
      $Result.GetResult<
        Prisma.$ProductoPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>,
    ): Prisma__UsuarioClient<
      | $Result.GetResult<
          Prisma.$UsuarioPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    respuestas<T extends Resena$respuestasArgs<ExtArgs> = {}>(
      args?: Subset<T, Resena$respuestasArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$ResenaRespuestaPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    likes<T extends Resena$likesArgs<ExtArgs> = {}>(
      args?: Subset<T, Resena$likesArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$ResenaLikePayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Resena model
   */
  interface ResenaFieldRefs {
    readonly id: FieldRef<'Resena', 'Int'>;
    readonly cursoId: FieldRef<'Resena', 'Int'>;
    readonly productoId: FieldRef<'Resena', 'Int'>;
    readonly usuarioId: FieldRef<'Resena', 'Int'>;
    readonly puntaje: FieldRef<'Resena', 'Int'>;
    readonly comentario: FieldRef<'Resena', 'String'>;
    readonly creadoEn: FieldRef<'Resena', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Resena findUnique
   */
  export type ResenaFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Resena
     */
    select?: ResenaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Resena
     */
    omit?: ResenaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaInclude<ExtArgs> | null;
    /**
     * Filter, which Resena to fetch.
     */
    where: ResenaWhereUniqueInput;
  };

  /**
   * Resena findUniqueOrThrow
   */
  export type ResenaFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Resena
     */
    select?: ResenaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Resena
     */
    omit?: ResenaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaInclude<ExtArgs> | null;
    /**
     * Filter, which Resena to fetch.
     */
    where: ResenaWhereUniqueInput;
  };

  /**
   * Resena findFirst
   */
  export type ResenaFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Resena
     */
    select?: ResenaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Resena
     */
    omit?: ResenaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaInclude<ExtArgs> | null;
    /**
     * Filter, which Resena to fetch.
     */
    where?: ResenaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Resenas to fetch.
     */
    orderBy?: ResenaOrderByWithRelationInput | ResenaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Resenas.
     */
    cursor?: ResenaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Resenas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Resenas.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Resenas.
     */
    distinct?: ResenaScalarFieldEnum | ResenaScalarFieldEnum[];
  };

  /**
   * Resena findFirstOrThrow
   */
  export type ResenaFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Resena
     */
    select?: ResenaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Resena
     */
    omit?: ResenaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaInclude<ExtArgs> | null;
    /**
     * Filter, which Resena to fetch.
     */
    where?: ResenaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Resenas to fetch.
     */
    orderBy?: ResenaOrderByWithRelationInput | ResenaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Resenas.
     */
    cursor?: ResenaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Resenas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Resenas.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Resenas.
     */
    distinct?: ResenaScalarFieldEnum | ResenaScalarFieldEnum[];
  };

  /**
   * Resena findMany
   */
  export type ResenaFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Resena
     */
    select?: ResenaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Resena
     */
    omit?: ResenaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaInclude<ExtArgs> | null;
    /**
     * Filter, which Resenas to fetch.
     */
    where?: ResenaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Resenas to fetch.
     */
    orderBy?: ResenaOrderByWithRelationInput | ResenaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Resenas.
     */
    cursor?: ResenaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Resenas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Resenas.
     */
    skip?: number;
    distinct?: ResenaScalarFieldEnum | ResenaScalarFieldEnum[];
  };

  /**
   * Resena create
   */
  export type ResenaCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Resena
     */
    select?: ResenaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Resena
     */
    omit?: ResenaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaInclude<ExtArgs> | null;
    /**
     * The data needed to create a Resena.
     */
    data: XOR<ResenaCreateInput, ResenaUncheckedCreateInput>;
  };

  /**
   * Resena createMany
   */
  export type ResenaCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Resenas.
     */
    data: ResenaCreateManyInput | ResenaCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Resena update
   */
  export type ResenaUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Resena
     */
    select?: ResenaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Resena
     */
    omit?: ResenaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaInclude<ExtArgs> | null;
    /**
     * The data needed to update a Resena.
     */
    data: XOR<ResenaUpdateInput, ResenaUncheckedUpdateInput>;
    /**
     * Choose, which Resena to update.
     */
    where: ResenaWhereUniqueInput;
  };

  /**
   * Resena updateMany
   */
  export type ResenaUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Resenas.
     */
    data: XOR<ResenaUpdateManyMutationInput, ResenaUncheckedUpdateManyInput>;
    /**
     * Filter which Resenas to update
     */
    where?: ResenaWhereInput;
    /**
     * Limit how many Resenas to update.
     */
    limit?: number;
  };

  /**
   * Resena upsert
   */
  export type ResenaUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Resena
     */
    select?: ResenaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Resena
     */
    omit?: ResenaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaInclude<ExtArgs> | null;
    /**
     * The filter to search for the Resena to update in case it exists.
     */
    where: ResenaWhereUniqueInput;
    /**
     * In case the Resena found by the `where` argument doesn't exist, create a new Resena with this data.
     */
    create: XOR<ResenaCreateInput, ResenaUncheckedCreateInput>;
    /**
     * In case the Resena was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResenaUpdateInput, ResenaUncheckedUpdateInput>;
  };

  /**
   * Resena delete
   */
  export type ResenaDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Resena
     */
    select?: ResenaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Resena
     */
    omit?: ResenaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaInclude<ExtArgs> | null;
    /**
     * Filter which Resena to delete.
     */
    where: ResenaWhereUniqueInput;
  };

  /**
   * Resena deleteMany
   */
  export type ResenaDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Resenas to delete
     */
    where?: ResenaWhereInput;
    /**
     * Limit how many Resenas to delete.
     */
    limit?: number;
  };

  /**
   * Resena.curso
   */
  export type Resena$cursoArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Curso
     */
    select?: CursoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Curso
     */
    omit?: CursoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoInclude<ExtArgs> | null;
    where?: CursoWhereInput;
  };

  /**
   * Resena.producto
   */
  export type Resena$productoArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Producto
     */
    omit?: ProductoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoInclude<ExtArgs> | null;
    where?: ProductoWhereInput;
  };

  /**
   * Resena.respuestas
   */
  export type Resena$respuestasArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ResenaRespuesta
     */
    select?: ResenaRespuestaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ResenaRespuesta
     */
    omit?: ResenaRespuestaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaRespuestaInclude<ExtArgs> | null;
    where?: ResenaRespuestaWhereInput;
    orderBy?:
      | ResenaRespuestaOrderByWithRelationInput
      | ResenaRespuestaOrderByWithRelationInput[];
    cursor?: ResenaRespuestaWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | ResenaRespuestaScalarFieldEnum
      | ResenaRespuestaScalarFieldEnum[];
  };

  /**
   * Resena.likes
   */
  export type Resena$likesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ResenaLike
     */
    select?: ResenaLikeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ResenaLike
     */
    omit?: ResenaLikeOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaLikeInclude<ExtArgs> | null;
    where?: ResenaLikeWhereInput;
    orderBy?:
      | ResenaLikeOrderByWithRelationInput
      | ResenaLikeOrderByWithRelationInput[];
    cursor?: ResenaLikeWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ResenaLikeScalarFieldEnum | ResenaLikeScalarFieldEnum[];
  };

  /**
   * Resena without action
   */
  export type ResenaDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Resena
     */
    select?: ResenaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Resena
     */
    omit?: ResenaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaInclude<ExtArgs> | null;
  };

  /**
   * Model ResenaLike
   */

  export type AggregateResenaLike = {
    _count: ResenaLikeCountAggregateOutputType | null;
    _avg: ResenaLikeAvgAggregateOutputType | null;
    _sum: ResenaLikeSumAggregateOutputType | null;
    _min: ResenaLikeMinAggregateOutputType | null;
    _max: ResenaLikeMaxAggregateOutputType | null;
  };

  export type ResenaLikeAvgAggregateOutputType = {
    id: number | null;
    resenaId: number | null;
    usuarioId: number | null;
  };

  export type ResenaLikeSumAggregateOutputType = {
    id: number | null;
    resenaId: number | null;
    usuarioId: number | null;
  };

  export type ResenaLikeMinAggregateOutputType = {
    id: number | null;
    resenaId: number | null;
    usuarioId: number | null;
    tipo: $Enums.TipoLike | null;
    creadoEn: Date | null;
  };

  export type ResenaLikeMaxAggregateOutputType = {
    id: number | null;
    resenaId: number | null;
    usuarioId: number | null;
    tipo: $Enums.TipoLike | null;
    creadoEn: Date | null;
  };

  export type ResenaLikeCountAggregateOutputType = {
    id: number;
    resenaId: number;
    usuarioId: number;
    tipo: number;
    creadoEn: number;
    _all: number;
  };

  export type ResenaLikeAvgAggregateInputType = {
    id?: true;
    resenaId?: true;
    usuarioId?: true;
  };

  export type ResenaLikeSumAggregateInputType = {
    id?: true;
    resenaId?: true;
    usuarioId?: true;
  };

  export type ResenaLikeMinAggregateInputType = {
    id?: true;
    resenaId?: true;
    usuarioId?: true;
    tipo?: true;
    creadoEn?: true;
  };

  export type ResenaLikeMaxAggregateInputType = {
    id?: true;
    resenaId?: true;
    usuarioId?: true;
    tipo?: true;
    creadoEn?: true;
  };

  export type ResenaLikeCountAggregateInputType = {
    id?: true;
    resenaId?: true;
    usuarioId?: true;
    tipo?: true;
    creadoEn?: true;
    _all?: true;
  };

  export type ResenaLikeAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ResenaLike to aggregate.
     */
    where?: ResenaLikeWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ResenaLikes to fetch.
     */
    orderBy?:
      | ResenaLikeOrderByWithRelationInput
      | ResenaLikeOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ResenaLikeWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ResenaLikes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ResenaLikes.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned ResenaLikes
     **/
    _count?: true | ResenaLikeCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ResenaLikeAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ResenaLikeSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ResenaLikeMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ResenaLikeMaxAggregateInputType;
  };

  export type GetResenaLikeAggregateType<T extends ResenaLikeAggregateArgs> = {
    [P in keyof T & keyof AggregateResenaLike]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResenaLike[P]>
      : GetScalarType<T[P], AggregateResenaLike[P]>;
  };

  export type ResenaLikeGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ResenaLikeWhereInput;
    orderBy?:
      | ResenaLikeOrderByWithAggregationInput
      | ResenaLikeOrderByWithAggregationInput[];
    by: ResenaLikeScalarFieldEnum[] | ResenaLikeScalarFieldEnum;
    having?: ResenaLikeScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ResenaLikeCountAggregateInputType | true;
    _avg?: ResenaLikeAvgAggregateInputType;
    _sum?: ResenaLikeSumAggregateInputType;
    _min?: ResenaLikeMinAggregateInputType;
    _max?: ResenaLikeMaxAggregateInputType;
  };

  export type ResenaLikeGroupByOutputType = {
    id: number;
    resenaId: number;
    usuarioId: number;
    tipo: $Enums.TipoLike;
    creadoEn: Date;
    _count: ResenaLikeCountAggregateOutputType | null;
    _avg: ResenaLikeAvgAggregateOutputType | null;
    _sum: ResenaLikeSumAggregateOutputType | null;
    _min: ResenaLikeMinAggregateOutputType | null;
    _max: ResenaLikeMaxAggregateOutputType | null;
  };

  type GetResenaLikeGroupByPayload<T extends ResenaLikeGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ResenaLikeGroupByOutputType, T['by']> & {
          [P in keyof T & keyof ResenaLikeGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResenaLikeGroupByOutputType[P]>
            : GetScalarType<T[P], ResenaLikeGroupByOutputType[P]>;
        }
      >
    >;

  export type ResenaLikeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      resenaId?: boolean;
      usuarioId?: boolean;
      tipo?: boolean;
      creadoEn?: boolean;
      resena?: boolean | ResenaDefaultArgs<ExtArgs>;
      usuario?: boolean | UsuarioDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['resenaLike']
  >;

  export type ResenaLikeSelectScalar = {
    id?: boolean;
    resenaId?: boolean;
    usuarioId?: boolean;
    tipo?: boolean;
    creadoEn?: boolean;
  };

  export type ResenaLikeOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    'id' | 'resenaId' | 'usuarioId' | 'tipo' | 'creadoEn',
    ExtArgs['result']['resenaLike']
  >;
  export type ResenaLikeInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    resena?: boolean | ResenaDefaultArgs<ExtArgs>;
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>;
  };

  export type $ResenaLikePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'ResenaLike';
    objects: {
      resena: Prisma.$ResenaPayload<ExtArgs>;
      usuario: Prisma.$UsuarioPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        resenaId: number;
        usuarioId: number;
        tipo: $Enums.TipoLike;
        creadoEn: Date;
      },
      ExtArgs['result']['resenaLike']
    >;
    composites: {};
  };

  type ResenaLikeGetPayload<
    S extends boolean | null | undefined | ResenaLikeDefaultArgs,
  > = $Result.GetResult<Prisma.$ResenaLikePayload, S>;

  type ResenaLikeCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    ResenaLikeFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: ResenaLikeCountAggregateInputType | true;
  };

  export interface ResenaLikeDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['ResenaLike'];
      meta: { name: 'ResenaLike' };
    };
    /**
     * Find zero or one ResenaLike that matches the filter.
     * @param {ResenaLikeFindUniqueArgs} args - Arguments to find a ResenaLike
     * @example
     * // Get one ResenaLike
     * const resenaLike = await prisma.resenaLike.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResenaLikeFindUniqueArgs>(
      args: SelectSubset<T, ResenaLikeFindUniqueArgs<ExtArgs>>,
    ): Prisma__ResenaLikeClient<
      $Result.GetResult<
        Prisma.$ResenaLikePayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one ResenaLike that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ResenaLikeFindUniqueOrThrowArgs} args - Arguments to find a ResenaLike
     * @example
     * // Get one ResenaLike
     * const resenaLike = await prisma.resenaLike.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResenaLikeFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ResenaLikeFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__ResenaLikeClient<
      $Result.GetResult<
        Prisma.$ResenaLikePayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ResenaLike that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResenaLikeFindFirstArgs} args - Arguments to find a ResenaLike
     * @example
     * // Get one ResenaLike
     * const resenaLike = await prisma.resenaLike.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResenaLikeFindFirstArgs>(
      args?: SelectSubset<T, ResenaLikeFindFirstArgs<ExtArgs>>,
    ): Prisma__ResenaLikeClient<
      $Result.GetResult<
        Prisma.$ResenaLikePayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ResenaLike that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResenaLikeFindFirstOrThrowArgs} args - Arguments to find a ResenaLike
     * @example
     * // Get one ResenaLike
     * const resenaLike = await prisma.resenaLike.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResenaLikeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ResenaLikeFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__ResenaLikeClient<
      $Result.GetResult<
        Prisma.$ResenaLikePayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more ResenaLikes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResenaLikeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ResenaLikes
     * const resenaLikes = await prisma.resenaLike.findMany()
     *
     * // Get first 10 ResenaLikes
     * const resenaLikes = await prisma.resenaLike.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const resenaLikeWithIdOnly = await prisma.resenaLike.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ResenaLikeFindManyArgs>(
      args?: SelectSubset<T, ResenaLikeFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ResenaLikePayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a ResenaLike.
     * @param {ResenaLikeCreateArgs} args - Arguments to create a ResenaLike.
     * @example
     * // Create one ResenaLike
     * const ResenaLike = await prisma.resenaLike.create({
     *   data: {
     *     // ... data to create a ResenaLike
     *   }
     * })
     *
     */
    create<T extends ResenaLikeCreateArgs>(
      args: SelectSubset<T, ResenaLikeCreateArgs<ExtArgs>>,
    ): Prisma__ResenaLikeClient<
      $Result.GetResult<
        Prisma.$ResenaLikePayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many ResenaLikes.
     * @param {ResenaLikeCreateManyArgs} args - Arguments to create many ResenaLikes.
     * @example
     * // Create many ResenaLikes
     * const resenaLike = await prisma.resenaLike.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ResenaLikeCreateManyArgs>(
      args?: SelectSubset<T, ResenaLikeCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a ResenaLike.
     * @param {ResenaLikeDeleteArgs} args - Arguments to delete one ResenaLike.
     * @example
     * // Delete one ResenaLike
     * const ResenaLike = await prisma.resenaLike.delete({
     *   where: {
     *     // ... filter to delete one ResenaLike
     *   }
     * })
     *
     */
    delete<T extends ResenaLikeDeleteArgs>(
      args: SelectSubset<T, ResenaLikeDeleteArgs<ExtArgs>>,
    ): Prisma__ResenaLikeClient<
      $Result.GetResult<
        Prisma.$ResenaLikePayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one ResenaLike.
     * @param {ResenaLikeUpdateArgs} args - Arguments to update one ResenaLike.
     * @example
     * // Update one ResenaLike
     * const resenaLike = await prisma.resenaLike.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ResenaLikeUpdateArgs>(
      args: SelectSubset<T, ResenaLikeUpdateArgs<ExtArgs>>,
    ): Prisma__ResenaLikeClient<
      $Result.GetResult<
        Prisma.$ResenaLikePayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more ResenaLikes.
     * @param {ResenaLikeDeleteManyArgs} args - Arguments to filter ResenaLikes to delete.
     * @example
     * // Delete a few ResenaLikes
     * const { count } = await prisma.resenaLike.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ResenaLikeDeleteManyArgs>(
      args?: SelectSubset<T, ResenaLikeDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ResenaLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResenaLikeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ResenaLikes
     * const resenaLike = await prisma.resenaLike.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ResenaLikeUpdateManyArgs>(
      args: SelectSubset<T, ResenaLikeUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one ResenaLike.
     * @param {ResenaLikeUpsertArgs} args - Arguments to update or create a ResenaLike.
     * @example
     * // Update or create a ResenaLike
     * const resenaLike = await prisma.resenaLike.upsert({
     *   create: {
     *     // ... data to create a ResenaLike
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ResenaLike we want to update
     *   }
     * })
     */
    upsert<T extends ResenaLikeUpsertArgs>(
      args: SelectSubset<T, ResenaLikeUpsertArgs<ExtArgs>>,
    ): Prisma__ResenaLikeClient<
      $Result.GetResult<
        Prisma.$ResenaLikePayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of ResenaLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResenaLikeCountArgs} args - Arguments to filter ResenaLikes to count.
     * @example
     * // Count the number of ResenaLikes
     * const count = await prisma.resenaLike.count({
     *   where: {
     *     // ... the filter for the ResenaLikes we want to count
     *   }
     * })
     **/
    count<T extends ResenaLikeCountArgs>(
      args?: Subset<T, ResenaLikeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResenaLikeCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a ResenaLike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResenaLikeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ResenaLikeAggregateArgs>(
      args: Subset<T, ResenaLikeAggregateArgs>,
    ): Prisma.PrismaPromise<GetResenaLikeAggregateType<T>>;

    /**
     * Group by ResenaLike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResenaLikeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ResenaLikeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResenaLikeGroupByArgs['orderBy'] }
        : { orderBy?: ResenaLikeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ResenaLikeGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetResenaLikeGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the ResenaLike model
     */
    readonly fields: ResenaLikeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ResenaLike.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResenaLikeClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    resena<T extends ResenaDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, ResenaDefaultArgs<ExtArgs>>,
    ): Prisma__ResenaClient<
      | $Result.GetResult<
          Prisma.$ResenaPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>,
    ): Prisma__UsuarioClient<
      | $Result.GetResult<
          Prisma.$UsuarioPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the ResenaLike model
   */
  interface ResenaLikeFieldRefs {
    readonly id: FieldRef<'ResenaLike', 'Int'>;
    readonly resenaId: FieldRef<'ResenaLike', 'Int'>;
    readonly usuarioId: FieldRef<'ResenaLike', 'Int'>;
    readonly tipo: FieldRef<'ResenaLike', 'TipoLike'>;
    readonly creadoEn: FieldRef<'ResenaLike', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * ResenaLike findUnique
   */
  export type ResenaLikeFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ResenaLike
     */
    select?: ResenaLikeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ResenaLike
     */
    omit?: ResenaLikeOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaLikeInclude<ExtArgs> | null;
    /**
     * Filter, which ResenaLike to fetch.
     */
    where: ResenaLikeWhereUniqueInput;
  };

  /**
   * ResenaLike findUniqueOrThrow
   */
  export type ResenaLikeFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ResenaLike
     */
    select?: ResenaLikeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ResenaLike
     */
    omit?: ResenaLikeOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaLikeInclude<ExtArgs> | null;
    /**
     * Filter, which ResenaLike to fetch.
     */
    where: ResenaLikeWhereUniqueInput;
  };

  /**
   * ResenaLike findFirst
   */
  export type ResenaLikeFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ResenaLike
     */
    select?: ResenaLikeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ResenaLike
     */
    omit?: ResenaLikeOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaLikeInclude<ExtArgs> | null;
    /**
     * Filter, which ResenaLike to fetch.
     */
    where?: ResenaLikeWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ResenaLikes to fetch.
     */
    orderBy?:
      | ResenaLikeOrderByWithRelationInput
      | ResenaLikeOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ResenaLikes.
     */
    cursor?: ResenaLikeWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ResenaLikes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ResenaLikes.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ResenaLikes.
     */
    distinct?: ResenaLikeScalarFieldEnum | ResenaLikeScalarFieldEnum[];
  };

  /**
   * ResenaLike findFirstOrThrow
   */
  export type ResenaLikeFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ResenaLike
     */
    select?: ResenaLikeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ResenaLike
     */
    omit?: ResenaLikeOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaLikeInclude<ExtArgs> | null;
    /**
     * Filter, which ResenaLike to fetch.
     */
    where?: ResenaLikeWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ResenaLikes to fetch.
     */
    orderBy?:
      | ResenaLikeOrderByWithRelationInput
      | ResenaLikeOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ResenaLikes.
     */
    cursor?: ResenaLikeWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ResenaLikes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ResenaLikes.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ResenaLikes.
     */
    distinct?: ResenaLikeScalarFieldEnum | ResenaLikeScalarFieldEnum[];
  };

  /**
   * ResenaLike findMany
   */
  export type ResenaLikeFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ResenaLike
     */
    select?: ResenaLikeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ResenaLike
     */
    omit?: ResenaLikeOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaLikeInclude<ExtArgs> | null;
    /**
     * Filter, which ResenaLikes to fetch.
     */
    where?: ResenaLikeWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ResenaLikes to fetch.
     */
    orderBy?:
      | ResenaLikeOrderByWithRelationInput
      | ResenaLikeOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing ResenaLikes.
     */
    cursor?: ResenaLikeWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ResenaLikes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ResenaLikes.
     */
    skip?: number;
    distinct?: ResenaLikeScalarFieldEnum | ResenaLikeScalarFieldEnum[];
  };

  /**
   * ResenaLike create
   */
  export type ResenaLikeCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ResenaLike
     */
    select?: ResenaLikeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ResenaLike
     */
    omit?: ResenaLikeOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaLikeInclude<ExtArgs> | null;
    /**
     * The data needed to create a ResenaLike.
     */
    data: XOR<ResenaLikeCreateInput, ResenaLikeUncheckedCreateInput>;
  };

  /**
   * ResenaLike createMany
   */
  export type ResenaLikeCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many ResenaLikes.
     */
    data: ResenaLikeCreateManyInput | ResenaLikeCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * ResenaLike update
   */
  export type ResenaLikeUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ResenaLike
     */
    select?: ResenaLikeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ResenaLike
     */
    omit?: ResenaLikeOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaLikeInclude<ExtArgs> | null;
    /**
     * The data needed to update a ResenaLike.
     */
    data: XOR<ResenaLikeUpdateInput, ResenaLikeUncheckedUpdateInput>;
    /**
     * Choose, which ResenaLike to update.
     */
    where: ResenaLikeWhereUniqueInput;
  };

  /**
   * ResenaLike updateMany
   */
  export type ResenaLikeUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update ResenaLikes.
     */
    data: XOR<
      ResenaLikeUpdateManyMutationInput,
      ResenaLikeUncheckedUpdateManyInput
    >;
    /**
     * Filter which ResenaLikes to update
     */
    where?: ResenaLikeWhereInput;
    /**
     * Limit how many ResenaLikes to update.
     */
    limit?: number;
  };

  /**
   * ResenaLike upsert
   */
  export type ResenaLikeUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ResenaLike
     */
    select?: ResenaLikeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ResenaLike
     */
    omit?: ResenaLikeOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaLikeInclude<ExtArgs> | null;
    /**
     * The filter to search for the ResenaLike to update in case it exists.
     */
    where: ResenaLikeWhereUniqueInput;
    /**
     * In case the ResenaLike found by the `where` argument doesn't exist, create a new ResenaLike with this data.
     */
    create: XOR<ResenaLikeCreateInput, ResenaLikeUncheckedCreateInput>;
    /**
     * In case the ResenaLike was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResenaLikeUpdateInput, ResenaLikeUncheckedUpdateInput>;
  };

  /**
   * ResenaLike delete
   */
  export type ResenaLikeDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ResenaLike
     */
    select?: ResenaLikeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ResenaLike
     */
    omit?: ResenaLikeOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaLikeInclude<ExtArgs> | null;
    /**
     * Filter which ResenaLike to delete.
     */
    where: ResenaLikeWhereUniqueInput;
  };

  /**
   * ResenaLike deleteMany
   */
  export type ResenaLikeDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ResenaLikes to delete
     */
    where?: ResenaLikeWhereInput;
    /**
     * Limit how many ResenaLikes to delete.
     */
    limit?: number;
  };

  /**
   * ResenaLike without action
   */
  export type ResenaLikeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ResenaLike
     */
    select?: ResenaLikeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ResenaLike
     */
    omit?: ResenaLikeOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaLikeInclude<ExtArgs> | null;
  };

  /**
   * Model ResenaRespuesta
   */

  export type AggregateResenaRespuesta = {
    _count: ResenaRespuestaCountAggregateOutputType | null;
    _avg: ResenaRespuestaAvgAggregateOutputType | null;
    _sum: ResenaRespuestaSumAggregateOutputType | null;
    _min: ResenaRespuestaMinAggregateOutputType | null;
    _max: ResenaRespuestaMaxAggregateOutputType | null;
  };

  export type ResenaRespuestaAvgAggregateOutputType = {
    id: number | null;
    resenaId: number | null;
    usuarioId: number | null;
    parentId: number | null;
  };

  export type ResenaRespuestaSumAggregateOutputType = {
    id: number | null;
    resenaId: number | null;
    usuarioId: number | null;
    parentId: number | null;
  };

  export type ResenaRespuestaMinAggregateOutputType = {
    id: number | null;
    resenaId: number | null;
    usuarioId: number | null;
    parentId: number | null;
    contenido: string | null;
    eliminado: boolean | null;
    creadoEn: Date | null;
    actualizadoEn: Date | null;
  };

  export type ResenaRespuestaMaxAggregateOutputType = {
    id: number | null;
    resenaId: number | null;
    usuarioId: number | null;
    parentId: number | null;
    contenido: string | null;
    eliminado: boolean | null;
    creadoEn: Date | null;
    actualizadoEn: Date | null;
  };

  export type ResenaRespuestaCountAggregateOutputType = {
    id: number;
    resenaId: number;
    usuarioId: number;
    parentId: number;
    contenido: number;
    eliminado: number;
    creadoEn: number;
    actualizadoEn: number;
    _all: number;
  };

  export type ResenaRespuestaAvgAggregateInputType = {
    id?: true;
    resenaId?: true;
    usuarioId?: true;
    parentId?: true;
  };

  export type ResenaRespuestaSumAggregateInputType = {
    id?: true;
    resenaId?: true;
    usuarioId?: true;
    parentId?: true;
  };

  export type ResenaRespuestaMinAggregateInputType = {
    id?: true;
    resenaId?: true;
    usuarioId?: true;
    parentId?: true;
    contenido?: true;
    eliminado?: true;
    creadoEn?: true;
    actualizadoEn?: true;
  };

  export type ResenaRespuestaMaxAggregateInputType = {
    id?: true;
    resenaId?: true;
    usuarioId?: true;
    parentId?: true;
    contenido?: true;
    eliminado?: true;
    creadoEn?: true;
    actualizadoEn?: true;
  };

  export type ResenaRespuestaCountAggregateInputType = {
    id?: true;
    resenaId?: true;
    usuarioId?: true;
    parentId?: true;
    contenido?: true;
    eliminado?: true;
    creadoEn?: true;
    actualizadoEn?: true;
    _all?: true;
  };

  export type ResenaRespuestaAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ResenaRespuesta to aggregate.
     */
    where?: ResenaRespuestaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ResenaRespuestas to fetch.
     */
    orderBy?:
      | ResenaRespuestaOrderByWithRelationInput
      | ResenaRespuestaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ResenaRespuestaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ResenaRespuestas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ResenaRespuestas.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned ResenaRespuestas
     **/
    _count?: true | ResenaRespuestaCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ResenaRespuestaAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ResenaRespuestaSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ResenaRespuestaMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ResenaRespuestaMaxAggregateInputType;
  };

  export type GetResenaRespuestaAggregateType<
    T extends ResenaRespuestaAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateResenaRespuesta]: P extends
      | '_count'
      | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResenaRespuesta[P]>
      : GetScalarType<T[P], AggregateResenaRespuesta[P]>;
  };

  export type ResenaRespuestaGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ResenaRespuestaWhereInput;
    orderBy?:
      | ResenaRespuestaOrderByWithAggregationInput
      | ResenaRespuestaOrderByWithAggregationInput[];
    by: ResenaRespuestaScalarFieldEnum[] | ResenaRespuestaScalarFieldEnum;
    having?: ResenaRespuestaScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ResenaRespuestaCountAggregateInputType | true;
    _avg?: ResenaRespuestaAvgAggregateInputType;
    _sum?: ResenaRespuestaSumAggregateInputType;
    _min?: ResenaRespuestaMinAggregateInputType;
    _max?: ResenaRespuestaMaxAggregateInputType;
  };

  export type ResenaRespuestaGroupByOutputType = {
    id: number;
    resenaId: number;
    usuarioId: number;
    parentId: number | null;
    contenido: string;
    eliminado: boolean;
    creadoEn: Date;
    actualizadoEn: Date;
    _count: ResenaRespuestaCountAggregateOutputType | null;
    _avg: ResenaRespuestaAvgAggregateOutputType | null;
    _sum: ResenaRespuestaSumAggregateOutputType | null;
    _min: ResenaRespuestaMinAggregateOutputType | null;
    _max: ResenaRespuestaMaxAggregateOutputType | null;
  };

  type GetResenaRespuestaGroupByPayload<T extends ResenaRespuestaGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ResenaRespuestaGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof ResenaRespuestaGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResenaRespuestaGroupByOutputType[P]>
            : GetScalarType<T[P], ResenaRespuestaGroupByOutputType[P]>;
        }
      >
    >;

  export type ResenaRespuestaSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      resenaId?: boolean;
      usuarioId?: boolean;
      parentId?: boolean;
      contenido?: boolean;
      eliminado?: boolean;
      creadoEn?: boolean;
      actualizadoEn?: boolean;
      resena?: boolean | ResenaDefaultArgs<ExtArgs>;
      usuario?: boolean | UsuarioDefaultArgs<ExtArgs>;
      parent?: boolean | ResenaRespuesta$parentArgs<ExtArgs>;
      hijos?: boolean | ResenaRespuesta$hijosArgs<ExtArgs>;
      _count?: boolean | ResenaRespuestaCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['resenaRespuesta']
  >;

  export type ResenaRespuestaSelectScalar = {
    id?: boolean;
    resenaId?: boolean;
    usuarioId?: boolean;
    parentId?: boolean;
    contenido?: boolean;
    eliminado?: boolean;
    creadoEn?: boolean;
    actualizadoEn?: boolean;
  };

  export type ResenaRespuestaOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'resenaId'
    | 'usuarioId'
    | 'parentId'
    | 'contenido'
    | 'eliminado'
    | 'creadoEn'
    | 'actualizadoEn',
    ExtArgs['result']['resenaRespuesta']
  >;
  export type ResenaRespuestaInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    resena?: boolean | ResenaDefaultArgs<ExtArgs>;
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>;
    parent?: boolean | ResenaRespuesta$parentArgs<ExtArgs>;
    hijos?: boolean | ResenaRespuesta$hijosArgs<ExtArgs>;
    _count?: boolean | ResenaRespuestaCountOutputTypeDefaultArgs<ExtArgs>;
  };

  export type $ResenaRespuestaPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'ResenaRespuesta';
    objects: {
      resena: Prisma.$ResenaPayload<ExtArgs>;
      usuario: Prisma.$UsuarioPayload<ExtArgs>;
      parent: Prisma.$ResenaRespuestaPayload<ExtArgs> | null;
      hijos: Prisma.$ResenaRespuestaPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        resenaId: number;
        usuarioId: number;
        parentId: number | null;
        contenido: string;
        eliminado: boolean;
        creadoEn: Date;
        actualizadoEn: Date;
      },
      ExtArgs['result']['resenaRespuesta']
    >;
    composites: {};
  };

  type ResenaRespuestaGetPayload<
    S extends boolean | null | undefined | ResenaRespuestaDefaultArgs,
  > = $Result.GetResult<Prisma.$ResenaRespuestaPayload, S>;

  type ResenaRespuestaCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    ResenaRespuestaFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: ResenaRespuestaCountAggregateInputType | true;
  };

  export interface ResenaRespuestaDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['ResenaRespuesta'];
      meta: { name: 'ResenaRespuesta' };
    };
    /**
     * Find zero or one ResenaRespuesta that matches the filter.
     * @param {ResenaRespuestaFindUniqueArgs} args - Arguments to find a ResenaRespuesta
     * @example
     * // Get one ResenaRespuesta
     * const resenaRespuesta = await prisma.resenaRespuesta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResenaRespuestaFindUniqueArgs>(
      args: SelectSubset<T, ResenaRespuestaFindUniqueArgs<ExtArgs>>,
    ): Prisma__ResenaRespuestaClient<
      $Result.GetResult<
        Prisma.$ResenaRespuestaPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one ResenaRespuesta that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ResenaRespuestaFindUniqueOrThrowArgs} args - Arguments to find a ResenaRespuesta
     * @example
     * // Get one ResenaRespuesta
     * const resenaRespuesta = await prisma.resenaRespuesta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResenaRespuestaFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ResenaRespuestaFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__ResenaRespuestaClient<
      $Result.GetResult<
        Prisma.$ResenaRespuestaPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ResenaRespuesta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResenaRespuestaFindFirstArgs} args - Arguments to find a ResenaRespuesta
     * @example
     * // Get one ResenaRespuesta
     * const resenaRespuesta = await prisma.resenaRespuesta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResenaRespuestaFindFirstArgs>(
      args?: SelectSubset<T, ResenaRespuestaFindFirstArgs<ExtArgs>>,
    ): Prisma__ResenaRespuestaClient<
      $Result.GetResult<
        Prisma.$ResenaRespuestaPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ResenaRespuesta that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResenaRespuestaFindFirstOrThrowArgs} args - Arguments to find a ResenaRespuesta
     * @example
     * // Get one ResenaRespuesta
     * const resenaRespuesta = await prisma.resenaRespuesta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResenaRespuestaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ResenaRespuestaFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__ResenaRespuestaClient<
      $Result.GetResult<
        Prisma.$ResenaRespuestaPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more ResenaRespuestas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResenaRespuestaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ResenaRespuestas
     * const resenaRespuestas = await prisma.resenaRespuesta.findMany()
     *
     * // Get first 10 ResenaRespuestas
     * const resenaRespuestas = await prisma.resenaRespuesta.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const resenaRespuestaWithIdOnly = await prisma.resenaRespuesta.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ResenaRespuestaFindManyArgs>(
      args?: SelectSubset<T, ResenaRespuestaFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ResenaRespuestaPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a ResenaRespuesta.
     * @param {ResenaRespuestaCreateArgs} args - Arguments to create a ResenaRespuesta.
     * @example
     * // Create one ResenaRespuesta
     * const ResenaRespuesta = await prisma.resenaRespuesta.create({
     *   data: {
     *     // ... data to create a ResenaRespuesta
     *   }
     * })
     *
     */
    create<T extends ResenaRespuestaCreateArgs>(
      args: SelectSubset<T, ResenaRespuestaCreateArgs<ExtArgs>>,
    ): Prisma__ResenaRespuestaClient<
      $Result.GetResult<
        Prisma.$ResenaRespuestaPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many ResenaRespuestas.
     * @param {ResenaRespuestaCreateManyArgs} args - Arguments to create many ResenaRespuestas.
     * @example
     * // Create many ResenaRespuestas
     * const resenaRespuesta = await prisma.resenaRespuesta.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ResenaRespuestaCreateManyArgs>(
      args?: SelectSubset<T, ResenaRespuestaCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a ResenaRespuesta.
     * @param {ResenaRespuestaDeleteArgs} args - Arguments to delete one ResenaRespuesta.
     * @example
     * // Delete one ResenaRespuesta
     * const ResenaRespuesta = await prisma.resenaRespuesta.delete({
     *   where: {
     *     // ... filter to delete one ResenaRespuesta
     *   }
     * })
     *
     */
    delete<T extends ResenaRespuestaDeleteArgs>(
      args: SelectSubset<T, ResenaRespuestaDeleteArgs<ExtArgs>>,
    ): Prisma__ResenaRespuestaClient<
      $Result.GetResult<
        Prisma.$ResenaRespuestaPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one ResenaRespuesta.
     * @param {ResenaRespuestaUpdateArgs} args - Arguments to update one ResenaRespuesta.
     * @example
     * // Update one ResenaRespuesta
     * const resenaRespuesta = await prisma.resenaRespuesta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ResenaRespuestaUpdateArgs>(
      args: SelectSubset<T, ResenaRespuestaUpdateArgs<ExtArgs>>,
    ): Prisma__ResenaRespuestaClient<
      $Result.GetResult<
        Prisma.$ResenaRespuestaPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more ResenaRespuestas.
     * @param {ResenaRespuestaDeleteManyArgs} args - Arguments to filter ResenaRespuestas to delete.
     * @example
     * // Delete a few ResenaRespuestas
     * const { count } = await prisma.resenaRespuesta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ResenaRespuestaDeleteManyArgs>(
      args?: SelectSubset<T, ResenaRespuestaDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ResenaRespuestas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResenaRespuestaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ResenaRespuestas
     * const resenaRespuesta = await prisma.resenaRespuesta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ResenaRespuestaUpdateManyArgs>(
      args: SelectSubset<T, ResenaRespuestaUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one ResenaRespuesta.
     * @param {ResenaRespuestaUpsertArgs} args - Arguments to update or create a ResenaRespuesta.
     * @example
     * // Update or create a ResenaRespuesta
     * const resenaRespuesta = await prisma.resenaRespuesta.upsert({
     *   create: {
     *     // ... data to create a ResenaRespuesta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ResenaRespuesta we want to update
     *   }
     * })
     */
    upsert<T extends ResenaRespuestaUpsertArgs>(
      args: SelectSubset<T, ResenaRespuestaUpsertArgs<ExtArgs>>,
    ): Prisma__ResenaRespuestaClient<
      $Result.GetResult<
        Prisma.$ResenaRespuestaPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of ResenaRespuestas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResenaRespuestaCountArgs} args - Arguments to filter ResenaRespuestas to count.
     * @example
     * // Count the number of ResenaRespuestas
     * const count = await prisma.resenaRespuesta.count({
     *   where: {
     *     // ... the filter for the ResenaRespuestas we want to count
     *   }
     * })
     **/
    count<T extends ResenaRespuestaCountArgs>(
      args?: Subset<T, ResenaRespuestaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResenaRespuestaCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a ResenaRespuesta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResenaRespuestaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ResenaRespuestaAggregateArgs>(
      args: Subset<T, ResenaRespuestaAggregateArgs>,
    ): Prisma.PrismaPromise<GetResenaRespuestaAggregateType<T>>;

    /**
     * Group by ResenaRespuesta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResenaRespuestaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ResenaRespuestaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResenaRespuestaGroupByArgs['orderBy'] }
        : { orderBy?: ResenaRespuestaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ResenaRespuestaGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetResenaRespuestaGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the ResenaRespuesta model
     */
    readonly fields: ResenaRespuestaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ResenaRespuesta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResenaRespuestaClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    resena<T extends ResenaDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, ResenaDefaultArgs<ExtArgs>>,
    ): Prisma__ResenaClient<
      | $Result.GetResult<
          Prisma.$ResenaPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>,
    ): Prisma__UsuarioClient<
      | $Result.GetResult<
          Prisma.$UsuarioPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    parent<T extends ResenaRespuesta$parentArgs<ExtArgs> = {}>(
      args?: Subset<T, ResenaRespuesta$parentArgs<ExtArgs>>,
    ): Prisma__ResenaRespuestaClient<
      $Result.GetResult<
        Prisma.$ResenaRespuestaPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    hijos<T extends ResenaRespuesta$hijosArgs<ExtArgs> = {}>(
      args?: Subset<T, ResenaRespuesta$hijosArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$ResenaRespuestaPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the ResenaRespuesta model
   */
  interface ResenaRespuestaFieldRefs {
    readonly id: FieldRef<'ResenaRespuesta', 'Int'>;
    readonly resenaId: FieldRef<'ResenaRespuesta', 'Int'>;
    readonly usuarioId: FieldRef<'ResenaRespuesta', 'Int'>;
    readonly parentId: FieldRef<'ResenaRespuesta', 'Int'>;
    readonly contenido: FieldRef<'ResenaRespuesta', 'String'>;
    readonly eliminado: FieldRef<'ResenaRespuesta', 'Boolean'>;
    readonly creadoEn: FieldRef<'ResenaRespuesta', 'DateTime'>;
    readonly actualizadoEn: FieldRef<'ResenaRespuesta', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * ResenaRespuesta findUnique
   */
  export type ResenaRespuestaFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ResenaRespuesta
     */
    select?: ResenaRespuestaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ResenaRespuesta
     */
    omit?: ResenaRespuestaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaRespuestaInclude<ExtArgs> | null;
    /**
     * Filter, which ResenaRespuesta to fetch.
     */
    where: ResenaRespuestaWhereUniqueInput;
  };

  /**
   * ResenaRespuesta findUniqueOrThrow
   */
  export type ResenaRespuestaFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ResenaRespuesta
     */
    select?: ResenaRespuestaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ResenaRespuesta
     */
    omit?: ResenaRespuestaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaRespuestaInclude<ExtArgs> | null;
    /**
     * Filter, which ResenaRespuesta to fetch.
     */
    where: ResenaRespuestaWhereUniqueInput;
  };

  /**
   * ResenaRespuesta findFirst
   */
  export type ResenaRespuestaFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ResenaRespuesta
     */
    select?: ResenaRespuestaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ResenaRespuesta
     */
    omit?: ResenaRespuestaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaRespuestaInclude<ExtArgs> | null;
    /**
     * Filter, which ResenaRespuesta to fetch.
     */
    where?: ResenaRespuestaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ResenaRespuestas to fetch.
     */
    orderBy?:
      | ResenaRespuestaOrderByWithRelationInput
      | ResenaRespuestaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ResenaRespuestas.
     */
    cursor?: ResenaRespuestaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ResenaRespuestas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ResenaRespuestas.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ResenaRespuestas.
     */
    distinct?:
      | ResenaRespuestaScalarFieldEnum
      | ResenaRespuestaScalarFieldEnum[];
  };

  /**
   * ResenaRespuesta findFirstOrThrow
   */
  export type ResenaRespuestaFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ResenaRespuesta
     */
    select?: ResenaRespuestaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ResenaRespuesta
     */
    omit?: ResenaRespuestaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaRespuestaInclude<ExtArgs> | null;
    /**
     * Filter, which ResenaRespuesta to fetch.
     */
    where?: ResenaRespuestaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ResenaRespuestas to fetch.
     */
    orderBy?:
      | ResenaRespuestaOrderByWithRelationInput
      | ResenaRespuestaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ResenaRespuestas.
     */
    cursor?: ResenaRespuestaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ResenaRespuestas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ResenaRespuestas.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ResenaRespuestas.
     */
    distinct?:
      | ResenaRespuestaScalarFieldEnum
      | ResenaRespuestaScalarFieldEnum[];
  };

  /**
   * ResenaRespuesta findMany
   */
  export type ResenaRespuestaFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ResenaRespuesta
     */
    select?: ResenaRespuestaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ResenaRespuesta
     */
    omit?: ResenaRespuestaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaRespuestaInclude<ExtArgs> | null;
    /**
     * Filter, which ResenaRespuestas to fetch.
     */
    where?: ResenaRespuestaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ResenaRespuestas to fetch.
     */
    orderBy?:
      | ResenaRespuestaOrderByWithRelationInput
      | ResenaRespuestaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing ResenaRespuestas.
     */
    cursor?: ResenaRespuestaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ResenaRespuestas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ResenaRespuestas.
     */
    skip?: number;
    distinct?:
      | ResenaRespuestaScalarFieldEnum
      | ResenaRespuestaScalarFieldEnum[];
  };

  /**
   * ResenaRespuesta create
   */
  export type ResenaRespuestaCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ResenaRespuesta
     */
    select?: ResenaRespuestaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ResenaRespuesta
     */
    omit?: ResenaRespuestaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaRespuestaInclude<ExtArgs> | null;
    /**
     * The data needed to create a ResenaRespuesta.
     */
    data: XOR<ResenaRespuestaCreateInput, ResenaRespuestaUncheckedCreateInput>;
  };

  /**
   * ResenaRespuesta createMany
   */
  export type ResenaRespuestaCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many ResenaRespuestas.
     */
    data: ResenaRespuestaCreateManyInput | ResenaRespuestaCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * ResenaRespuesta update
   */
  export type ResenaRespuestaUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ResenaRespuesta
     */
    select?: ResenaRespuestaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ResenaRespuesta
     */
    omit?: ResenaRespuestaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaRespuestaInclude<ExtArgs> | null;
    /**
     * The data needed to update a ResenaRespuesta.
     */
    data: XOR<ResenaRespuestaUpdateInput, ResenaRespuestaUncheckedUpdateInput>;
    /**
     * Choose, which ResenaRespuesta to update.
     */
    where: ResenaRespuestaWhereUniqueInput;
  };

  /**
   * ResenaRespuesta updateMany
   */
  export type ResenaRespuestaUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update ResenaRespuestas.
     */
    data: XOR<
      ResenaRespuestaUpdateManyMutationInput,
      ResenaRespuestaUncheckedUpdateManyInput
    >;
    /**
     * Filter which ResenaRespuestas to update
     */
    where?: ResenaRespuestaWhereInput;
    /**
     * Limit how many ResenaRespuestas to update.
     */
    limit?: number;
  };

  /**
   * ResenaRespuesta upsert
   */
  export type ResenaRespuestaUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ResenaRespuesta
     */
    select?: ResenaRespuestaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ResenaRespuesta
     */
    omit?: ResenaRespuestaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaRespuestaInclude<ExtArgs> | null;
    /**
     * The filter to search for the ResenaRespuesta to update in case it exists.
     */
    where: ResenaRespuestaWhereUniqueInput;
    /**
     * In case the ResenaRespuesta found by the `where` argument doesn't exist, create a new ResenaRespuesta with this data.
     */
    create: XOR<
      ResenaRespuestaCreateInput,
      ResenaRespuestaUncheckedCreateInput
    >;
    /**
     * In case the ResenaRespuesta was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      ResenaRespuestaUpdateInput,
      ResenaRespuestaUncheckedUpdateInput
    >;
  };

  /**
   * ResenaRespuesta delete
   */
  export type ResenaRespuestaDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ResenaRespuesta
     */
    select?: ResenaRespuestaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ResenaRespuesta
     */
    omit?: ResenaRespuestaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaRespuestaInclude<ExtArgs> | null;
    /**
     * Filter which ResenaRespuesta to delete.
     */
    where: ResenaRespuestaWhereUniqueInput;
  };

  /**
   * ResenaRespuesta deleteMany
   */
  export type ResenaRespuestaDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ResenaRespuestas to delete
     */
    where?: ResenaRespuestaWhereInput;
    /**
     * Limit how many ResenaRespuestas to delete.
     */
    limit?: number;
  };

  /**
   * ResenaRespuesta.parent
   */
  export type ResenaRespuesta$parentArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ResenaRespuesta
     */
    select?: ResenaRespuestaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ResenaRespuesta
     */
    omit?: ResenaRespuestaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaRespuestaInclude<ExtArgs> | null;
    where?: ResenaRespuestaWhereInput;
  };

  /**
   * ResenaRespuesta.hijos
   */
  export type ResenaRespuesta$hijosArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ResenaRespuesta
     */
    select?: ResenaRespuestaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ResenaRespuesta
     */
    omit?: ResenaRespuestaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaRespuestaInclude<ExtArgs> | null;
    where?: ResenaRespuestaWhereInput;
    orderBy?:
      | ResenaRespuestaOrderByWithRelationInput
      | ResenaRespuestaOrderByWithRelationInput[];
    cursor?: ResenaRespuestaWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | ResenaRespuestaScalarFieldEnum
      | ResenaRespuestaScalarFieldEnum[];
  };

  /**
   * ResenaRespuesta without action
   */
  export type ResenaRespuestaDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ResenaRespuesta
     */
    select?: ResenaRespuestaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ResenaRespuesta
     */
    omit?: ResenaRespuestaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaRespuestaInclude<ExtArgs> | null;
  };

  /**
   * Model Notificacion
   */

  export type AggregateNotificacion = {
    _count: NotificacionCountAggregateOutputType | null;
    _avg: NotificacionAvgAggregateOutputType | null;
    _sum: NotificacionSumAggregateOutputType | null;
    _min: NotificacionMinAggregateOutputType | null;
    _max: NotificacionMaxAggregateOutputType | null;
  };

  export type NotificacionAvgAggregateOutputType = {
    id: number | null;
    usuarioId: number | null;
  };

  export type NotificacionSumAggregateOutputType = {
    id: number | null;
    usuarioId: number | null;
  };

  export type NotificacionMinAggregateOutputType = {
    id: number | null;
    usuarioId: number | null;
    tipo: $Enums.TipoNotificacion | null;
    titulo: string | null;
    mensaje: string | null;
    leida: boolean | null;
    url: string | null;
    creadoEn: Date | null;
  };

  export type NotificacionMaxAggregateOutputType = {
    id: number | null;
    usuarioId: number | null;
    tipo: $Enums.TipoNotificacion | null;
    titulo: string | null;
    mensaje: string | null;
    leida: boolean | null;
    url: string | null;
    creadoEn: Date | null;
  };

  export type NotificacionCountAggregateOutputType = {
    id: number;
    usuarioId: number;
    tipo: number;
    titulo: number;
    mensaje: number;
    leida: number;
    url: number;
    metadata: number;
    creadoEn: number;
    _all: number;
  };

  export type NotificacionAvgAggregateInputType = {
    id?: true;
    usuarioId?: true;
  };

  export type NotificacionSumAggregateInputType = {
    id?: true;
    usuarioId?: true;
  };

  export type NotificacionMinAggregateInputType = {
    id?: true;
    usuarioId?: true;
    tipo?: true;
    titulo?: true;
    mensaje?: true;
    leida?: true;
    url?: true;
    creadoEn?: true;
  };

  export type NotificacionMaxAggregateInputType = {
    id?: true;
    usuarioId?: true;
    tipo?: true;
    titulo?: true;
    mensaje?: true;
    leida?: true;
    url?: true;
    creadoEn?: true;
  };

  export type NotificacionCountAggregateInputType = {
    id?: true;
    usuarioId?: true;
    tipo?: true;
    titulo?: true;
    mensaje?: true;
    leida?: true;
    url?: true;
    metadata?: true;
    creadoEn?: true;
    _all?: true;
  };

  export type NotificacionAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Notificacion to aggregate.
     */
    where?: NotificacionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Notificacions to fetch.
     */
    orderBy?:
      | NotificacionOrderByWithRelationInput
      | NotificacionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: NotificacionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Notificacions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Notificacions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Notificacions
     **/
    _count?: true | NotificacionCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: NotificacionAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: NotificacionSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: NotificacionMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: NotificacionMaxAggregateInputType;
  };

  export type GetNotificacionAggregateType<
    T extends NotificacionAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateNotificacion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificacion[P]>
      : GetScalarType<T[P], AggregateNotificacion[P]>;
  };

  export type NotificacionGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: NotificacionWhereInput;
    orderBy?:
      | NotificacionOrderByWithAggregationInput
      | NotificacionOrderByWithAggregationInput[];
    by: NotificacionScalarFieldEnum[] | NotificacionScalarFieldEnum;
    having?: NotificacionScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: NotificacionCountAggregateInputType | true;
    _avg?: NotificacionAvgAggregateInputType;
    _sum?: NotificacionSumAggregateInputType;
    _min?: NotificacionMinAggregateInputType;
    _max?: NotificacionMaxAggregateInputType;
  };

  export type NotificacionGroupByOutputType = {
    id: number;
    usuarioId: number;
    tipo: $Enums.TipoNotificacion;
    titulo: string;
    mensaje: string;
    leida: boolean;
    url: string | null;
    metadata: JsonValue | null;
    creadoEn: Date;
    _count: NotificacionCountAggregateOutputType | null;
    _avg: NotificacionAvgAggregateOutputType | null;
    _sum: NotificacionSumAggregateOutputType | null;
    _min: NotificacionMinAggregateOutputType | null;
    _max: NotificacionMaxAggregateOutputType | null;
  };

  type GetNotificacionGroupByPayload<T extends NotificacionGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<NotificacionGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof NotificacionGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificacionGroupByOutputType[P]>
            : GetScalarType<T[P], NotificacionGroupByOutputType[P]>;
        }
      >
    >;

  export type NotificacionSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      usuarioId?: boolean;
      tipo?: boolean;
      titulo?: boolean;
      mensaje?: boolean;
      leida?: boolean;
      url?: boolean;
      metadata?: boolean;
      creadoEn?: boolean;
      usuario?: boolean | UsuarioDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['notificacion']
  >;

  export type NotificacionSelectScalar = {
    id?: boolean;
    usuarioId?: boolean;
    tipo?: boolean;
    titulo?: boolean;
    mensaje?: boolean;
    leida?: boolean;
    url?: boolean;
    metadata?: boolean;
    creadoEn?: boolean;
  };

  export type NotificacionOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'usuarioId'
    | 'tipo'
    | 'titulo'
    | 'mensaje'
    | 'leida'
    | 'url'
    | 'metadata'
    | 'creadoEn',
    ExtArgs['result']['notificacion']
  >;
  export type NotificacionInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>;
  };

  export type $NotificacionPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Notificacion';
    objects: {
      usuario: Prisma.$UsuarioPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        usuarioId: number;
        tipo: $Enums.TipoNotificacion;
        titulo: string;
        mensaje: string;
        leida: boolean;
        url: string | null;
        metadata: Prisma.JsonValue | null;
        creadoEn: Date;
      },
      ExtArgs['result']['notificacion']
    >;
    composites: {};
  };

  type NotificacionGetPayload<
    S extends boolean | null | undefined | NotificacionDefaultArgs,
  > = $Result.GetResult<Prisma.$NotificacionPayload, S>;

  type NotificacionCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    NotificacionFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: NotificacionCountAggregateInputType | true;
  };

  export interface NotificacionDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Notificacion'];
      meta: { name: 'Notificacion' };
    };
    /**
     * Find zero or one Notificacion that matches the filter.
     * @param {NotificacionFindUniqueArgs} args - Arguments to find a Notificacion
     * @example
     * // Get one Notificacion
     * const notificacion = await prisma.notificacion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificacionFindUniqueArgs>(
      args: SelectSubset<T, NotificacionFindUniqueArgs<ExtArgs>>,
    ): Prisma__NotificacionClient<
      $Result.GetResult<
        Prisma.$NotificacionPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Notificacion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificacionFindUniqueOrThrowArgs} args - Arguments to find a Notificacion
     * @example
     * // Get one Notificacion
     * const notificacion = await prisma.notificacion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificacionFindUniqueOrThrowArgs>(
      args: SelectSubset<T, NotificacionFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__NotificacionClient<
      $Result.GetResult<
        Prisma.$NotificacionPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Notificacion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacionFindFirstArgs} args - Arguments to find a Notificacion
     * @example
     * // Get one Notificacion
     * const notificacion = await prisma.notificacion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificacionFindFirstArgs>(
      args?: SelectSubset<T, NotificacionFindFirstArgs<ExtArgs>>,
    ): Prisma__NotificacionClient<
      $Result.GetResult<
        Prisma.$NotificacionPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Notificacion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacionFindFirstOrThrowArgs} args - Arguments to find a Notificacion
     * @example
     * // Get one Notificacion
     * const notificacion = await prisma.notificacion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificacionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, NotificacionFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__NotificacionClient<
      $Result.GetResult<
        Prisma.$NotificacionPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Notificacions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notificacions
     * const notificacions = await prisma.notificacion.findMany()
     *
     * // Get first 10 Notificacions
     * const notificacions = await prisma.notificacion.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const notificacionWithIdOnly = await prisma.notificacion.findMany({ select: { id: true } })
     *
     */
    findMany<T extends NotificacionFindManyArgs>(
      args?: SelectSubset<T, NotificacionFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$NotificacionPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Notificacion.
     * @param {NotificacionCreateArgs} args - Arguments to create a Notificacion.
     * @example
     * // Create one Notificacion
     * const Notificacion = await prisma.notificacion.create({
     *   data: {
     *     // ... data to create a Notificacion
     *   }
     * })
     *
     */
    create<T extends NotificacionCreateArgs>(
      args: SelectSubset<T, NotificacionCreateArgs<ExtArgs>>,
    ): Prisma__NotificacionClient<
      $Result.GetResult<
        Prisma.$NotificacionPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Notificacions.
     * @param {NotificacionCreateManyArgs} args - Arguments to create many Notificacions.
     * @example
     * // Create many Notificacions
     * const notificacion = await prisma.notificacion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends NotificacionCreateManyArgs>(
      args?: SelectSubset<T, NotificacionCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Notificacion.
     * @param {NotificacionDeleteArgs} args - Arguments to delete one Notificacion.
     * @example
     * // Delete one Notificacion
     * const Notificacion = await prisma.notificacion.delete({
     *   where: {
     *     // ... filter to delete one Notificacion
     *   }
     * })
     *
     */
    delete<T extends NotificacionDeleteArgs>(
      args: SelectSubset<T, NotificacionDeleteArgs<ExtArgs>>,
    ): Prisma__NotificacionClient<
      $Result.GetResult<
        Prisma.$NotificacionPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Notificacion.
     * @param {NotificacionUpdateArgs} args - Arguments to update one Notificacion.
     * @example
     * // Update one Notificacion
     * const notificacion = await prisma.notificacion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends NotificacionUpdateArgs>(
      args: SelectSubset<T, NotificacionUpdateArgs<ExtArgs>>,
    ): Prisma__NotificacionClient<
      $Result.GetResult<
        Prisma.$NotificacionPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Notificacions.
     * @param {NotificacionDeleteManyArgs} args - Arguments to filter Notificacions to delete.
     * @example
     * // Delete a few Notificacions
     * const { count } = await prisma.notificacion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends NotificacionDeleteManyArgs>(
      args?: SelectSubset<T, NotificacionDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Notificacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notificacions
     * const notificacion = await prisma.notificacion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends NotificacionUpdateManyArgs>(
      args: SelectSubset<T, NotificacionUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Notificacion.
     * @param {NotificacionUpsertArgs} args - Arguments to update or create a Notificacion.
     * @example
     * // Update or create a Notificacion
     * const notificacion = await prisma.notificacion.upsert({
     *   create: {
     *     // ... data to create a Notificacion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notificacion we want to update
     *   }
     * })
     */
    upsert<T extends NotificacionUpsertArgs>(
      args: SelectSubset<T, NotificacionUpsertArgs<ExtArgs>>,
    ): Prisma__NotificacionClient<
      $Result.GetResult<
        Prisma.$NotificacionPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Notificacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacionCountArgs} args - Arguments to filter Notificacions to count.
     * @example
     * // Count the number of Notificacions
     * const count = await prisma.notificacion.count({
     *   where: {
     *     // ... the filter for the Notificacions we want to count
     *   }
     * })
     **/
    count<T extends NotificacionCountArgs>(
      args?: Subset<T, NotificacionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificacionCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Notificacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends NotificacionAggregateArgs>(
      args: Subset<T, NotificacionAggregateArgs>,
    ): Prisma.PrismaPromise<GetNotificacionAggregateType<T>>;

    /**
     * Group by Notificacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends NotificacionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificacionGroupByArgs['orderBy'] }
        : { orderBy?: NotificacionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, NotificacionGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetNotificacionGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Notificacion model
     */
    readonly fields: NotificacionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notificacion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificacionClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>,
    ): Prisma__UsuarioClient<
      | $Result.GetResult<
          Prisma.$UsuarioPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Notificacion model
   */
  interface NotificacionFieldRefs {
    readonly id: FieldRef<'Notificacion', 'Int'>;
    readonly usuarioId: FieldRef<'Notificacion', 'Int'>;
    readonly tipo: FieldRef<'Notificacion', 'TipoNotificacion'>;
    readonly titulo: FieldRef<'Notificacion', 'String'>;
    readonly mensaje: FieldRef<'Notificacion', 'String'>;
    readonly leida: FieldRef<'Notificacion', 'Boolean'>;
    readonly url: FieldRef<'Notificacion', 'String'>;
    readonly metadata: FieldRef<'Notificacion', 'Json'>;
    readonly creadoEn: FieldRef<'Notificacion', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Notificacion findUnique
   */
  export type NotificacionFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null;
    /**
     * Filter, which Notificacion to fetch.
     */
    where: NotificacionWhereUniqueInput;
  };

  /**
   * Notificacion findUniqueOrThrow
   */
  export type NotificacionFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null;
    /**
     * Filter, which Notificacion to fetch.
     */
    where: NotificacionWhereUniqueInput;
  };

  /**
   * Notificacion findFirst
   */
  export type NotificacionFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null;
    /**
     * Filter, which Notificacion to fetch.
     */
    where?: NotificacionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Notificacions to fetch.
     */
    orderBy?:
      | NotificacionOrderByWithRelationInput
      | NotificacionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Notificacions.
     */
    cursor?: NotificacionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Notificacions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Notificacions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Notificacions.
     */
    distinct?: NotificacionScalarFieldEnum | NotificacionScalarFieldEnum[];
  };

  /**
   * Notificacion findFirstOrThrow
   */
  export type NotificacionFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null;
    /**
     * Filter, which Notificacion to fetch.
     */
    where?: NotificacionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Notificacions to fetch.
     */
    orderBy?:
      | NotificacionOrderByWithRelationInput
      | NotificacionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Notificacions.
     */
    cursor?: NotificacionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Notificacions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Notificacions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Notificacions.
     */
    distinct?: NotificacionScalarFieldEnum | NotificacionScalarFieldEnum[];
  };

  /**
   * Notificacion findMany
   */
  export type NotificacionFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null;
    /**
     * Filter, which Notificacions to fetch.
     */
    where?: NotificacionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Notificacions to fetch.
     */
    orderBy?:
      | NotificacionOrderByWithRelationInput
      | NotificacionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Notificacions.
     */
    cursor?: NotificacionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Notificacions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Notificacions.
     */
    skip?: number;
    distinct?: NotificacionScalarFieldEnum | NotificacionScalarFieldEnum[];
  };

  /**
   * Notificacion create
   */
  export type NotificacionCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null;
    /**
     * The data needed to create a Notificacion.
     */
    data: XOR<NotificacionCreateInput, NotificacionUncheckedCreateInput>;
  };

  /**
   * Notificacion createMany
   */
  export type NotificacionCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Notificacions.
     */
    data: NotificacionCreateManyInput | NotificacionCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Notificacion update
   */
  export type NotificacionUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null;
    /**
     * The data needed to update a Notificacion.
     */
    data: XOR<NotificacionUpdateInput, NotificacionUncheckedUpdateInput>;
    /**
     * Choose, which Notificacion to update.
     */
    where: NotificacionWhereUniqueInput;
  };

  /**
   * Notificacion updateMany
   */
  export type NotificacionUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Notificacions.
     */
    data: XOR<
      NotificacionUpdateManyMutationInput,
      NotificacionUncheckedUpdateManyInput
    >;
    /**
     * Filter which Notificacions to update
     */
    where?: NotificacionWhereInput;
    /**
     * Limit how many Notificacions to update.
     */
    limit?: number;
  };

  /**
   * Notificacion upsert
   */
  export type NotificacionUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null;
    /**
     * The filter to search for the Notificacion to update in case it exists.
     */
    where: NotificacionWhereUniqueInput;
    /**
     * In case the Notificacion found by the `where` argument doesn't exist, create a new Notificacion with this data.
     */
    create: XOR<NotificacionCreateInput, NotificacionUncheckedCreateInput>;
    /**
     * In case the Notificacion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificacionUpdateInput, NotificacionUncheckedUpdateInput>;
  };

  /**
   * Notificacion delete
   */
  export type NotificacionDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null;
    /**
     * Filter which Notificacion to delete.
     */
    where: NotificacionWhereUniqueInput;
  };

  /**
   * Notificacion deleteMany
   */
  export type NotificacionDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Notificacions to delete
     */
    where?: NotificacionWhereInput;
    /**
     * Limit how many Notificacions to delete.
     */
    limit?: number;
  };

  /**
   * Notificacion without action
   */
  export type NotificacionDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null;
  };

  /**
   * Model PreferenciasNotificacion
   */

  export type AggregatePreferenciasNotificacion = {
    _count: PreferenciasNotificacionCountAggregateOutputType | null;
    _avg: PreferenciasNotificacionAvgAggregateOutputType | null;
    _sum: PreferenciasNotificacionSumAggregateOutputType | null;
    _min: PreferenciasNotificacionMinAggregateOutputType | null;
    _max: PreferenciasNotificacionMaxAggregateOutputType | null;
  };

  export type PreferenciasNotificacionAvgAggregateOutputType = {
    id: number | null;
    usuarioId: number | null;
  };

  export type PreferenciasNotificacionSumAggregateOutputType = {
    id: number | null;
    usuarioId: number | null;
  };

  export type PreferenciasNotificacionMinAggregateOutputType = {
    id: number | null;
    usuarioId: number | null;
    nuevaResena: boolean | null;
    respuestaResena: boolean | null;
    actualizacionesSistema: boolean | null;
    mantenimiento: boolean | null;
    reporteContenido: boolean | null;
    contenidoPendiente: boolean | null;
    resumenDiario: boolean | null;
    notificacionesInstantaneas: boolean | null;
    creadoEn: Date | null;
    actualizadoEn: Date | null;
  };

  export type PreferenciasNotificacionMaxAggregateOutputType = {
    id: number | null;
    usuarioId: number | null;
    nuevaResena: boolean | null;
    respuestaResena: boolean | null;
    actualizacionesSistema: boolean | null;
    mantenimiento: boolean | null;
    reporteContenido: boolean | null;
    contenidoPendiente: boolean | null;
    resumenDiario: boolean | null;
    notificacionesInstantaneas: boolean | null;
    creadoEn: Date | null;
    actualizadoEn: Date | null;
  };

  export type PreferenciasNotificacionCountAggregateOutputType = {
    id: number;
    usuarioId: number;
    nuevaResena: number;
    respuestaResena: number;
    actualizacionesSistema: number;
    mantenimiento: number;
    reporteContenido: number;
    contenidoPendiente: number;
    resumenDiario: number;
    notificacionesInstantaneas: number;
    creadoEn: number;
    actualizadoEn: number;
    _all: number;
  };

  export type PreferenciasNotificacionAvgAggregateInputType = {
    id?: true;
    usuarioId?: true;
  };

  export type PreferenciasNotificacionSumAggregateInputType = {
    id?: true;
    usuarioId?: true;
  };

  export type PreferenciasNotificacionMinAggregateInputType = {
    id?: true;
    usuarioId?: true;
    nuevaResena?: true;
    respuestaResena?: true;
    actualizacionesSistema?: true;
    mantenimiento?: true;
    reporteContenido?: true;
    contenidoPendiente?: true;
    resumenDiario?: true;
    notificacionesInstantaneas?: true;
    creadoEn?: true;
    actualizadoEn?: true;
  };

  export type PreferenciasNotificacionMaxAggregateInputType = {
    id?: true;
    usuarioId?: true;
    nuevaResena?: true;
    respuestaResena?: true;
    actualizacionesSistema?: true;
    mantenimiento?: true;
    reporteContenido?: true;
    contenidoPendiente?: true;
    resumenDiario?: true;
    notificacionesInstantaneas?: true;
    creadoEn?: true;
    actualizadoEn?: true;
  };

  export type PreferenciasNotificacionCountAggregateInputType = {
    id?: true;
    usuarioId?: true;
    nuevaResena?: true;
    respuestaResena?: true;
    actualizacionesSistema?: true;
    mantenimiento?: true;
    reporteContenido?: true;
    contenidoPendiente?: true;
    resumenDiario?: true;
    notificacionesInstantaneas?: true;
    creadoEn?: true;
    actualizadoEn?: true;
    _all?: true;
  };

  export type PreferenciasNotificacionAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which PreferenciasNotificacion to aggregate.
     */
    where?: PreferenciasNotificacionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PreferenciasNotificacions to fetch.
     */
    orderBy?:
      | PreferenciasNotificacionOrderByWithRelationInput
      | PreferenciasNotificacionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: PreferenciasNotificacionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PreferenciasNotificacions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PreferenciasNotificacions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned PreferenciasNotificacions
     **/
    _count?: true | PreferenciasNotificacionCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: PreferenciasNotificacionAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: PreferenciasNotificacionSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: PreferenciasNotificacionMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: PreferenciasNotificacionMaxAggregateInputType;
  };

  export type GetPreferenciasNotificacionAggregateType<
    T extends PreferenciasNotificacionAggregateArgs,
  > = {
    [P in keyof T & keyof AggregatePreferenciasNotificacion]: P extends
      | '_count'
      | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePreferenciasNotificacion[P]>
      : GetScalarType<T[P], AggregatePreferenciasNotificacion[P]>;
  };

  export type PreferenciasNotificacionGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: PreferenciasNotificacionWhereInput;
    orderBy?:
      | PreferenciasNotificacionOrderByWithAggregationInput
      | PreferenciasNotificacionOrderByWithAggregationInput[];
    by:
      | PreferenciasNotificacionScalarFieldEnum[]
      | PreferenciasNotificacionScalarFieldEnum;
    having?: PreferenciasNotificacionScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: PreferenciasNotificacionCountAggregateInputType | true;
    _avg?: PreferenciasNotificacionAvgAggregateInputType;
    _sum?: PreferenciasNotificacionSumAggregateInputType;
    _min?: PreferenciasNotificacionMinAggregateInputType;
    _max?: PreferenciasNotificacionMaxAggregateInputType;
  };

  export type PreferenciasNotificacionGroupByOutputType = {
    id: number;
    usuarioId: number;
    nuevaResena: boolean;
    respuestaResena: boolean;
    actualizacionesSistema: boolean;
    mantenimiento: boolean;
    reporteContenido: boolean;
    contenidoPendiente: boolean;
    resumenDiario: boolean;
    notificacionesInstantaneas: boolean;
    creadoEn: Date;
    actualizadoEn: Date;
    _count: PreferenciasNotificacionCountAggregateOutputType | null;
    _avg: PreferenciasNotificacionAvgAggregateOutputType | null;
    _sum: PreferenciasNotificacionSumAggregateOutputType | null;
    _min: PreferenciasNotificacionMinAggregateOutputType | null;
    _max: PreferenciasNotificacionMaxAggregateOutputType | null;
  };

  type GetPreferenciasNotificacionGroupByPayload<
    T extends PreferenciasNotificacionGroupByArgs,
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PreferenciasNotificacionGroupByOutputType, T['by']> & {
        [P in keyof T &
          keyof PreferenciasNotificacionGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], PreferenciasNotificacionGroupByOutputType[P]>
          : GetScalarType<T[P], PreferenciasNotificacionGroupByOutputType[P]>;
      }
    >
  >;

  export type PreferenciasNotificacionSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      usuarioId?: boolean;
      nuevaResena?: boolean;
      respuestaResena?: boolean;
      actualizacionesSistema?: boolean;
      mantenimiento?: boolean;
      reporteContenido?: boolean;
      contenidoPendiente?: boolean;
      resumenDiario?: boolean;
      notificacionesInstantaneas?: boolean;
      creadoEn?: boolean;
      actualizadoEn?: boolean;
    },
    ExtArgs['result']['preferenciasNotificacion']
  >;

  export type PreferenciasNotificacionSelectScalar = {
    id?: boolean;
    usuarioId?: boolean;
    nuevaResena?: boolean;
    respuestaResena?: boolean;
    actualizacionesSistema?: boolean;
    mantenimiento?: boolean;
    reporteContenido?: boolean;
    contenidoPendiente?: boolean;
    resumenDiario?: boolean;
    notificacionesInstantaneas?: boolean;
    creadoEn?: boolean;
    actualizadoEn?: boolean;
  };

  export type PreferenciasNotificacionOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'usuarioId'
    | 'nuevaResena'
    | 'respuestaResena'
    | 'actualizacionesSistema'
    | 'mantenimiento'
    | 'reporteContenido'
    | 'contenidoPendiente'
    | 'resumenDiario'
    | 'notificacionesInstantaneas'
    | 'creadoEn'
    | 'actualizadoEn',
    ExtArgs['result']['preferenciasNotificacion']
  >;

  export type $PreferenciasNotificacionPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'PreferenciasNotificacion';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        usuarioId: number;
        nuevaResena: boolean;
        respuestaResena: boolean;
        actualizacionesSistema: boolean;
        mantenimiento: boolean;
        reporteContenido: boolean;
        contenidoPendiente: boolean;
        resumenDiario: boolean;
        notificacionesInstantaneas: boolean;
        creadoEn: Date;
        actualizadoEn: Date;
      },
      ExtArgs['result']['preferenciasNotificacion']
    >;
    composites: {};
  };

  type PreferenciasNotificacionGetPayload<
    S extends boolean | null | undefined | PreferenciasNotificacionDefaultArgs,
  > = $Result.GetResult<Prisma.$PreferenciasNotificacionPayload, S>;

  type PreferenciasNotificacionCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    PreferenciasNotificacionFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: PreferenciasNotificacionCountAggregateInputType | true;
  };

  export interface PreferenciasNotificacionDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['PreferenciasNotificacion'];
      meta: { name: 'PreferenciasNotificacion' };
    };
    /**
     * Find zero or one PreferenciasNotificacion that matches the filter.
     * @param {PreferenciasNotificacionFindUniqueArgs} args - Arguments to find a PreferenciasNotificacion
     * @example
     * // Get one PreferenciasNotificacion
     * const preferenciasNotificacion = await prisma.preferenciasNotificacion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PreferenciasNotificacionFindUniqueArgs>(
      args: SelectSubset<T, PreferenciasNotificacionFindUniqueArgs<ExtArgs>>,
    ): Prisma__PreferenciasNotificacionClient<
      $Result.GetResult<
        Prisma.$PreferenciasNotificacionPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one PreferenciasNotificacion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PreferenciasNotificacionFindUniqueOrThrowArgs} args - Arguments to find a PreferenciasNotificacion
     * @example
     * // Get one PreferenciasNotificacion
     * const preferenciasNotificacion = await prisma.preferenciasNotificacion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PreferenciasNotificacionFindUniqueOrThrowArgs>(
      args: SelectSubset<
        T,
        PreferenciasNotificacionFindUniqueOrThrowArgs<ExtArgs>
      >,
    ): Prisma__PreferenciasNotificacionClient<
      $Result.GetResult<
        Prisma.$PreferenciasNotificacionPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first PreferenciasNotificacion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreferenciasNotificacionFindFirstArgs} args - Arguments to find a PreferenciasNotificacion
     * @example
     * // Get one PreferenciasNotificacion
     * const preferenciasNotificacion = await prisma.preferenciasNotificacion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PreferenciasNotificacionFindFirstArgs>(
      args?: SelectSubset<T, PreferenciasNotificacionFindFirstArgs<ExtArgs>>,
    ): Prisma__PreferenciasNotificacionClient<
      $Result.GetResult<
        Prisma.$PreferenciasNotificacionPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first PreferenciasNotificacion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreferenciasNotificacionFindFirstOrThrowArgs} args - Arguments to find a PreferenciasNotificacion
     * @example
     * // Get one PreferenciasNotificacion
     * const preferenciasNotificacion = await prisma.preferenciasNotificacion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PreferenciasNotificacionFindFirstOrThrowArgs>(
      args?: SelectSubset<
        T,
        PreferenciasNotificacionFindFirstOrThrowArgs<ExtArgs>
      >,
    ): Prisma__PreferenciasNotificacionClient<
      $Result.GetResult<
        Prisma.$PreferenciasNotificacionPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more PreferenciasNotificacions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreferenciasNotificacionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PreferenciasNotificacions
     * const preferenciasNotificacions = await prisma.preferenciasNotificacion.findMany()
     *
     * // Get first 10 PreferenciasNotificacions
     * const preferenciasNotificacions = await prisma.preferenciasNotificacion.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const preferenciasNotificacionWithIdOnly = await prisma.preferenciasNotificacion.findMany({ select: { id: true } })
     *
     */
    findMany<T extends PreferenciasNotificacionFindManyArgs>(
      args?: SelectSubset<T, PreferenciasNotificacionFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$PreferenciasNotificacionPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a PreferenciasNotificacion.
     * @param {PreferenciasNotificacionCreateArgs} args - Arguments to create a PreferenciasNotificacion.
     * @example
     * // Create one PreferenciasNotificacion
     * const PreferenciasNotificacion = await prisma.preferenciasNotificacion.create({
     *   data: {
     *     // ... data to create a PreferenciasNotificacion
     *   }
     * })
     *
     */
    create<T extends PreferenciasNotificacionCreateArgs>(
      args: SelectSubset<T, PreferenciasNotificacionCreateArgs<ExtArgs>>,
    ): Prisma__PreferenciasNotificacionClient<
      $Result.GetResult<
        Prisma.$PreferenciasNotificacionPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many PreferenciasNotificacions.
     * @param {PreferenciasNotificacionCreateManyArgs} args - Arguments to create many PreferenciasNotificacions.
     * @example
     * // Create many PreferenciasNotificacions
     * const preferenciasNotificacion = await prisma.preferenciasNotificacion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends PreferenciasNotificacionCreateManyArgs>(
      args?: SelectSubset<T, PreferenciasNotificacionCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a PreferenciasNotificacion.
     * @param {PreferenciasNotificacionDeleteArgs} args - Arguments to delete one PreferenciasNotificacion.
     * @example
     * // Delete one PreferenciasNotificacion
     * const PreferenciasNotificacion = await prisma.preferenciasNotificacion.delete({
     *   where: {
     *     // ... filter to delete one PreferenciasNotificacion
     *   }
     * })
     *
     */
    delete<T extends PreferenciasNotificacionDeleteArgs>(
      args: SelectSubset<T, PreferenciasNotificacionDeleteArgs<ExtArgs>>,
    ): Prisma__PreferenciasNotificacionClient<
      $Result.GetResult<
        Prisma.$PreferenciasNotificacionPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one PreferenciasNotificacion.
     * @param {PreferenciasNotificacionUpdateArgs} args - Arguments to update one PreferenciasNotificacion.
     * @example
     * // Update one PreferenciasNotificacion
     * const preferenciasNotificacion = await prisma.preferenciasNotificacion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends PreferenciasNotificacionUpdateArgs>(
      args: SelectSubset<T, PreferenciasNotificacionUpdateArgs<ExtArgs>>,
    ): Prisma__PreferenciasNotificacionClient<
      $Result.GetResult<
        Prisma.$PreferenciasNotificacionPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more PreferenciasNotificacions.
     * @param {PreferenciasNotificacionDeleteManyArgs} args - Arguments to filter PreferenciasNotificacions to delete.
     * @example
     * // Delete a few PreferenciasNotificacions
     * const { count } = await prisma.preferenciasNotificacion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends PreferenciasNotificacionDeleteManyArgs>(
      args?: SelectSubset<T, PreferenciasNotificacionDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more PreferenciasNotificacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreferenciasNotificacionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PreferenciasNotificacions
     * const preferenciasNotificacion = await prisma.preferenciasNotificacion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends PreferenciasNotificacionUpdateManyArgs>(
      args: SelectSubset<T, PreferenciasNotificacionUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one PreferenciasNotificacion.
     * @param {PreferenciasNotificacionUpsertArgs} args - Arguments to update or create a PreferenciasNotificacion.
     * @example
     * // Update or create a PreferenciasNotificacion
     * const preferenciasNotificacion = await prisma.preferenciasNotificacion.upsert({
     *   create: {
     *     // ... data to create a PreferenciasNotificacion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PreferenciasNotificacion we want to update
     *   }
     * })
     */
    upsert<T extends PreferenciasNotificacionUpsertArgs>(
      args: SelectSubset<T, PreferenciasNotificacionUpsertArgs<ExtArgs>>,
    ): Prisma__PreferenciasNotificacionClient<
      $Result.GetResult<
        Prisma.$PreferenciasNotificacionPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of PreferenciasNotificacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreferenciasNotificacionCountArgs} args - Arguments to filter PreferenciasNotificacions to count.
     * @example
     * // Count the number of PreferenciasNotificacions
     * const count = await prisma.preferenciasNotificacion.count({
     *   where: {
     *     // ... the filter for the PreferenciasNotificacions we want to count
     *   }
     * })
     **/
    count<T extends PreferenciasNotificacionCountArgs>(
      args?: Subset<T, PreferenciasNotificacionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<
              T['select'],
              PreferenciasNotificacionCountAggregateOutputType
            >
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a PreferenciasNotificacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreferenciasNotificacionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends PreferenciasNotificacionAggregateArgs>(
      args: Subset<T, PreferenciasNotificacionAggregateArgs>,
    ): Prisma.PrismaPromise<GetPreferenciasNotificacionAggregateType<T>>;

    /**
     * Group by PreferenciasNotificacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreferenciasNotificacionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends PreferenciasNotificacionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PreferenciasNotificacionGroupByArgs['orderBy'] }
        : { orderBy?: PreferenciasNotificacionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<
        T,
        PreferenciasNotificacionGroupByArgs,
        OrderByArg
      > &
        InputErrors,
    ): {} extends InputErrors
      ? GetPreferenciasNotificacionGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the PreferenciasNotificacion model
     */
    readonly fields: PreferenciasNotificacionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PreferenciasNotificacion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PreferenciasNotificacionClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the PreferenciasNotificacion model
   */
  interface PreferenciasNotificacionFieldRefs {
    readonly id: FieldRef<'PreferenciasNotificacion', 'Int'>;
    readonly usuarioId: FieldRef<'PreferenciasNotificacion', 'Int'>;
    readonly nuevaResena: FieldRef<'PreferenciasNotificacion', 'Boolean'>;
    readonly respuestaResena: FieldRef<'PreferenciasNotificacion', 'Boolean'>;
    readonly actualizacionesSistema: FieldRef<
      'PreferenciasNotificacion',
      'Boolean'
    >;
    readonly mantenimiento: FieldRef<'PreferenciasNotificacion', 'Boolean'>;
    readonly reporteContenido: FieldRef<'PreferenciasNotificacion', 'Boolean'>;
    readonly contenidoPendiente: FieldRef<
      'PreferenciasNotificacion',
      'Boolean'
    >;
    readonly resumenDiario: FieldRef<'PreferenciasNotificacion', 'Boolean'>;
    readonly notificacionesInstantaneas: FieldRef<
      'PreferenciasNotificacion',
      'Boolean'
    >;
    readonly creadoEn: FieldRef<'PreferenciasNotificacion', 'DateTime'>;
    readonly actualizadoEn: FieldRef<'PreferenciasNotificacion', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * PreferenciasNotificacion findUnique
   */
  export type PreferenciasNotificacionFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PreferenciasNotificacion
     */
    select?: PreferenciasNotificacionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PreferenciasNotificacion
     */
    omit?: PreferenciasNotificacionOmit<ExtArgs> | null;
    /**
     * Filter, which PreferenciasNotificacion to fetch.
     */
    where: PreferenciasNotificacionWhereUniqueInput;
  };

  /**
   * PreferenciasNotificacion findUniqueOrThrow
   */
  export type PreferenciasNotificacionFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PreferenciasNotificacion
     */
    select?: PreferenciasNotificacionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PreferenciasNotificacion
     */
    omit?: PreferenciasNotificacionOmit<ExtArgs> | null;
    /**
     * Filter, which PreferenciasNotificacion to fetch.
     */
    where: PreferenciasNotificacionWhereUniqueInput;
  };

  /**
   * PreferenciasNotificacion findFirst
   */
  export type PreferenciasNotificacionFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PreferenciasNotificacion
     */
    select?: PreferenciasNotificacionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PreferenciasNotificacion
     */
    omit?: PreferenciasNotificacionOmit<ExtArgs> | null;
    /**
     * Filter, which PreferenciasNotificacion to fetch.
     */
    where?: PreferenciasNotificacionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PreferenciasNotificacions to fetch.
     */
    orderBy?:
      | PreferenciasNotificacionOrderByWithRelationInput
      | PreferenciasNotificacionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for PreferenciasNotificacions.
     */
    cursor?: PreferenciasNotificacionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PreferenciasNotificacions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PreferenciasNotificacions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of PreferenciasNotificacions.
     */
    distinct?:
      | PreferenciasNotificacionScalarFieldEnum
      | PreferenciasNotificacionScalarFieldEnum[];
  };

  /**
   * PreferenciasNotificacion findFirstOrThrow
   */
  export type PreferenciasNotificacionFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PreferenciasNotificacion
     */
    select?: PreferenciasNotificacionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PreferenciasNotificacion
     */
    omit?: PreferenciasNotificacionOmit<ExtArgs> | null;
    /**
     * Filter, which PreferenciasNotificacion to fetch.
     */
    where?: PreferenciasNotificacionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PreferenciasNotificacions to fetch.
     */
    orderBy?:
      | PreferenciasNotificacionOrderByWithRelationInput
      | PreferenciasNotificacionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for PreferenciasNotificacions.
     */
    cursor?: PreferenciasNotificacionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PreferenciasNotificacions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PreferenciasNotificacions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of PreferenciasNotificacions.
     */
    distinct?:
      | PreferenciasNotificacionScalarFieldEnum
      | PreferenciasNotificacionScalarFieldEnum[];
  };

  /**
   * PreferenciasNotificacion findMany
   */
  export type PreferenciasNotificacionFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PreferenciasNotificacion
     */
    select?: PreferenciasNotificacionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PreferenciasNotificacion
     */
    omit?: PreferenciasNotificacionOmit<ExtArgs> | null;
    /**
     * Filter, which PreferenciasNotificacions to fetch.
     */
    where?: PreferenciasNotificacionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PreferenciasNotificacions to fetch.
     */
    orderBy?:
      | PreferenciasNotificacionOrderByWithRelationInput
      | PreferenciasNotificacionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing PreferenciasNotificacions.
     */
    cursor?: PreferenciasNotificacionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PreferenciasNotificacions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PreferenciasNotificacions.
     */
    skip?: number;
    distinct?:
      | PreferenciasNotificacionScalarFieldEnum
      | PreferenciasNotificacionScalarFieldEnum[];
  };

  /**
   * PreferenciasNotificacion create
   */
  export type PreferenciasNotificacionCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PreferenciasNotificacion
     */
    select?: PreferenciasNotificacionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PreferenciasNotificacion
     */
    omit?: PreferenciasNotificacionOmit<ExtArgs> | null;
    /**
     * The data needed to create a PreferenciasNotificacion.
     */
    data: XOR<
      PreferenciasNotificacionCreateInput,
      PreferenciasNotificacionUncheckedCreateInput
    >;
  };

  /**
   * PreferenciasNotificacion createMany
   */
  export type PreferenciasNotificacionCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many PreferenciasNotificacions.
     */
    data:
      | PreferenciasNotificacionCreateManyInput
      | PreferenciasNotificacionCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * PreferenciasNotificacion update
   */
  export type PreferenciasNotificacionUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PreferenciasNotificacion
     */
    select?: PreferenciasNotificacionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PreferenciasNotificacion
     */
    omit?: PreferenciasNotificacionOmit<ExtArgs> | null;
    /**
     * The data needed to update a PreferenciasNotificacion.
     */
    data: XOR<
      PreferenciasNotificacionUpdateInput,
      PreferenciasNotificacionUncheckedUpdateInput
    >;
    /**
     * Choose, which PreferenciasNotificacion to update.
     */
    where: PreferenciasNotificacionWhereUniqueInput;
  };

  /**
   * PreferenciasNotificacion updateMany
   */
  export type PreferenciasNotificacionUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update PreferenciasNotificacions.
     */
    data: XOR<
      PreferenciasNotificacionUpdateManyMutationInput,
      PreferenciasNotificacionUncheckedUpdateManyInput
    >;
    /**
     * Filter which PreferenciasNotificacions to update
     */
    where?: PreferenciasNotificacionWhereInput;
    /**
     * Limit how many PreferenciasNotificacions to update.
     */
    limit?: number;
  };

  /**
   * PreferenciasNotificacion upsert
   */
  export type PreferenciasNotificacionUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PreferenciasNotificacion
     */
    select?: PreferenciasNotificacionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PreferenciasNotificacion
     */
    omit?: PreferenciasNotificacionOmit<ExtArgs> | null;
    /**
     * The filter to search for the PreferenciasNotificacion to update in case it exists.
     */
    where: PreferenciasNotificacionWhereUniqueInput;
    /**
     * In case the PreferenciasNotificacion found by the `where` argument doesn't exist, create a new PreferenciasNotificacion with this data.
     */
    create: XOR<
      PreferenciasNotificacionCreateInput,
      PreferenciasNotificacionUncheckedCreateInput
    >;
    /**
     * In case the PreferenciasNotificacion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      PreferenciasNotificacionUpdateInput,
      PreferenciasNotificacionUncheckedUpdateInput
    >;
  };

  /**
   * PreferenciasNotificacion delete
   */
  export type PreferenciasNotificacionDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PreferenciasNotificacion
     */
    select?: PreferenciasNotificacionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PreferenciasNotificacion
     */
    omit?: PreferenciasNotificacionOmit<ExtArgs> | null;
    /**
     * Filter which PreferenciasNotificacion to delete.
     */
    where: PreferenciasNotificacionWhereUniqueInput;
  };

  /**
   * PreferenciasNotificacion deleteMany
   */
  export type PreferenciasNotificacionDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which PreferenciasNotificacions to delete
     */
    where?: PreferenciasNotificacionWhereInput;
    /**
     * Limit how many PreferenciasNotificacions to delete.
     */
    limit?: number;
  };

  /**
   * PreferenciasNotificacion without action
   */
  export type PreferenciasNotificacionDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PreferenciasNotificacion
     */
    select?: PreferenciasNotificacionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PreferenciasNotificacion
     */
    omit?: PreferenciasNotificacionOmit<ExtArgs> | null;
  };

  /**
   * Model ResenaBorrador
   */

  export type AggregateResenaBorrador = {
    _count: ResenaBorradorCountAggregateOutputType | null;
    _avg: ResenaBorradorAvgAggregateOutputType | null;
    _sum: ResenaBorradorSumAggregateOutputType | null;
    _min: ResenaBorradorMinAggregateOutputType | null;
    _max: ResenaBorradorMaxAggregateOutputType | null;
  };

  export type ResenaBorradorAvgAggregateOutputType = {
    id: number | null;
    usuarioId: number | null;
    cursoId: number | null;
    productoId: number | null;
    puntaje: number | null;
  };

  export type ResenaBorradorSumAggregateOutputType = {
    id: number | null;
    usuarioId: number | null;
    cursoId: number | null;
    productoId: number | null;
    puntaje: number | null;
  };

  export type ResenaBorradorMinAggregateOutputType = {
    id: number | null;
    usuarioId: number | null;
    cursoId: number | null;
    productoId: number | null;
    puntaje: number | null;
    comentario: string | null;
    creadoEn: Date | null;
    actualizadoEn: Date | null;
  };

  export type ResenaBorradorMaxAggregateOutputType = {
    id: number | null;
    usuarioId: number | null;
    cursoId: number | null;
    productoId: number | null;
    puntaje: number | null;
    comentario: string | null;
    creadoEn: Date | null;
    actualizadoEn: Date | null;
  };

  export type ResenaBorradorCountAggregateOutputType = {
    id: number;
    usuarioId: number;
    cursoId: number;
    productoId: number;
    puntaje: number;
    comentario: number;
    creadoEn: number;
    actualizadoEn: number;
    _all: number;
  };

  export type ResenaBorradorAvgAggregateInputType = {
    id?: true;
    usuarioId?: true;
    cursoId?: true;
    productoId?: true;
    puntaje?: true;
  };

  export type ResenaBorradorSumAggregateInputType = {
    id?: true;
    usuarioId?: true;
    cursoId?: true;
    productoId?: true;
    puntaje?: true;
  };

  export type ResenaBorradorMinAggregateInputType = {
    id?: true;
    usuarioId?: true;
    cursoId?: true;
    productoId?: true;
    puntaje?: true;
    comentario?: true;
    creadoEn?: true;
    actualizadoEn?: true;
  };

  export type ResenaBorradorMaxAggregateInputType = {
    id?: true;
    usuarioId?: true;
    cursoId?: true;
    productoId?: true;
    puntaje?: true;
    comentario?: true;
    creadoEn?: true;
    actualizadoEn?: true;
  };

  export type ResenaBorradorCountAggregateInputType = {
    id?: true;
    usuarioId?: true;
    cursoId?: true;
    productoId?: true;
    puntaje?: true;
    comentario?: true;
    creadoEn?: true;
    actualizadoEn?: true;
    _all?: true;
  };

  export type ResenaBorradorAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ResenaBorrador to aggregate.
     */
    where?: ResenaBorradorWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ResenaBorradors to fetch.
     */
    orderBy?:
      | ResenaBorradorOrderByWithRelationInput
      | ResenaBorradorOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ResenaBorradorWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ResenaBorradors from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ResenaBorradors.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned ResenaBorradors
     **/
    _count?: true | ResenaBorradorCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ResenaBorradorAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ResenaBorradorSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ResenaBorradorMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ResenaBorradorMaxAggregateInputType;
  };

  export type GetResenaBorradorAggregateType<
    T extends ResenaBorradorAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateResenaBorrador]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResenaBorrador[P]>
      : GetScalarType<T[P], AggregateResenaBorrador[P]>;
  };

  export type ResenaBorradorGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ResenaBorradorWhereInput;
    orderBy?:
      | ResenaBorradorOrderByWithAggregationInput
      | ResenaBorradorOrderByWithAggregationInput[];
    by: ResenaBorradorScalarFieldEnum[] | ResenaBorradorScalarFieldEnum;
    having?: ResenaBorradorScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ResenaBorradorCountAggregateInputType | true;
    _avg?: ResenaBorradorAvgAggregateInputType;
    _sum?: ResenaBorradorSumAggregateInputType;
    _min?: ResenaBorradorMinAggregateInputType;
    _max?: ResenaBorradorMaxAggregateInputType;
  };

  export type ResenaBorradorGroupByOutputType = {
    id: number;
    usuarioId: number;
    cursoId: number | null;
    productoId: number | null;
    puntaje: number | null;
    comentario: string | null;
    creadoEn: Date;
    actualizadoEn: Date;
    _count: ResenaBorradorCountAggregateOutputType | null;
    _avg: ResenaBorradorAvgAggregateOutputType | null;
    _sum: ResenaBorradorSumAggregateOutputType | null;
    _min: ResenaBorradorMinAggregateOutputType | null;
    _max: ResenaBorradorMaxAggregateOutputType | null;
  };

  type GetResenaBorradorGroupByPayload<T extends ResenaBorradorGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ResenaBorradorGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof ResenaBorradorGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResenaBorradorGroupByOutputType[P]>
            : GetScalarType<T[P], ResenaBorradorGroupByOutputType[P]>;
        }
      >
    >;

  export type ResenaBorradorSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      usuarioId?: boolean;
      cursoId?: boolean;
      productoId?: boolean;
      puntaje?: boolean;
      comentario?: boolean;
      creadoEn?: boolean;
      actualizadoEn?: boolean;
    },
    ExtArgs['result']['resenaBorrador']
  >;

  export type ResenaBorradorSelectScalar = {
    id?: boolean;
    usuarioId?: boolean;
    cursoId?: boolean;
    productoId?: boolean;
    puntaje?: boolean;
    comentario?: boolean;
    creadoEn?: boolean;
    actualizadoEn?: boolean;
  };

  export type ResenaBorradorOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'usuarioId'
    | 'cursoId'
    | 'productoId'
    | 'puntaje'
    | 'comentario'
    | 'creadoEn'
    | 'actualizadoEn',
    ExtArgs['result']['resenaBorrador']
  >;

  export type $ResenaBorradorPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'ResenaBorrador';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        usuarioId: number;
        cursoId: number | null;
        productoId: number | null;
        puntaje: number | null;
        comentario: string | null;
        creadoEn: Date;
        actualizadoEn: Date;
      },
      ExtArgs['result']['resenaBorrador']
    >;
    composites: {};
  };

  type ResenaBorradorGetPayload<
    S extends boolean | null | undefined | ResenaBorradorDefaultArgs,
  > = $Result.GetResult<Prisma.$ResenaBorradorPayload, S>;

  type ResenaBorradorCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    ResenaBorradorFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: ResenaBorradorCountAggregateInputType | true;
  };

  export interface ResenaBorradorDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['ResenaBorrador'];
      meta: { name: 'ResenaBorrador' };
    };
    /**
     * Find zero or one ResenaBorrador that matches the filter.
     * @param {ResenaBorradorFindUniqueArgs} args - Arguments to find a ResenaBorrador
     * @example
     * // Get one ResenaBorrador
     * const resenaBorrador = await prisma.resenaBorrador.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResenaBorradorFindUniqueArgs>(
      args: SelectSubset<T, ResenaBorradorFindUniqueArgs<ExtArgs>>,
    ): Prisma__ResenaBorradorClient<
      $Result.GetResult<
        Prisma.$ResenaBorradorPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one ResenaBorrador that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ResenaBorradorFindUniqueOrThrowArgs} args - Arguments to find a ResenaBorrador
     * @example
     * // Get one ResenaBorrador
     * const resenaBorrador = await prisma.resenaBorrador.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResenaBorradorFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ResenaBorradorFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__ResenaBorradorClient<
      $Result.GetResult<
        Prisma.$ResenaBorradorPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ResenaBorrador that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResenaBorradorFindFirstArgs} args - Arguments to find a ResenaBorrador
     * @example
     * // Get one ResenaBorrador
     * const resenaBorrador = await prisma.resenaBorrador.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResenaBorradorFindFirstArgs>(
      args?: SelectSubset<T, ResenaBorradorFindFirstArgs<ExtArgs>>,
    ): Prisma__ResenaBorradorClient<
      $Result.GetResult<
        Prisma.$ResenaBorradorPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ResenaBorrador that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResenaBorradorFindFirstOrThrowArgs} args - Arguments to find a ResenaBorrador
     * @example
     * // Get one ResenaBorrador
     * const resenaBorrador = await prisma.resenaBorrador.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResenaBorradorFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ResenaBorradorFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__ResenaBorradorClient<
      $Result.GetResult<
        Prisma.$ResenaBorradorPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more ResenaBorradors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResenaBorradorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ResenaBorradors
     * const resenaBorradors = await prisma.resenaBorrador.findMany()
     *
     * // Get first 10 ResenaBorradors
     * const resenaBorradors = await prisma.resenaBorrador.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const resenaBorradorWithIdOnly = await prisma.resenaBorrador.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ResenaBorradorFindManyArgs>(
      args?: SelectSubset<T, ResenaBorradorFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ResenaBorradorPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a ResenaBorrador.
     * @param {ResenaBorradorCreateArgs} args - Arguments to create a ResenaBorrador.
     * @example
     * // Create one ResenaBorrador
     * const ResenaBorrador = await prisma.resenaBorrador.create({
     *   data: {
     *     // ... data to create a ResenaBorrador
     *   }
     * })
     *
     */
    create<T extends ResenaBorradorCreateArgs>(
      args: SelectSubset<T, ResenaBorradorCreateArgs<ExtArgs>>,
    ): Prisma__ResenaBorradorClient<
      $Result.GetResult<
        Prisma.$ResenaBorradorPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many ResenaBorradors.
     * @param {ResenaBorradorCreateManyArgs} args - Arguments to create many ResenaBorradors.
     * @example
     * // Create many ResenaBorradors
     * const resenaBorrador = await prisma.resenaBorrador.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ResenaBorradorCreateManyArgs>(
      args?: SelectSubset<T, ResenaBorradorCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a ResenaBorrador.
     * @param {ResenaBorradorDeleteArgs} args - Arguments to delete one ResenaBorrador.
     * @example
     * // Delete one ResenaBorrador
     * const ResenaBorrador = await prisma.resenaBorrador.delete({
     *   where: {
     *     // ... filter to delete one ResenaBorrador
     *   }
     * })
     *
     */
    delete<T extends ResenaBorradorDeleteArgs>(
      args: SelectSubset<T, ResenaBorradorDeleteArgs<ExtArgs>>,
    ): Prisma__ResenaBorradorClient<
      $Result.GetResult<
        Prisma.$ResenaBorradorPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one ResenaBorrador.
     * @param {ResenaBorradorUpdateArgs} args - Arguments to update one ResenaBorrador.
     * @example
     * // Update one ResenaBorrador
     * const resenaBorrador = await prisma.resenaBorrador.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ResenaBorradorUpdateArgs>(
      args: SelectSubset<T, ResenaBorradorUpdateArgs<ExtArgs>>,
    ): Prisma__ResenaBorradorClient<
      $Result.GetResult<
        Prisma.$ResenaBorradorPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more ResenaBorradors.
     * @param {ResenaBorradorDeleteManyArgs} args - Arguments to filter ResenaBorradors to delete.
     * @example
     * // Delete a few ResenaBorradors
     * const { count } = await prisma.resenaBorrador.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ResenaBorradorDeleteManyArgs>(
      args?: SelectSubset<T, ResenaBorradorDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ResenaBorradors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResenaBorradorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ResenaBorradors
     * const resenaBorrador = await prisma.resenaBorrador.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ResenaBorradorUpdateManyArgs>(
      args: SelectSubset<T, ResenaBorradorUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one ResenaBorrador.
     * @param {ResenaBorradorUpsertArgs} args - Arguments to update or create a ResenaBorrador.
     * @example
     * // Update or create a ResenaBorrador
     * const resenaBorrador = await prisma.resenaBorrador.upsert({
     *   create: {
     *     // ... data to create a ResenaBorrador
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ResenaBorrador we want to update
     *   }
     * })
     */
    upsert<T extends ResenaBorradorUpsertArgs>(
      args: SelectSubset<T, ResenaBorradorUpsertArgs<ExtArgs>>,
    ): Prisma__ResenaBorradorClient<
      $Result.GetResult<
        Prisma.$ResenaBorradorPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of ResenaBorradors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResenaBorradorCountArgs} args - Arguments to filter ResenaBorradors to count.
     * @example
     * // Count the number of ResenaBorradors
     * const count = await prisma.resenaBorrador.count({
     *   where: {
     *     // ... the filter for the ResenaBorradors we want to count
     *   }
     * })
     **/
    count<T extends ResenaBorradorCountArgs>(
      args?: Subset<T, ResenaBorradorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResenaBorradorCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a ResenaBorrador.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResenaBorradorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ResenaBorradorAggregateArgs>(
      args: Subset<T, ResenaBorradorAggregateArgs>,
    ): Prisma.PrismaPromise<GetResenaBorradorAggregateType<T>>;

    /**
     * Group by ResenaBorrador.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResenaBorradorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ResenaBorradorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResenaBorradorGroupByArgs['orderBy'] }
        : { orderBy?: ResenaBorradorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ResenaBorradorGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetResenaBorradorGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the ResenaBorrador model
     */
    readonly fields: ResenaBorradorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ResenaBorrador.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResenaBorradorClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the ResenaBorrador model
   */
  interface ResenaBorradorFieldRefs {
    readonly id: FieldRef<'ResenaBorrador', 'Int'>;
    readonly usuarioId: FieldRef<'ResenaBorrador', 'Int'>;
    readonly cursoId: FieldRef<'ResenaBorrador', 'Int'>;
    readonly productoId: FieldRef<'ResenaBorrador', 'Int'>;
    readonly puntaje: FieldRef<'ResenaBorrador', 'Int'>;
    readonly comentario: FieldRef<'ResenaBorrador', 'String'>;
    readonly creadoEn: FieldRef<'ResenaBorrador', 'DateTime'>;
    readonly actualizadoEn: FieldRef<'ResenaBorrador', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * ResenaBorrador findUnique
   */
  export type ResenaBorradorFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ResenaBorrador
     */
    select?: ResenaBorradorSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ResenaBorrador
     */
    omit?: ResenaBorradorOmit<ExtArgs> | null;
    /**
     * Filter, which ResenaBorrador to fetch.
     */
    where: ResenaBorradorWhereUniqueInput;
  };

  /**
   * ResenaBorrador findUniqueOrThrow
   */
  export type ResenaBorradorFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ResenaBorrador
     */
    select?: ResenaBorradorSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ResenaBorrador
     */
    omit?: ResenaBorradorOmit<ExtArgs> | null;
    /**
     * Filter, which ResenaBorrador to fetch.
     */
    where: ResenaBorradorWhereUniqueInput;
  };

  /**
   * ResenaBorrador findFirst
   */
  export type ResenaBorradorFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ResenaBorrador
     */
    select?: ResenaBorradorSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ResenaBorrador
     */
    omit?: ResenaBorradorOmit<ExtArgs> | null;
    /**
     * Filter, which ResenaBorrador to fetch.
     */
    where?: ResenaBorradorWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ResenaBorradors to fetch.
     */
    orderBy?:
      | ResenaBorradorOrderByWithRelationInput
      | ResenaBorradorOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ResenaBorradors.
     */
    cursor?: ResenaBorradorWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ResenaBorradors from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ResenaBorradors.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ResenaBorradors.
     */
    distinct?: ResenaBorradorScalarFieldEnum | ResenaBorradorScalarFieldEnum[];
  };

  /**
   * ResenaBorrador findFirstOrThrow
   */
  export type ResenaBorradorFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ResenaBorrador
     */
    select?: ResenaBorradorSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ResenaBorrador
     */
    omit?: ResenaBorradorOmit<ExtArgs> | null;
    /**
     * Filter, which ResenaBorrador to fetch.
     */
    where?: ResenaBorradorWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ResenaBorradors to fetch.
     */
    orderBy?:
      | ResenaBorradorOrderByWithRelationInput
      | ResenaBorradorOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ResenaBorradors.
     */
    cursor?: ResenaBorradorWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ResenaBorradors from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ResenaBorradors.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ResenaBorradors.
     */
    distinct?: ResenaBorradorScalarFieldEnum | ResenaBorradorScalarFieldEnum[];
  };

  /**
   * ResenaBorrador findMany
   */
  export type ResenaBorradorFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ResenaBorrador
     */
    select?: ResenaBorradorSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ResenaBorrador
     */
    omit?: ResenaBorradorOmit<ExtArgs> | null;
    /**
     * Filter, which ResenaBorradors to fetch.
     */
    where?: ResenaBorradorWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ResenaBorradors to fetch.
     */
    orderBy?:
      | ResenaBorradorOrderByWithRelationInput
      | ResenaBorradorOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing ResenaBorradors.
     */
    cursor?: ResenaBorradorWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ResenaBorradors from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ResenaBorradors.
     */
    skip?: number;
    distinct?: ResenaBorradorScalarFieldEnum | ResenaBorradorScalarFieldEnum[];
  };

  /**
   * ResenaBorrador create
   */
  export type ResenaBorradorCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ResenaBorrador
     */
    select?: ResenaBorradorSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ResenaBorrador
     */
    omit?: ResenaBorradorOmit<ExtArgs> | null;
    /**
     * The data needed to create a ResenaBorrador.
     */
    data: XOR<ResenaBorradorCreateInput, ResenaBorradorUncheckedCreateInput>;
  };

  /**
   * ResenaBorrador createMany
   */
  export type ResenaBorradorCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many ResenaBorradors.
     */
    data: ResenaBorradorCreateManyInput | ResenaBorradorCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * ResenaBorrador update
   */
  export type ResenaBorradorUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ResenaBorrador
     */
    select?: ResenaBorradorSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ResenaBorrador
     */
    omit?: ResenaBorradorOmit<ExtArgs> | null;
    /**
     * The data needed to update a ResenaBorrador.
     */
    data: XOR<ResenaBorradorUpdateInput, ResenaBorradorUncheckedUpdateInput>;
    /**
     * Choose, which ResenaBorrador to update.
     */
    where: ResenaBorradorWhereUniqueInput;
  };

  /**
   * ResenaBorrador updateMany
   */
  export type ResenaBorradorUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update ResenaBorradors.
     */
    data: XOR<
      ResenaBorradorUpdateManyMutationInput,
      ResenaBorradorUncheckedUpdateManyInput
    >;
    /**
     * Filter which ResenaBorradors to update
     */
    where?: ResenaBorradorWhereInput;
    /**
     * Limit how many ResenaBorradors to update.
     */
    limit?: number;
  };

  /**
   * ResenaBorrador upsert
   */
  export type ResenaBorradorUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ResenaBorrador
     */
    select?: ResenaBorradorSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ResenaBorrador
     */
    omit?: ResenaBorradorOmit<ExtArgs> | null;
    /**
     * The filter to search for the ResenaBorrador to update in case it exists.
     */
    where: ResenaBorradorWhereUniqueInput;
    /**
     * In case the ResenaBorrador found by the `where` argument doesn't exist, create a new ResenaBorrador with this data.
     */
    create: XOR<ResenaBorradorCreateInput, ResenaBorradorUncheckedCreateInput>;
    /**
     * In case the ResenaBorrador was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResenaBorradorUpdateInput, ResenaBorradorUncheckedUpdateInput>;
  };

  /**
   * ResenaBorrador delete
   */
  export type ResenaBorradorDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ResenaBorrador
     */
    select?: ResenaBorradorSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ResenaBorrador
     */
    omit?: ResenaBorradorOmit<ExtArgs> | null;
    /**
     * Filter which ResenaBorrador to delete.
     */
    where: ResenaBorradorWhereUniqueInput;
  };

  /**
   * ResenaBorrador deleteMany
   */
  export type ResenaBorradorDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ResenaBorradors to delete
     */
    where?: ResenaBorradorWhereInput;
    /**
     * Limit how many ResenaBorradors to delete.
     */
    limit?: number;
  };

  /**
   * ResenaBorrador without action
   */
  export type ResenaBorradorDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ResenaBorrador
     */
    select?: ResenaBorradorSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ResenaBorrador
     */
    omit?: ResenaBorradorOmit<ExtArgs> | null;
  };

  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null;
    _avg: AuditLogAvgAggregateOutputType | null;
    _sum: AuditLogSumAggregateOutputType | null;
    _min: AuditLogMinAggregateOutputType | null;
    _max: AuditLogMaxAggregateOutputType | null;
  };

  export type AuditLogAvgAggregateOutputType = {
    id: number | null;
    userId: number | null;
  };

  export type AuditLogSumAggregateOutputType = {
    id: number | null;
    userId: number | null;
  };

  export type AuditLogMinAggregateOutputType = {
    id: number | null;
    tableName: string | null;
    recordId: string | null;
    action: string | null;
    userId: number | null;
    userAgent: string | null;
    ipAddress: string | null;
    endpoint: string | null;
    timestamp: Date | null;
  };

  export type AuditLogMaxAggregateOutputType = {
    id: number | null;
    tableName: string | null;
    recordId: string | null;
    action: string | null;
    userId: number | null;
    userAgent: string | null;
    ipAddress: string | null;
    endpoint: string | null;
    timestamp: Date | null;
  };

  export type AuditLogCountAggregateOutputType = {
    id: number;
    tableName: number;
    recordId: number;
    action: number;
    oldData: number;
    newData: number;
    userId: number;
    userAgent: number;
    ipAddress: number;
    endpoint: number;
    timestamp: number;
    _all: number;
  };

  export type AuditLogAvgAggregateInputType = {
    id?: true;
    userId?: true;
  };

  export type AuditLogSumAggregateInputType = {
    id?: true;
    userId?: true;
  };

  export type AuditLogMinAggregateInputType = {
    id?: true;
    tableName?: true;
    recordId?: true;
    action?: true;
    userId?: true;
    userAgent?: true;
    ipAddress?: true;
    endpoint?: true;
    timestamp?: true;
  };

  export type AuditLogMaxAggregateInputType = {
    id?: true;
    tableName?: true;
    recordId?: true;
    action?: true;
    userId?: true;
    userAgent?: true;
    ipAddress?: true;
    endpoint?: true;
    timestamp?: true;
  };

  export type AuditLogCountAggregateInputType = {
    id?: true;
    tableName?: true;
    recordId?: true;
    action?: true;
    oldData?: true;
    newData?: true;
    userId?: true;
    userAgent?: true;
    ipAddress?: true;
    endpoint?: true;
    timestamp?: true;
    _all?: true;
  };

  export type AuditLogAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?:
      | AuditLogOrderByWithRelationInput
      | AuditLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AuditLogs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned AuditLogs
     **/
    _count?: true | AuditLogCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: AuditLogAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: AuditLogSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: AuditLogMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: AuditLogMaxAggregateInputType;
  };

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
    [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>;
  };

  export type AuditLogGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AuditLogWhereInput;
    orderBy?:
      | AuditLogOrderByWithAggregationInput
      | AuditLogOrderByWithAggregationInput[];
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum;
    having?: AuditLogScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: AuditLogCountAggregateInputType | true;
    _avg?: AuditLogAvgAggregateInputType;
    _sum?: AuditLogSumAggregateInputType;
    _min?: AuditLogMinAggregateInputType;
    _max?: AuditLogMaxAggregateInputType;
  };

  export type AuditLogGroupByOutputType = {
    id: number;
    tableName: string;
    recordId: string;
    action: string;
    oldData: JsonValue | null;
    newData: JsonValue | null;
    userId: number;
    userAgent: string | null;
    ipAddress: string | null;
    endpoint: string | null;
    timestamp: Date;
    _count: AuditLogCountAggregateOutputType | null;
    _avg: AuditLogAvgAggregateOutputType | null;
    _sum: AuditLogSumAggregateOutputType | null;
    _min: AuditLogMinAggregateOutputType | null;
    _max: AuditLogMaxAggregateOutputType | null;
  };

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<AuditLogGroupByOutputType, T['by']> & {
          [P in keyof T & keyof AuditLogGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>;
        }
      >
    >;

  export type AuditLogSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      tableName?: boolean;
      recordId?: boolean;
      action?: boolean;
      oldData?: boolean;
      newData?: boolean;
      userId?: boolean;
      userAgent?: boolean;
      ipAddress?: boolean;
      endpoint?: boolean;
      timestamp?: boolean;
      user?: boolean | UsuarioDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['auditLog']
  >;

  export type AuditLogSelectScalar = {
    id?: boolean;
    tableName?: boolean;
    recordId?: boolean;
    action?: boolean;
    oldData?: boolean;
    newData?: boolean;
    userId?: boolean;
    userAgent?: boolean;
    ipAddress?: boolean;
    endpoint?: boolean;
    timestamp?: boolean;
  };

  export type AuditLogOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'tableName'
    | 'recordId'
    | 'action'
    | 'oldData'
    | 'newData'
    | 'userId'
    | 'userAgent'
    | 'ipAddress'
    | 'endpoint'
    | 'timestamp',
    ExtArgs['result']['auditLog']
  >;
  export type AuditLogInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UsuarioDefaultArgs<ExtArgs>;
  };

  export type $AuditLogPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'AuditLog';
    objects: {
      user: Prisma.$UsuarioPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        tableName: string;
        recordId: string;
        action: string;
        oldData: Prisma.JsonValue | null;
        newData: Prisma.JsonValue | null;
        userId: number;
        userAgent: string | null;
        ipAddress: string | null;
        endpoint: string | null;
        timestamp: Date;
      },
      ExtArgs['result']['auditLog']
    >;
    composites: {};
  };

  type AuditLogGetPayload<
    S extends boolean | null | undefined | AuditLogDefaultArgs,
  > = $Result.GetResult<Prisma.$AuditLogPayload, S>;

  type AuditLogCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: AuditLogCountAggregateInputType | true;
  };

  export interface AuditLogDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'];
      meta: { name: 'AuditLog' };
    };
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(
      args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>,
    ): Prisma__AuditLogClient<
      $Result.GetResult<
        Prisma.$AuditLogPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(
      args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__AuditLogClient<
      $Result.GetResult<
        Prisma.$AuditLogPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(
      args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>,
    ): Prisma__AuditLogClient<
      $Result.GetResult<
        Prisma.$AuditLogPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__AuditLogClient<
      $Result.GetResult<
        Prisma.$AuditLogPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     *
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     *
     */
    findMany<T extends AuditLogFindManyArgs>(
      args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AuditLogPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     *
     */
    create<T extends AuditLogCreateArgs>(
      args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>,
    ): Prisma__AuditLogClient<
      $Result.GetResult<
        Prisma.$AuditLogPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends AuditLogCreateManyArgs>(
      args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     *
     */
    delete<T extends AuditLogDeleteArgs>(
      args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>,
    ): Prisma__AuditLogClient<
      $Result.GetResult<
        Prisma.$AuditLogPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends AuditLogUpdateArgs>(
      args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>,
    ): Prisma__AuditLogClient<
      $Result.GetResult<
        Prisma.$AuditLogPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(
      args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends AuditLogUpdateManyArgs>(
      args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(
      args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>,
    ): Prisma__AuditLogClient<
      $Result.GetResult<
        Prisma.$AuditLogPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
     **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends AuditLogAggregateArgs>(
      args: Subset<T, AuditLogAggregateArgs>,
    ): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>;

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetAuditLogGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the AuditLog model
     */
    readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    user<T extends UsuarioDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>,
    ): Prisma__UsuarioClient<
      | $Result.GetResult<
          Prisma.$UsuarioPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<'AuditLog', 'Int'>;
    readonly tableName: FieldRef<'AuditLog', 'String'>;
    readonly recordId: FieldRef<'AuditLog', 'String'>;
    readonly action: FieldRef<'AuditLog', 'String'>;
    readonly oldData: FieldRef<'AuditLog', 'Json'>;
    readonly newData: FieldRef<'AuditLog', 'Json'>;
    readonly userId: FieldRef<'AuditLog', 'Int'>;
    readonly userAgent: FieldRef<'AuditLog', 'String'>;
    readonly ipAddress: FieldRef<'AuditLog', 'String'>;
    readonly endpoint: FieldRef<'AuditLog', 'String'>;
    readonly timestamp: FieldRef<'AuditLog', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput;
  };

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput;
  };

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?:
      | AuditLogOrderByWithRelationInput
      | AuditLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AuditLogs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[];
  };

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?:
      | AuditLogOrderByWithRelationInput
      | AuditLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AuditLogs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[];
  };

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?:
      | AuditLogOrderByWithRelationInput
      | AuditLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AuditLogs.
     */
    skip?: number;
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[];
  };

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>;
  };

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>;
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput;
  };

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<
      AuditLogUpdateManyMutationInput,
      AuditLogUncheckedUpdateManyInput
    >;
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput;
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number;
  };

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput;
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>;
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>;
  };

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput;
  };

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput;
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number;
  };

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
  };

  /**
   * Model Carrito
   */

  export type AggregateCarrito = {
    _count: CarritoCountAggregateOutputType | null;
    _avg: CarritoAvgAggregateOutputType | null;
    _sum: CarritoSumAggregateOutputType | null;
    _min: CarritoMinAggregateOutputType | null;
    _max: CarritoMaxAggregateOutputType | null;
  };

  export type CarritoAvgAggregateOutputType = {
    id: number | null;
    usuarioId: number | null;
  };

  export type CarritoSumAggregateOutputType = {
    id: number | null;
    usuarioId: number | null;
  };

  export type CarritoMinAggregateOutputType = {
    id: number | null;
    usuarioId: number | null;
    creadoEn: Date | null;
    actualizadoEn: Date | null;
  };

  export type CarritoMaxAggregateOutputType = {
    id: number | null;
    usuarioId: number | null;
    creadoEn: Date | null;
    actualizadoEn: Date | null;
  };

  export type CarritoCountAggregateOutputType = {
    id: number;
    usuarioId: number;
    creadoEn: number;
    actualizadoEn: number;
    _all: number;
  };

  export type CarritoAvgAggregateInputType = {
    id?: true;
    usuarioId?: true;
  };

  export type CarritoSumAggregateInputType = {
    id?: true;
    usuarioId?: true;
  };

  export type CarritoMinAggregateInputType = {
    id?: true;
    usuarioId?: true;
    creadoEn?: true;
    actualizadoEn?: true;
  };

  export type CarritoMaxAggregateInputType = {
    id?: true;
    usuarioId?: true;
    creadoEn?: true;
    actualizadoEn?: true;
  };

  export type CarritoCountAggregateInputType = {
    id?: true;
    usuarioId?: true;
    creadoEn?: true;
    actualizadoEn?: true;
    _all?: true;
  };

  export type CarritoAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Carrito to aggregate.
     */
    where?: CarritoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Carritos to fetch.
     */
    orderBy?:
      | CarritoOrderByWithRelationInput
      | CarritoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: CarritoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Carritos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Carritos.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Carritos
     **/
    _count?: true | CarritoCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: CarritoAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: CarritoSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: CarritoMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: CarritoMaxAggregateInputType;
  };

  export type GetCarritoAggregateType<T extends CarritoAggregateArgs> = {
    [P in keyof T & keyof AggregateCarrito]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCarrito[P]>
      : GetScalarType<T[P], AggregateCarrito[P]>;
  };

  export type CarritoGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: CarritoWhereInput;
    orderBy?:
      | CarritoOrderByWithAggregationInput
      | CarritoOrderByWithAggregationInput[];
    by: CarritoScalarFieldEnum[] | CarritoScalarFieldEnum;
    having?: CarritoScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: CarritoCountAggregateInputType | true;
    _avg?: CarritoAvgAggregateInputType;
    _sum?: CarritoSumAggregateInputType;
    _min?: CarritoMinAggregateInputType;
    _max?: CarritoMaxAggregateInputType;
  };

  export type CarritoGroupByOutputType = {
    id: number;
    usuarioId: number;
    creadoEn: Date;
    actualizadoEn: Date;
    _count: CarritoCountAggregateOutputType | null;
    _avg: CarritoAvgAggregateOutputType | null;
    _sum: CarritoSumAggregateOutputType | null;
    _min: CarritoMinAggregateOutputType | null;
    _max: CarritoMaxAggregateOutputType | null;
  };

  type GetCarritoGroupByPayload<T extends CarritoGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<CarritoGroupByOutputType, T['by']> & {
          [P in keyof T & keyof CarritoGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CarritoGroupByOutputType[P]>
            : GetScalarType<T[P], CarritoGroupByOutputType[P]>;
        }
      >
    >;

  export type CarritoSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      usuarioId?: boolean;
      creadoEn?: boolean;
      actualizadoEn?: boolean;
      usuario?: boolean | UsuarioDefaultArgs<ExtArgs>;
      items?: boolean | Carrito$itemsArgs<ExtArgs>;
      _count?: boolean | CarritoCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['carrito']
  >;

  export type CarritoSelectScalar = {
    id?: boolean;
    usuarioId?: boolean;
    creadoEn?: boolean;
    actualizadoEn?: boolean;
  };

  export type CarritoOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    'id' | 'usuarioId' | 'creadoEn' | 'actualizadoEn',
    ExtArgs['result']['carrito']
  >;
  export type CarritoInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>;
    items?: boolean | Carrito$itemsArgs<ExtArgs>;
    _count?: boolean | CarritoCountOutputTypeDefaultArgs<ExtArgs>;
  };

  export type $CarritoPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Carrito';
    objects: {
      usuario: Prisma.$UsuarioPayload<ExtArgs>;
      items: Prisma.$ItemCarritoPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        usuarioId: number;
        creadoEn: Date;
        actualizadoEn: Date;
      },
      ExtArgs['result']['carrito']
    >;
    composites: {};
  };

  type CarritoGetPayload<
    S extends boolean | null | undefined | CarritoDefaultArgs,
  > = $Result.GetResult<Prisma.$CarritoPayload, S>;

  type CarritoCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<CarritoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: CarritoCountAggregateInputType | true;
  };

  export interface CarritoDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Carrito'];
      meta: { name: 'Carrito' };
    };
    /**
     * Find zero or one Carrito that matches the filter.
     * @param {CarritoFindUniqueArgs} args - Arguments to find a Carrito
     * @example
     * // Get one Carrito
     * const carrito = await prisma.carrito.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CarritoFindUniqueArgs>(
      args: SelectSubset<T, CarritoFindUniqueArgs<ExtArgs>>,
    ): Prisma__CarritoClient<
      $Result.GetResult<
        Prisma.$CarritoPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Carrito that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CarritoFindUniqueOrThrowArgs} args - Arguments to find a Carrito
     * @example
     * // Get one Carrito
     * const carrito = await prisma.carrito.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CarritoFindUniqueOrThrowArgs>(
      args: SelectSubset<T, CarritoFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__CarritoClient<
      $Result.GetResult<
        Prisma.$CarritoPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Carrito that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarritoFindFirstArgs} args - Arguments to find a Carrito
     * @example
     * // Get one Carrito
     * const carrito = await prisma.carrito.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CarritoFindFirstArgs>(
      args?: SelectSubset<T, CarritoFindFirstArgs<ExtArgs>>,
    ): Prisma__CarritoClient<
      $Result.GetResult<
        Prisma.$CarritoPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Carrito that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarritoFindFirstOrThrowArgs} args - Arguments to find a Carrito
     * @example
     * // Get one Carrito
     * const carrito = await prisma.carrito.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CarritoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CarritoFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__CarritoClient<
      $Result.GetResult<
        Prisma.$CarritoPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Carritos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarritoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Carritos
     * const carritos = await prisma.carrito.findMany()
     *
     * // Get first 10 Carritos
     * const carritos = await prisma.carrito.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const carritoWithIdOnly = await prisma.carrito.findMany({ select: { id: true } })
     *
     */
    findMany<T extends CarritoFindManyArgs>(
      args?: SelectSubset<T, CarritoFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$CarritoPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Carrito.
     * @param {CarritoCreateArgs} args - Arguments to create a Carrito.
     * @example
     * // Create one Carrito
     * const Carrito = await prisma.carrito.create({
     *   data: {
     *     // ... data to create a Carrito
     *   }
     * })
     *
     */
    create<T extends CarritoCreateArgs>(
      args: SelectSubset<T, CarritoCreateArgs<ExtArgs>>,
    ): Prisma__CarritoClient<
      $Result.GetResult<
        Prisma.$CarritoPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Carritos.
     * @param {CarritoCreateManyArgs} args - Arguments to create many Carritos.
     * @example
     * // Create many Carritos
     * const carrito = await prisma.carrito.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends CarritoCreateManyArgs>(
      args?: SelectSubset<T, CarritoCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Carrito.
     * @param {CarritoDeleteArgs} args - Arguments to delete one Carrito.
     * @example
     * // Delete one Carrito
     * const Carrito = await prisma.carrito.delete({
     *   where: {
     *     // ... filter to delete one Carrito
     *   }
     * })
     *
     */
    delete<T extends CarritoDeleteArgs>(
      args: SelectSubset<T, CarritoDeleteArgs<ExtArgs>>,
    ): Prisma__CarritoClient<
      $Result.GetResult<
        Prisma.$CarritoPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Carrito.
     * @param {CarritoUpdateArgs} args - Arguments to update one Carrito.
     * @example
     * // Update one Carrito
     * const carrito = await prisma.carrito.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends CarritoUpdateArgs>(
      args: SelectSubset<T, CarritoUpdateArgs<ExtArgs>>,
    ): Prisma__CarritoClient<
      $Result.GetResult<
        Prisma.$CarritoPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Carritos.
     * @param {CarritoDeleteManyArgs} args - Arguments to filter Carritos to delete.
     * @example
     * // Delete a few Carritos
     * const { count } = await prisma.carrito.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends CarritoDeleteManyArgs>(
      args?: SelectSubset<T, CarritoDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Carritos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarritoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Carritos
     * const carrito = await prisma.carrito.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends CarritoUpdateManyArgs>(
      args: SelectSubset<T, CarritoUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Carrito.
     * @param {CarritoUpsertArgs} args - Arguments to update or create a Carrito.
     * @example
     * // Update or create a Carrito
     * const carrito = await prisma.carrito.upsert({
     *   create: {
     *     // ... data to create a Carrito
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Carrito we want to update
     *   }
     * })
     */
    upsert<T extends CarritoUpsertArgs>(
      args: SelectSubset<T, CarritoUpsertArgs<ExtArgs>>,
    ): Prisma__CarritoClient<
      $Result.GetResult<
        Prisma.$CarritoPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Carritos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarritoCountArgs} args - Arguments to filter Carritos to count.
     * @example
     * // Count the number of Carritos
     * const count = await prisma.carrito.count({
     *   where: {
     *     // ... the filter for the Carritos we want to count
     *   }
     * })
     **/
    count<T extends CarritoCountArgs>(
      args?: Subset<T, CarritoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CarritoCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Carrito.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarritoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends CarritoAggregateArgs>(
      args: Subset<T, CarritoAggregateArgs>,
    ): Prisma.PrismaPromise<GetCarritoAggregateType<T>>;

    /**
     * Group by Carrito.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarritoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends CarritoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CarritoGroupByArgs['orderBy'] }
        : { orderBy?: CarritoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, CarritoGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetCarritoGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Carrito model
     */
    readonly fields: CarritoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Carrito.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CarritoClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>,
    ): Prisma__UsuarioClient<
      | $Result.GetResult<
          Prisma.$UsuarioPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    items<T extends Carrito$itemsArgs<ExtArgs> = {}>(
      args?: Subset<T, Carrito$itemsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$ItemCarritoPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Carrito model
   */
  interface CarritoFieldRefs {
    readonly id: FieldRef<'Carrito', 'Int'>;
    readonly usuarioId: FieldRef<'Carrito', 'Int'>;
    readonly creadoEn: FieldRef<'Carrito', 'DateTime'>;
    readonly actualizadoEn: FieldRef<'Carrito', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Carrito findUnique
   */
  export type CarritoFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Carrito
     */
    select?: CarritoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Carrito
     */
    omit?: CarritoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarritoInclude<ExtArgs> | null;
    /**
     * Filter, which Carrito to fetch.
     */
    where: CarritoWhereUniqueInput;
  };

  /**
   * Carrito findUniqueOrThrow
   */
  export type CarritoFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Carrito
     */
    select?: CarritoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Carrito
     */
    omit?: CarritoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarritoInclude<ExtArgs> | null;
    /**
     * Filter, which Carrito to fetch.
     */
    where: CarritoWhereUniqueInput;
  };

  /**
   * Carrito findFirst
   */
  export type CarritoFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Carrito
     */
    select?: CarritoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Carrito
     */
    omit?: CarritoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarritoInclude<ExtArgs> | null;
    /**
     * Filter, which Carrito to fetch.
     */
    where?: CarritoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Carritos to fetch.
     */
    orderBy?:
      | CarritoOrderByWithRelationInput
      | CarritoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Carritos.
     */
    cursor?: CarritoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Carritos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Carritos.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Carritos.
     */
    distinct?: CarritoScalarFieldEnum | CarritoScalarFieldEnum[];
  };

  /**
   * Carrito findFirstOrThrow
   */
  export type CarritoFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Carrito
     */
    select?: CarritoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Carrito
     */
    omit?: CarritoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarritoInclude<ExtArgs> | null;
    /**
     * Filter, which Carrito to fetch.
     */
    where?: CarritoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Carritos to fetch.
     */
    orderBy?:
      | CarritoOrderByWithRelationInput
      | CarritoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Carritos.
     */
    cursor?: CarritoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Carritos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Carritos.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Carritos.
     */
    distinct?: CarritoScalarFieldEnum | CarritoScalarFieldEnum[];
  };

  /**
   * Carrito findMany
   */
  export type CarritoFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Carrito
     */
    select?: CarritoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Carrito
     */
    omit?: CarritoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarritoInclude<ExtArgs> | null;
    /**
     * Filter, which Carritos to fetch.
     */
    where?: CarritoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Carritos to fetch.
     */
    orderBy?:
      | CarritoOrderByWithRelationInput
      | CarritoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Carritos.
     */
    cursor?: CarritoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Carritos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Carritos.
     */
    skip?: number;
    distinct?: CarritoScalarFieldEnum | CarritoScalarFieldEnum[];
  };

  /**
   * Carrito create
   */
  export type CarritoCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Carrito
     */
    select?: CarritoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Carrito
     */
    omit?: CarritoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarritoInclude<ExtArgs> | null;
    /**
     * The data needed to create a Carrito.
     */
    data: XOR<CarritoCreateInput, CarritoUncheckedCreateInput>;
  };

  /**
   * Carrito createMany
   */
  export type CarritoCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Carritos.
     */
    data: CarritoCreateManyInput | CarritoCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Carrito update
   */
  export type CarritoUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Carrito
     */
    select?: CarritoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Carrito
     */
    omit?: CarritoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarritoInclude<ExtArgs> | null;
    /**
     * The data needed to update a Carrito.
     */
    data: XOR<CarritoUpdateInput, CarritoUncheckedUpdateInput>;
    /**
     * Choose, which Carrito to update.
     */
    where: CarritoWhereUniqueInput;
  };

  /**
   * Carrito updateMany
   */
  export type CarritoUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Carritos.
     */
    data: XOR<CarritoUpdateManyMutationInput, CarritoUncheckedUpdateManyInput>;
    /**
     * Filter which Carritos to update
     */
    where?: CarritoWhereInput;
    /**
     * Limit how many Carritos to update.
     */
    limit?: number;
  };

  /**
   * Carrito upsert
   */
  export type CarritoUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Carrito
     */
    select?: CarritoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Carrito
     */
    omit?: CarritoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarritoInclude<ExtArgs> | null;
    /**
     * The filter to search for the Carrito to update in case it exists.
     */
    where: CarritoWhereUniqueInput;
    /**
     * In case the Carrito found by the `where` argument doesn't exist, create a new Carrito with this data.
     */
    create: XOR<CarritoCreateInput, CarritoUncheckedCreateInput>;
    /**
     * In case the Carrito was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CarritoUpdateInput, CarritoUncheckedUpdateInput>;
  };

  /**
   * Carrito delete
   */
  export type CarritoDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Carrito
     */
    select?: CarritoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Carrito
     */
    omit?: CarritoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarritoInclude<ExtArgs> | null;
    /**
     * Filter which Carrito to delete.
     */
    where: CarritoWhereUniqueInput;
  };

  /**
   * Carrito deleteMany
   */
  export type CarritoDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Carritos to delete
     */
    where?: CarritoWhereInput;
    /**
     * Limit how many Carritos to delete.
     */
    limit?: number;
  };

  /**
   * Carrito.items
   */
  export type Carrito$itemsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ItemCarrito
     */
    select?: ItemCarritoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ItemCarrito
     */
    omit?: ItemCarritoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCarritoInclude<ExtArgs> | null;
    where?: ItemCarritoWhereInput;
    orderBy?:
      | ItemCarritoOrderByWithRelationInput
      | ItemCarritoOrderByWithRelationInput[];
    cursor?: ItemCarritoWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ItemCarritoScalarFieldEnum | ItemCarritoScalarFieldEnum[];
  };

  /**
   * Carrito without action
   */
  export type CarritoDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Carrito
     */
    select?: CarritoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Carrito
     */
    omit?: CarritoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarritoInclude<ExtArgs> | null;
  };

  /**
   * Model ItemCarrito
   */

  export type AggregateItemCarrito = {
    _count: ItemCarritoCountAggregateOutputType | null;
    _avg: ItemCarritoAvgAggregateOutputType | null;
    _sum: ItemCarritoSumAggregateOutputType | null;
    _min: ItemCarritoMinAggregateOutputType | null;
    _max: ItemCarritoMaxAggregateOutputType | null;
  };

  export type ItemCarritoAvgAggregateOutputType = {
    id: number | null;
    carritoId: number | null;
    productoId: number | null;
    cursoId: number | null;
    cantidad: number | null;
  };

  export type ItemCarritoSumAggregateOutputType = {
    id: number | null;
    carritoId: number | null;
    productoId: number | null;
    cursoId: number | null;
    cantidad: number | null;
  };

  export type ItemCarritoMinAggregateOutputType = {
    id: number | null;
    carritoId: number | null;
    tipo: $Enums.TipoItemOrden | null;
    productoId: number | null;
    cursoId: number | null;
    cantidad: number | null;
    creadoEn: Date | null;
  };

  export type ItemCarritoMaxAggregateOutputType = {
    id: number | null;
    carritoId: number | null;
    tipo: $Enums.TipoItemOrden | null;
    productoId: number | null;
    cursoId: number | null;
    cantidad: number | null;
    creadoEn: Date | null;
  };

  export type ItemCarritoCountAggregateOutputType = {
    id: number;
    carritoId: number;
    tipo: number;
    productoId: number;
    cursoId: number;
    cantidad: number;
    creadoEn: number;
    _all: number;
  };

  export type ItemCarritoAvgAggregateInputType = {
    id?: true;
    carritoId?: true;
    productoId?: true;
    cursoId?: true;
    cantidad?: true;
  };

  export type ItemCarritoSumAggregateInputType = {
    id?: true;
    carritoId?: true;
    productoId?: true;
    cursoId?: true;
    cantidad?: true;
  };

  export type ItemCarritoMinAggregateInputType = {
    id?: true;
    carritoId?: true;
    tipo?: true;
    productoId?: true;
    cursoId?: true;
    cantidad?: true;
    creadoEn?: true;
  };

  export type ItemCarritoMaxAggregateInputType = {
    id?: true;
    carritoId?: true;
    tipo?: true;
    productoId?: true;
    cursoId?: true;
    cantidad?: true;
    creadoEn?: true;
  };

  export type ItemCarritoCountAggregateInputType = {
    id?: true;
    carritoId?: true;
    tipo?: true;
    productoId?: true;
    cursoId?: true;
    cantidad?: true;
    creadoEn?: true;
    _all?: true;
  };

  export type ItemCarritoAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ItemCarrito to aggregate.
     */
    where?: ItemCarritoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ItemCarritos to fetch.
     */
    orderBy?:
      | ItemCarritoOrderByWithRelationInput
      | ItemCarritoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ItemCarritoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ItemCarritos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ItemCarritos.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned ItemCarritos
     **/
    _count?: true | ItemCarritoCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ItemCarritoAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ItemCarritoSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ItemCarritoMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ItemCarritoMaxAggregateInputType;
  };

  export type GetItemCarritoAggregateType<T extends ItemCarritoAggregateArgs> =
    {
      [P in keyof T & keyof AggregateItemCarrito]: P extends '_count' | 'count'
        ? T[P] extends true
          ? number
          : GetScalarType<T[P], AggregateItemCarrito[P]>
        : GetScalarType<T[P], AggregateItemCarrito[P]>;
    };

  export type ItemCarritoGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ItemCarritoWhereInput;
    orderBy?:
      | ItemCarritoOrderByWithAggregationInput
      | ItemCarritoOrderByWithAggregationInput[];
    by: ItemCarritoScalarFieldEnum[] | ItemCarritoScalarFieldEnum;
    having?: ItemCarritoScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ItemCarritoCountAggregateInputType | true;
    _avg?: ItemCarritoAvgAggregateInputType;
    _sum?: ItemCarritoSumAggregateInputType;
    _min?: ItemCarritoMinAggregateInputType;
    _max?: ItemCarritoMaxAggregateInputType;
  };

  export type ItemCarritoGroupByOutputType = {
    id: number;
    carritoId: number;
    tipo: $Enums.TipoItemOrden;
    productoId: number | null;
    cursoId: number | null;
    cantidad: number;
    creadoEn: Date;
    _count: ItemCarritoCountAggregateOutputType | null;
    _avg: ItemCarritoAvgAggregateOutputType | null;
    _sum: ItemCarritoSumAggregateOutputType | null;
    _min: ItemCarritoMinAggregateOutputType | null;
    _max: ItemCarritoMaxAggregateOutputType | null;
  };

  type GetItemCarritoGroupByPayload<T extends ItemCarritoGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ItemCarritoGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof ItemCarritoGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemCarritoGroupByOutputType[P]>
            : GetScalarType<T[P], ItemCarritoGroupByOutputType[P]>;
        }
      >
    >;

  export type ItemCarritoSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      carritoId?: boolean;
      tipo?: boolean;
      productoId?: boolean;
      cursoId?: boolean;
      cantidad?: boolean;
      creadoEn?: boolean;
      carrito?: boolean | CarritoDefaultArgs<ExtArgs>;
      producto?: boolean | ItemCarrito$productoArgs<ExtArgs>;
      curso?: boolean | ItemCarrito$cursoArgs<ExtArgs>;
    },
    ExtArgs['result']['itemCarrito']
  >;

  export type ItemCarritoSelectScalar = {
    id?: boolean;
    carritoId?: boolean;
    tipo?: boolean;
    productoId?: boolean;
    cursoId?: boolean;
    cantidad?: boolean;
    creadoEn?: boolean;
  };

  export type ItemCarritoOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'carritoId'
    | 'tipo'
    | 'productoId'
    | 'cursoId'
    | 'cantidad'
    | 'creadoEn',
    ExtArgs['result']['itemCarrito']
  >;
  export type ItemCarritoInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    carrito?: boolean | CarritoDefaultArgs<ExtArgs>;
    producto?: boolean | ItemCarrito$productoArgs<ExtArgs>;
    curso?: boolean | ItemCarrito$cursoArgs<ExtArgs>;
  };

  export type $ItemCarritoPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'ItemCarrito';
    objects: {
      carrito: Prisma.$CarritoPayload<ExtArgs>;
      producto: Prisma.$ProductoPayload<ExtArgs> | null;
      curso: Prisma.$CursoPayload<ExtArgs> | null;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        carritoId: number;
        tipo: $Enums.TipoItemOrden;
        productoId: number | null;
        cursoId: number | null;
        cantidad: number;
        creadoEn: Date;
      },
      ExtArgs['result']['itemCarrito']
    >;
    composites: {};
  };

  type ItemCarritoGetPayload<
    S extends boolean | null | undefined | ItemCarritoDefaultArgs,
  > = $Result.GetResult<Prisma.$ItemCarritoPayload, S>;

  type ItemCarritoCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    ItemCarritoFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: ItemCarritoCountAggregateInputType | true;
  };

  export interface ItemCarritoDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['ItemCarrito'];
      meta: { name: 'ItemCarrito' };
    };
    /**
     * Find zero or one ItemCarrito that matches the filter.
     * @param {ItemCarritoFindUniqueArgs} args - Arguments to find a ItemCarrito
     * @example
     * // Get one ItemCarrito
     * const itemCarrito = await prisma.itemCarrito.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ItemCarritoFindUniqueArgs>(
      args: SelectSubset<T, ItemCarritoFindUniqueArgs<ExtArgs>>,
    ): Prisma__ItemCarritoClient<
      $Result.GetResult<
        Prisma.$ItemCarritoPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one ItemCarrito that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ItemCarritoFindUniqueOrThrowArgs} args - Arguments to find a ItemCarrito
     * @example
     * // Get one ItemCarrito
     * const itemCarrito = await prisma.itemCarrito.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ItemCarritoFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ItemCarritoFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__ItemCarritoClient<
      $Result.GetResult<
        Prisma.$ItemCarritoPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ItemCarrito that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCarritoFindFirstArgs} args - Arguments to find a ItemCarrito
     * @example
     * // Get one ItemCarrito
     * const itemCarrito = await prisma.itemCarrito.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ItemCarritoFindFirstArgs>(
      args?: SelectSubset<T, ItemCarritoFindFirstArgs<ExtArgs>>,
    ): Prisma__ItemCarritoClient<
      $Result.GetResult<
        Prisma.$ItemCarritoPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ItemCarrito that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCarritoFindFirstOrThrowArgs} args - Arguments to find a ItemCarrito
     * @example
     * // Get one ItemCarrito
     * const itemCarrito = await prisma.itemCarrito.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ItemCarritoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ItemCarritoFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__ItemCarritoClient<
      $Result.GetResult<
        Prisma.$ItemCarritoPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more ItemCarritos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCarritoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ItemCarritos
     * const itemCarritos = await prisma.itemCarrito.findMany()
     *
     * // Get first 10 ItemCarritos
     * const itemCarritos = await prisma.itemCarrito.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const itemCarritoWithIdOnly = await prisma.itemCarrito.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ItemCarritoFindManyArgs>(
      args?: SelectSubset<T, ItemCarritoFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ItemCarritoPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a ItemCarrito.
     * @param {ItemCarritoCreateArgs} args - Arguments to create a ItemCarrito.
     * @example
     * // Create one ItemCarrito
     * const ItemCarrito = await prisma.itemCarrito.create({
     *   data: {
     *     // ... data to create a ItemCarrito
     *   }
     * })
     *
     */
    create<T extends ItemCarritoCreateArgs>(
      args: SelectSubset<T, ItemCarritoCreateArgs<ExtArgs>>,
    ): Prisma__ItemCarritoClient<
      $Result.GetResult<
        Prisma.$ItemCarritoPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many ItemCarritos.
     * @param {ItemCarritoCreateManyArgs} args - Arguments to create many ItemCarritos.
     * @example
     * // Create many ItemCarritos
     * const itemCarrito = await prisma.itemCarrito.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ItemCarritoCreateManyArgs>(
      args?: SelectSubset<T, ItemCarritoCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a ItemCarrito.
     * @param {ItemCarritoDeleteArgs} args - Arguments to delete one ItemCarrito.
     * @example
     * // Delete one ItemCarrito
     * const ItemCarrito = await prisma.itemCarrito.delete({
     *   where: {
     *     // ... filter to delete one ItemCarrito
     *   }
     * })
     *
     */
    delete<T extends ItemCarritoDeleteArgs>(
      args: SelectSubset<T, ItemCarritoDeleteArgs<ExtArgs>>,
    ): Prisma__ItemCarritoClient<
      $Result.GetResult<
        Prisma.$ItemCarritoPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one ItemCarrito.
     * @param {ItemCarritoUpdateArgs} args - Arguments to update one ItemCarrito.
     * @example
     * // Update one ItemCarrito
     * const itemCarrito = await prisma.itemCarrito.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ItemCarritoUpdateArgs>(
      args: SelectSubset<T, ItemCarritoUpdateArgs<ExtArgs>>,
    ): Prisma__ItemCarritoClient<
      $Result.GetResult<
        Prisma.$ItemCarritoPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more ItemCarritos.
     * @param {ItemCarritoDeleteManyArgs} args - Arguments to filter ItemCarritos to delete.
     * @example
     * // Delete a few ItemCarritos
     * const { count } = await prisma.itemCarrito.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ItemCarritoDeleteManyArgs>(
      args?: SelectSubset<T, ItemCarritoDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ItemCarritos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCarritoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ItemCarritos
     * const itemCarrito = await prisma.itemCarrito.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ItemCarritoUpdateManyArgs>(
      args: SelectSubset<T, ItemCarritoUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one ItemCarrito.
     * @param {ItemCarritoUpsertArgs} args - Arguments to update or create a ItemCarrito.
     * @example
     * // Update or create a ItemCarrito
     * const itemCarrito = await prisma.itemCarrito.upsert({
     *   create: {
     *     // ... data to create a ItemCarrito
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ItemCarrito we want to update
     *   }
     * })
     */
    upsert<T extends ItemCarritoUpsertArgs>(
      args: SelectSubset<T, ItemCarritoUpsertArgs<ExtArgs>>,
    ): Prisma__ItemCarritoClient<
      $Result.GetResult<
        Prisma.$ItemCarritoPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of ItemCarritos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCarritoCountArgs} args - Arguments to filter ItemCarritos to count.
     * @example
     * // Count the number of ItemCarritos
     * const count = await prisma.itemCarrito.count({
     *   where: {
     *     // ... the filter for the ItemCarritos we want to count
     *   }
     * })
     **/
    count<T extends ItemCarritoCountArgs>(
      args?: Subset<T, ItemCarritoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemCarritoCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a ItemCarrito.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCarritoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ItemCarritoAggregateArgs>(
      args: Subset<T, ItemCarritoAggregateArgs>,
    ): Prisma.PrismaPromise<GetItemCarritoAggregateType<T>>;

    /**
     * Group by ItemCarrito.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCarritoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ItemCarritoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemCarritoGroupByArgs['orderBy'] }
        : { orderBy?: ItemCarritoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ItemCarritoGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetItemCarritoGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the ItemCarrito model
     */
    readonly fields: ItemCarritoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ItemCarrito.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemCarritoClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    carrito<T extends CarritoDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, CarritoDefaultArgs<ExtArgs>>,
    ): Prisma__CarritoClient<
      | $Result.GetResult<
          Prisma.$CarritoPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    producto<T extends ItemCarrito$productoArgs<ExtArgs> = {}>(
      args?: Subset<T, ItemCarrito$productoArgs<ExtArgs>>,
    ): Prisma__ProductoClient<
      $Result.GetResult<
        Prisma.$ProductoPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    curso<T extends ItemCarrito$cursoArgs<ExtArgs> = {}>(
      args?: Subset<T, ItemCarrito$cursoArgs<ExtArgs>>,
    ): Prisma__CursoClient<
      $Result.GetResult<
        Prisma.$CursoPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the ItemCarrito model
   */
  interface ItemCarritoFieldRefs {
    readonly id: FieldRef<'ItemCarrito', 'Int'>;
    readonly carritoId: FieldRef<'ItemCarrito', 'Int'>;
    readonly tipo: FieldRef<'ItemCarrito', 'TipoItemOrden'>;
    readonly productoId: FieldRef<'ItemCarrito', 'Int'>;
    readonly cursoId: FieldRef<'ItemCarrito', 'Int'>;
    readonly cantidad: FieldRef<'ItemCarrito', 'Int'>;
    readonly creadoEn: FieldRef<'ItemCarrito', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * ItemCarrito findUnique
   */
  export type ItemCarritoFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ItemCarrito
     */
    select?: ItemCarritoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ItemCarrito
     */
    omit?: ItemCarritoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCarritoInclude<ExtArgs> | null;
    /**
     * Filter, which ItemCarrito to fetch.
     */
    where: ItemCarritoWhereUniqueInput;
  };

  /**
   * ItemCarrito findUniqueOrThrow
   */
  export type ItemCarritoFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ItemCarrito
     */
    select?: ItemCarritoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ItemCarrito
     */
    omit?: ItemCarritoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCarritoInclude<ExtArgs> | null;
    /**
     * Filter, which ItemCarrito to fetch.
     */
    where: ItemCarritoWhereUniqueInput;
  };

  /**
   * ItemCarrito findFirst
   */
  export type ItemCarritoFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ItemCarrito
     */
    select?: ItemCarritoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ItemCarrito
     */
    omit?: ItemCarritoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCarritoInclude<ExtArgs> | null;
    /**
     * Filter, which ItemCarrito to fetch.
     */
    where?: ItemCarritoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ItemCarritos to fetch.
     */
    orderBy?:
      | ItemCarritoOrderByWithRelationInput
      | ItemCarritoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ItemCarritos.
     */
    cursor?: ItemCarritoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ItemCarritos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ItemCarritos.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ItemCarritos.
     */
    distinct?: ItemCarritoScalarFieldEnum | ItemCarritoScalarFieldEnum[];
  };

  /**
   * ItemCarrito findFirstOrThrow
   */
  export type ItemCarritoFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ItemCarrito
     */
    select?: ItemCarritoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ItemCarrito
     */
    omit?: ItemCarritoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCarritoInclude<ExtArgs> | null;
    /**
     * Filter, which ItemCarrito to fetch.
     */
    where?: ItemCarritoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ItemCarritos to fetch.
     */
    orderBy?:
      | ItemCarritoOrderByWithRelationInput
      | ItemCarritoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ItemCarritos.
     */
    cursor?: ItemCarritoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ItemCarritos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ItemCarritos.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ItemCarritos.
     */
    distinct?: ItemCarritoScalarFieldEnum | ItemCarritoScalarFieldEnum[];
  };

  /**
   * ItemCarrito findMany
   */
  export type ItemCarritoFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ItemCarrito
     */
    select?: ItemCarritoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ItemCarrito
     */
    omit?: ItemCarritoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCarritoInclude<ExtArgs> | null;
    /**
     * Filter, which ItemCarritos to fetch.
     */
    where?: ItemCarritoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ItemCarritos to fetch.
     */
    orderBy?:
      | ItemCarritoOrderByWithRelationInput
      | ItemCarritoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing ItemCarritos.
     */
    cursor?: ItemCarritoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ItemCarritos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ItemCarritos.
     */
    skip?: number;
    distinct?: ItemCarritoScalarFieldEnum | ItemCarritoScalarFieldEnum[];
  };

  /**
   * ItemCarrito create
   */
  export type ItemCarritoCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ItemCarrito
     */
    select?: ItemCarritoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ItemCarrito
     */
    omit?: ItemCarritoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCarritoInclude<ExtArgs> | null;
    /**
     * The data needed to create a ItemCarrito.
     */
    data: XOR<ItemCarritoCreateInput, ItemCarritoUncheckedCreateInput>;
  };

  /**
   * ItemCarrito createMany
   */
  export type ItemCarritoCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many ItemCarritos.
     */
    data: ItemCarritoCreateManyInput | ItemCarritoCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * ItemCarrito update
   */
  export type ItemCarritoUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ItemCarrito
     */
    select?: ItemCarritoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ItemCarrito
     */
    omit?: ItemCarritoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCarritoInclude<ExtArgs> | null;
    /**
     * The data needed to update a ItemCarrito.
     */
    data: XOR<ItemCarritoUpdateInput, ItemCarritoUncheckedUpdateInput>;
    /**
     * Choose, which ItemCarrito to update.
     */
    where: ItemCarritoWhereUniqueInput;
  };

  /**
   * ItemCarrito updateMany
   */
  export type ItemCarritoUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update ItemCarritos.
     */
    data: XOR<
      ItemCarritoUpdateManyMutationInput,
      ItemCarritoUncheckedUpdateManyInput
    >;
    /**
     * Filter which ItemCarritos to update
     */
    where?: ItemCarritoWhereInput;
    /**
     * Limit how many ItemCarritos to update.
     */
    limit?: number;
  };

  /**
   * ItemCarrito upsert
   */
  export type ItemCarritoUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ItemCarrito
     */
    select?: ItemCarritoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ItemCarrito
     */
    omit?: ItemCarritoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCarritoInclude<ExtArgs> | null;
    /**
     * The filter to search for the ItemCarrito to update in case it exists.
     */
    where: ItemCarritoWhereUniqueInput;
    /**
     * In case the ItemCarrito found by the `where` argument doesn't exist, create a new ItemCarrito with this data.
     */
    create: XOR<ItemCarritoCreateInput, ItemCarritoUncheckedCreateInput>;
    /**
     * In case the ItemCarrito was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemCarritoUpdateInput, ItemCarritoUncheckedUpdateInput>;
  };

  /**
   * ItemCarrito delete
   */
  export type ItemCarritoDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ItemCarrito
     */
    select?: ItemCarritoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ItemCarrito
     */
    omit?: ItemCarritoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCarritoInclude<ExtArgs> | null;
    /**
     * Filter which ItemCarrito to delete.
     */
    where: ItemCarritoWhereUniqueInput;
  };

  /**
   * ItemCarrito deleteMany
   */
  export type ItemCarritoDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ItemCarritos to delete
     */
    where?: ItemCarritoWhereInput;
    /**
     * Limit how many ItemCarritos to delete.
     */
    limit?: number;
  };

  /**
   * ItemCarrito.producto
   */
  export type ItemCarrito$productoArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Producto
     */
    omit?: ProductoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoInclude<ExtArgs> | null;
    where?: ProductoWhereInput;
  };

  /**
   * ItemCarrito.curso
   */
  export type ItemCarrito$cursoArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Curso
     */
    select?: CursoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Curso
     */
    omit?: CursoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoInclude<ExtArgs> | null;
    where?: CursoWhereInput;
  };

  /**
   * ItemCarrito without action
   */
  export type ItemCarritoDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ItemCarrito
     */
    select?: ItemCarritoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ItemCarrito
     */
    omit?: ItemCarritoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCarritoInclude<ExtArgs> | null;
  };

  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted';
    ReadCommitted: 'ReadCommitted';
    RepeatableRead: 'RepeatableRead';
    Serializable: 'Serializable';
  };

  export type TransactionIsolationLevel =
    (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel];

  export const UsuarioScalarFieldEnum: {
    id: 'id';
    email: 'email';
    nombre: 'nombre';
    passwordHash: 'passwordHash';
    creadoEn: 'creadoEn';
    actualizadoEn: 'actualizadoEn';
    emailVerificadoEn: 'emailVerificadoEn';
  };

  export type UsuarioScalarFieldEnum =
    (typeof UsuarioScalarFieldEnum)[keyof typeof UsuarioScalarFieldEnum];

  export const RoleScalarFieldEnum: {
    id: 'id';
    slug: 'slug';
    name: 'name';
    createdAt: 'createdAt';
  };

  export type RoleScalarFieldEnum =
    (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum];

  export const UsuarioRolScalarFieldEnum: {
    usuarioId: 'usuarioId';
    roleId: 'roleId';
  };

  export type UsuarioRolScalarFieldEnum =
    (typeof UsuarioRolScalarFieldEnum)[keyof typeof UsuarioRolScalarFieldEnum];

  export const FavoritoScalarFieldEnum: {
    id: 'id';
    usuarioId: 'usuarioId';
    productoId: 'productoId';
    creadoEn: 'creadoEn';
  };

  export type FavoritoScalarFieldEnum =
    (typeof FavoritoScalarFieldEnum)[keyof typeof FavoritoScalarFieldEnum];

  export const CursoScalarFieldEnum: {
    id: 'id';
    slug: 'slug';
    titulo: 'titulo';
    resumen: 'resumen';
    descripcionMD: 'descripcionMD';
    requisitos: 'requisitos';
    precio: 'precio';
    publicado: 'publicado';
    nivel: 'nivel';
    portada: 'portada';
    destacado: 'destacado';
    tags: 'tags';
    ratingProm: 'ratingProm';
    ratingConteo: 'ratingConteo';
    creadoEn: 'creadoEn';
    instructorId: 'instructorId';
  };

  export type CursoScalarFieldEnum =
    (typeof CursoScalarFieldEnum)[keyof typeof CursoScalarFieldEnum];

  export const InscripcionScalarFieldEnum: {
    id: 'id';
    usuarioId: 'usuarioId';
    cursoId: 'cursoId';
    estado: 'estado';
    progreso: 'progreso';
    creadoEn: 'creadoEn';
    actualizadoEn: 'actualizadoEn';
  };

  export type InscripcionScalarFieldEnum =
    (typeof InscripcionScalarFieldEnum)[keyof typeof InscripcionScalarFieldEnum];

  export const ModuloScalarFieldEnum: {
    id: 'id';
    cursoId: 'cursoId';
    titulo: 'titulo';
    orden: 'orden';
    parentId: 'parentId';
  };

  export type ModuloScalarFieldEnum =
    (typeof ModuloScalarFieldEnum)[keyof typeof ModuloScalarFieldEnum];

  export const LeccionScalarFieldEnum: {
    id: 'id';
    moduloId: 'moduloId';
    titulo: 'titulo';
    rutaSrc: 'rutaSrc';
    orden: 'orden';
    tipo: 'tipo';
    descripcion: 'descripcion';
    contenido: 'contenido';
    previewUrl: 'previewUrl';
    duracion: 'duracion';
  };

  export type LeccionScalarFieldEnum =
    (typeof LeccionScalarFieldEnum)[keyof typeof LeccionScalarFieldEnum];

  export const LeccionTipoConfigScalarFieldEnum: {
    id: 'id';
    tipo: 'tipo';
    schema: 'schema';
    ui: 'ui';
    version: 'version';
    creadoEn: 'creadoEn';
    actualizadoEn: 'actualizadoEn';
  };

  export type LeccionTipoConfigScalarFieldEnum =
    (typeof LeccionTipoConfigScalarFieldEnum)[keyof typeof LeccionTipoConfigScalarFieldEnum];

  export const ProductoScalarFieldEnum: {
    id: 'id';
    slug: 'slug';
    titulo: 'titulo';
    precio: 'precio';
    stock: 'stock';
    publicado: 'publicado';
    destacado: 'destacado';
    imagen: 'imagen';
    descripcionMD: 'descripcionMD';
    precioLista: 'precioLista';
    ratingProm: 'ratingProm';
    ratingConteo: 'ratingConteo';
    creadoEn: 'creadoEn';
    marcaId: 'marcaId';
    categoriaId: 'categoriaId';
  };

  export type ProductoScalarFieldEnum =
    (typeof ProductoScalarFieldEnum)[keyof typeof ProductoScalarFieldEnum];

  export const ProductoImagenScalarFieldEnum: {
    id: 'id';
    productoId: 'productoId';
    archivo: 'archivo';
    alt: 'alt';
    orden: 'orden';
  };

  export type ProductoImagenScalarFieldEnum =
    (typeof ProductoImagenScalarFieldEnum)[keyof typeof ProductoImagenScalarFieldEnum];

  export const MarcaScalarFieldEnum: {
    id: 'id';
    slug: 'slug';
    nombre: 'nombre';
    imagen: 'imagen';
    activa: 'activa';
    orden: 'orden';
    creadoEn: 'creadoEn';
  };

  export type MarcaScalarFieldEnum =
    (typeof MarcaScalarFieldEnum)[keyof typeof MarcaScalarFieldEnum];

  export const CategoriaScalarFieldEnum: {
    id: 'id';
    slug: 'slug';
    nombre: 'nombre';
    descripcion: 'descripcion';
    imagen: 'imagen';
    activa: 'activa';
    orden: 'orden';
    creadoEn: 'creadoEn';
    parentId: 'parentId';
  };

  export type CategoriaScalarFieldEnum =
    (typeof CategoriaScalarFieldEnum)[keyof typeof CategoriaScalarFieldEnum];

  export const OrdenScalarFieldEnum: {
    id: 'id';
    usuarioId: 'usuarioId';
    estado: 'estado';
    total: 'total';
    moneda: 'moneda';
    referenciaPago: 'referenciaPago';
    creadoEn: 'creadoEn';
    actualizadoEn: 'actualizadoEn';
    esSuscripcion: 'esSuscripcion';
    suscripcionActiva: 'suscripcionActiva';
    suscripcionId: 'suscripcionId';
    suscripcionFrecuencia: 'suscripcionFrecuencia';
    suscripcionTipoFrecuencia: 'suscripcionTipoFrecuencia';
    metadatos: 'metadatos';
    direccionEnvioId: 'direccionEnvioId';
    direccionFacturacionId: 'direccionFacturacionId';
  };

  export type OrdenScalarFieldEnum =
    (typeof OrdenScalarFieldEnum)[keyof typeof OrdenScalarFieldEnum];

  export const ItemOrdenScalarFieldEnum: {
    id: 'id';
    ordenId: 'ordenId';
    tipo: 'tipo';
    refId: 'refId';
    titulo: 'titulo';
    cantidad: 'cantidad';
    precioUnitario: 'precioUnitario';
  };

  export type ItemOrdenScalarFieldEnum =
    (typeof ItemOrdenScalarFieldEnum)[keyof typeof ItemOrdenScalarFieldEnum];

  export const PagoSuscripcionScalarFieldEnum: {
    id: 'id';
    ordenId: 'ordenId';
    usuarioId: 'usuarioId';
    referenciaPago: 'referenciaPago';
    monto: 'monto';
    estado: 'estado';
    metadatos: 'metadatos';
    creadoEn: 'creadoEn';
    actualizadoEn: 'actualizadoEn';
  };

  export type PagoSuscripcionScalarFieldEnum =
    (typeof PagoSuscripcionScalarFieldEnum)[keyof typeof PagoSuscripcionScalarFieldEnum];

  export const DireccionScalarFieldEnum: {
    id: 'id';
    usuarioId: 'usuarioId';
    etiqueta: 'etiqueta';
    nombre: 'nombre';
    telefono: 'telefono';
    calle: 'calle';
    numero: 'numero';
    pisoDepto: 'pisoDepto';
    ciudad: 'ciudad';
    provincia: 'provincia';
    cp: 'cp';
    pais: 'pais';
    predeterminada: 'predeterminada';
    creadoEn: 'creadoEn';
    actualizadoEn: 'actualizadoEn';
  };

  export type DireccionScalarFieldEnum =
    (typeof DireccionScalarFieldEnum)[keyof typeof DireccionScalarFieldEnum];

  export const SliderScalarFieldEnum: {
    id: 'id';
    titulo: 'titulo';
    alt: 'alt';
    archivo: 'archivo';
    activa: 'activa';
    orden: 'orden';
    creadoEn: 'creadoEn';
    actualizadoEn: 'actualizadoEn';
    ctaPrimarioHref: 'ctaPrimarioHref';
    ctaPrimarioTexto: 'ctaPrimarioTexto';
    ctaSecundarioHref: 'ctaSecundarioHref';
    ctaSecundarioTexto: 'ctaSecundarioTexto';
    descripcion: 'descripcion';
    etiqueta: 'etiqueta';
    subtitulo: 'subtitulo';
  };

  export type SliderScalarFieldEnum =
    (typeof SliderScalarFieldEnum)[keyof typeof SliderScalarFieldEnum];

  export const ResenaScalarFieldEnum: {
    id: 'id';
    cursoId: 'cursoId';
    productoId: 'productoId';
    usuarioId: 'usuarioId';
    puntaje: 'puntaje';
    comentario: 'comentario';
    creadoEn: 'creadoEn';
  };

  export type ResenaScalarFieldEnum =
    (typeof ResenaScalarFieldEnum)[keyof typeof ResenaScalarFieldEnum];

  export const ResenaLikeScalarFieldEnum: {
    id: 'id';
    resenaId: 'resenaId';
    usuarioId: 'usuarioId';
    tipo: 'tipo';
    creadoEn: 'creadoEn';
  };

  export type ResenaLikeScalarFieldEnum =
    (typeof ResenaLikeScalarFieldEnum)[keyof typeof ResenaLikeScalarFieldEnum];

  export const ResenaRespuestaScalarFieldEnum: {
    id: 'id';
    resenaId: 'resenaId';
    usuarioId: 'usuarioId';
    parentId: 'parentId';
    contenido: 'contenido';
    eliminado: 'eliminado';
    creadoEn: 'creadoEn';
    actualizadoEn: 'actualizadoEn';
  };

  export type ResenaRespuestaScalarFieldEnum =
    (typeof ResenaRespuestaScalarFieldEnum)[keyof typeof ResenaRespuestaScalarFieldEnum];

  export const NotificacionScalarFieldEnum: {
    id: 'id';
    usuarioId: 'usuarioId';
    tipo: 'tipo';
    titulo: 'titulo';
    mensaje: 'mensaje';
    leida: 'leida';
    url: 'url';
    metadata: 'metadata';
    creadoEn: 'creadoEn';
  };

  export type NotificacionScalarFieldEnum =
    (typeof NotificacionScalarFieldEnum)[keyof typeof NotificacionScalarFieldEnum];

  export const PreferenciasNotificacionScalarFieldEnum: {
    id: 'id';
    usuarioId: 'usuarioId';
    nuevaResena: 'nuevaResena';
    respuestaResena: 'respuestaResena';
    actualizacionesSistema: 'actualizacionesSistema';
    mantenimiento: 'mantenimiento';
    reporteContenido: 'reporteContenido';
    contenidoPendiente: 'contenidoPendiente';
    resumenDiario: 'resumenDiario';
    notificacionesInstantaneas: 'notificacionesInstantaneas';
    creadoEn: 'creadoEn';
    actualizadoEn: 'actualizadoEn';
  };

  export type PreferenciasNotificacionScalarFieldEnum =
    (typeof PreferenciasNotificacionScalarFieldEnum)[keyof typeof PreferenciasNotificacionScalarFieldEnum];

  export const ResenaBorradorScalarFieldEnum: {
    id: 'id';
    usuarioId: 'usuarioId';
    cursoId: 'cursoId';
    productoId: 'productoId';
    puntaje: 'puntaje';
    comentario: 'comentario';
    creadoEn: 'creadoEn';
    actualizadoEn: 'actualizadoEn';
  };

  export type ResenaBorradorScalarFieldEnum =
    (typeof ResenaBorradorScalarFieldEnum)[keyof typeof ResenaBorradorScalarFieldEnum];

  export const AuditLogScalarFieldEnum: {
    id: 'id';
    tableName: 'tableName';
    recordId: 'recordId';
    action: 'action';
    oldData: 'oldData';
    newData: 'newData';
    userId: 'userId';
    userAgent: 'userAgent';
    ipAddress: 'ipAddress';
    endpoint: 'endpoint';
    timestamp: 'timestamp';
  };

  export type AuditLogScalarFieldEnum =
    (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum];

  export const CarritoScalarFieldEnum: {
    id: 'id';
    usuarioId: 'usuarioId';
    creadoEn: 'creadoEn';
    actualizadoEn: 'actualizadoEn';
  };

  export type CarritoScalarFieldEnum =
    (typeof CarritoScalarFieldEnum)[keyof typeof CarritoScalarFieldEnum];

  export const ItemCarritoScalarFieldEnum: {
    id: 'id';
    carritoId: 'carritoId';
    tipo: 'tipo';
    productoId: 'productoId';
    cursoId: 'cursoId';
    cantidad: 'cantidad';
    creadoEn: 'creadoEn';
  };

  export type ItemCarritoScalarFieldEnum =
    (typeof ItemCarritoScalarFieldEnum)[keyof typeof ItemCarritoScalarFieldEnum];

  export const SortOrder: {
    asc: 'asc';
    desc: 'desc';
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder];

  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull;
    JsonNull: typeof JsonNull;
  };

  export type NullableJsonNullValueInput =
    (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput];

  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull;
  };

  export type JsonNullValueInput =
    (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput];

  export const NullsOrder: {
    first: 'first';
    last: 'last';
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder];

  export const UsuarioOrderByRelevanceFieldEnum: {
    email: 'email';
    nombre: 'nombre';
    passwordHash: 'passwordHash';
  };

  export type UsuarioOrderByRelevanceFieldEnum =
    (typeof UsuarioOrderByRelevanceFieldEnum)[keyof typeof UsuarioOrderByRelevanceFieldEnum];

  export const RoleOrderByRelevanceFieldEnum: {
    slug: 'slug';
    name: 'name';
  };

  export type RoleOrderByRelevanceFieldEnum =
    (typeof RoleOrderByRelevanceFieldEnum)[keyof typeof RoleOrderByRelevanceFieldEnum];

  export const JsonNullValueFilter: {
    DbNull: typeof DbNull;
    JsonNull: typeof JsonNull;
    AnyNull: typeof AnyNull;
  };

  export type JsonNullValueFilter =
    (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter];

  export const QueryMode: {
    default: 'default';
    insensitive: 'insensitive';
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode];

  export const CursoOrderByRelevanceFieldEnum: {
    slug: 'slug';
    titulo: 'titulo';
    resumen: 'resumen';
    descripcionMD: 'descripcionMD';
    requisitos: 'requisitos';
    portada: 'portada';
  };

  export type CursoOrderByRelevanceFieldEnum =
    (typeof CursoOrderByRelevanceFieldEnum)[keyof typeof CursoOrderByRelevanceFieldEnum];

  export const ModuloOrderByRelevanceFieldEnum: {
    titulo: 'titulo';
  };

  export type ModuloOrderByRelevanceFieldEnum =
    (typeof ModuloOrderByRelevanceFieldEnum)[keyof typeof ModuloOrderByRelevanceFieldEnum];

  export const LeccionOrderByRelevanceFieldEnum: {
    titulo: 'titulo';
    rutaSrc: 'rutaSrc';
    descripcion: 'descripcion';
    previewUrl: 'previewUrl';
  };

  export type LeccionOrderByRelevanceFieldEnum =
    (typeof LeccionOrderByRelevanceFieldEnum)[keyof typeof LeccionOrderByRelevanceFieldEnum];

  export const ProductoOrderByRelevanceFieldEnum: {
    slug: 'slug';
    titulo: 'titulo';
    imagen: 'imagen';
    descripcionMD: 'descripcionMD';
  };

  export type ProductoOrderByRelevanceFieldEnum =
    (typeof ProductoOrderByRelevanceFieldEnum)[keyof typeof ProductoOrderByRelevanceFieldEnum];

  export const ProductoImagenOrderByRelevanceFieldEnum: {
    archivo: 'archivo';
    alt: 'alt';
  };

  export type ProductoImagenOrderByRelevanceFieldEnum =
    (typeof ProductoImagenOrderByRelevanceFieldEnum)[keyof typeof ProductoImagenOrderByRelevanceFieldEnum];

  export const MarcaOrderByRelevanceFieldEnum: {
    slug: 'slug';
    nombre: 'nombre';
    imagen: 'imagen';
  };

  export type MarcaOrderByRelevanceFieldEnum =
    (typeof MarcaOrderByRelevanceFieldEnum)[keyof typeof MarcaOrderByRelevanceFieldEnum];

  export const CategoriaOrderByRelevanceFieldEnum: {
    slug: 'slug';
    nombre: 'nombre';
    descripcion: 'descripcion';
    imagen: 'imagen';
  };

  export type CategoriaOrderByRelevanceFieldEnum =
    (typeof CategoriaOrderByRelevanceFieldEnum)[keyof typeof CategoriaOrderByRelevanceFieldEnum];

  export const OrdenOrderByRelevanceFieldEnum: {
    moneda: 'moneda';
    referenciaPago: 'referenciaPago';
    suscripcionId: 'suscripcionId';
    suscripcionTipoFrecuencia: 'suscripcionTipoFrecuencia';
  };

  export type OrdenOrderByRelevanceFieldEnum =
    (typeof OrdenOrderByRelevanceFieldEnum)[keyof typeof OrdenOrderByRelevanceFieldEnum];

  export const ItemOrdenOrderByRelevanceFieldEnum: {
    titulo: 'titulo';
  };

  export type ItemOrdenOrderByRelevanceFieldEnum =
    (typeof ItemOrdenOrderByRelevanceFieldEnum)[keyof typeof ItemOrdenOrderByRelevanceFieldEnum];

  export const PagoSuscripcionOrderByRelevanceFieldEnum: {
    referenciaPago: 'referenciaPago';
    estado: 'estado';
  };

  export type PagoSuscripcionOrderByRelevanceFieldEnum =
    (typeof PagoSuscripcionOrderByRelevanceFieldEnum)[keyof typeof PagoSuscripcionOrderByRelevanceFieldEnum];

  export const DireccionOrderByRelevanceFieldEnum: {
    etiqueta: 'etiqueta';
    nombre: 'nombre';
    telefono: 'telefono';
    calle: 'calle';
    numero: 'numero';
    pisoDepto: 'pisoDepto';
    ciudad: 'ciudad';
    provincia: 'provincia';
    cp: 'cp';
    pais: 'pais';
  };

  export type DireccionOrderByRelevanceFieldEnum =
    (typeof DireccionOrderByRelevanceFieldEnum)[keyof typeof DireccionOrderByRelevanceFieldEnum];

  export const SliderOrderByRelevanceFieldEnum: {
    titulo: 'titulo';
    alt: 'alt';
    archivo: 'archivo';
    ctaPrimarioHref: 'ctaPrimarioHref';
    ctaPrimarioTexto: 'ctaPrimarioTexto';
    ctaSecundarioHref: 'ctaSecundarioHref';
    ctaSecundarioTexto: 'ctaSecundarioTexto';
    descripcion: 'descripcion';
    etiqueta: 'etiqueta';
    subtitulo: 'subtitulo';
  };

  export type SliderOrderByRelevanceFieldEnum =
    (typeof SliderOrderByRelevanceFieldEnum)[keyof typeof SliderOrderByRelevanceFieldEnum];

  export const ResenaOrderByRelevanceFieldEnum: {
    comentario: 'comentario';
  };

  export type ResenaOrderByRelevanceFieldEnum =
    (typeof ResenaOrderByRelevanceFieldEnum)[keyof typeof ResenaOrderByRelevanceFieldEnum];

  export const ResenaRespuestaOrderByRelevanceFieldEnum: {
    contenido: 'contenido';
  };

  export type ResenaRespuestaOrderByRelevanceFieldEnum =
    (typeof ResenaRespuestaOrderByRelevanceFieldEnum)[keyof typeof ResenaRespuestaOrderByRelevanceFieldEnum];

  export const NotificacionOrderByRelevanceFieldEnum: {
    titulo: 'titulo';
    mensaje: 'mensaje';
    url: 'url';
  };

  export type NotificacionOrderByRelevanceFieldEnum =
    (typeof NotificacionOrderByRelevanceFieldEnum)[keyof typeof NotificacionOrderByRelevanceFieldEnum];

  export const ResenaBorradorOrderByRelevanceFieldEnum: {
    comentario: 'comentario';
  };

  export type ResenaBorradorOrderByRelevanceFieldEnum =
    (typeof ResenaBorradorOrderByRelevanceFieldEnum)[keyof typeof ResenaBorradorOrderByRelevanceFieldEnum];

  export const AuditLogOrderByRelevanceFieldEnum: {
    tableName: 'tableName';
    recordId: 'recordId';
    action: 'action';
    userAgent: 'userAgent';
    ipAddress: 'ipAddress';
    endpoint: 'endpoint';
  };

  export type AuditLogOrderByRelevanceFieldEnum =
    (typeof AuditLogOrderByRelevanceFieldEnum)[keyof typeof AuditLogOrderByRelevanceFieldEnum];

  /**
   * Field references
   */

  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Int'
  >;

  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'String'
  >;

  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'DateTime'
  >;

  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Boolean'
  >;

  /**
   * Reference to a field of type 'NivelCurso'
   */
  export type EnumNivelCursoFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'NivelCurso'
  >;

  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Json'
  >;

  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'QueryMode'
  >;

  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Decimal'
  >;

  /**
   * Reference to a field of type 'EstadoInscripcion'
   */
  export type EnumEstadoInscripcionFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, 'EstadoInscripcion'>;

  /**
   * Reference to a field of type 'TipoLeccion'
   */
  export type EnumTipoLeccionFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'TipoLeccion'
  >;

  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Float'
  >;

  /**
   * Reference to a field of type 'EstadoOrden'
   */
  export type EnumEstadoOrdenFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'EstadoOrden'
  >;

  /**
   * Reference to a field of type 'TipoItemOrden'
   */
  export type EnumTipoItemOrdenFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'TipoItemOrden'
  >;

  /**
   * Reference to a field of type 'TipoLike'
   */
  export type EnumTipoLikeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'TipoLike'
  >;

  /**
   * Reference to a field of type 'TipoNotificacion'
   */
  export type EnumTipoNotificacionFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, 'TipoNotificacion'>;

  /**
   * Deep Input Types
   */

  export type UsuarioWhereInput = {
    AND?: UsuarioWhereInput | UsuarioWhereInput[];
    OR?: UsuarioWhereInput[];
    NOT?: UsuarioWhereInput | UsuarioWhereInput[];
    id?: IntFilter<'Usuario'> | number;
    email?: StringFilter<'Usuario'> | string;
    nombre?: StringNullableFilter<'Usuario'> | string | null;
    passwordHash?: StringFilter<'Usuario'> | string;
    creadoEn?: DateTimeFilter<'Usuario'> | Date | string;
    actualizadoEn?: DateTimeFilter<'Usuario'> | Date | string;
    emailVerificadoEn?:
      | DateTimeNullableFilter<'Usuario'>
      | Date
      | string
      | null;
    roles?: UsuarioRolListRelationFilter;
    cursosImpartidos?: CursoListRelationFilter;
    inscripciones?: InscripcionListRelationFilter;
    resenas?: ResenaListRelationFilter;
    resenaRespuestas?: ResenaRespuestaListRelationFilter;
    favoritos?: FavoritoListRelationFilter;
    resenaLikes?: ResenaLikeListRelationFilter;
    ordenes?: OrdenListRelationFilter;
    auditLogs?: AuditLogListRelationFilter;
    carrito?: XOR<
      CarritoNullableScalarRelationFilter,
      CarritoWhereInput
    > | null;
    notificaciones?: NotificacionListRelationFilter;
  };

  export type UsuarioOrderByWithRelationInput = {
    id?: SortOrder;
    email?: SortOrder;
    nombre?: SortOrderInput | SortOrder;
    passwordHash?: SortOrder;
    creadoEn?: SortOrder;
    actualizadoEn?: SortOrder;
    emailVerificadoEn?: SortOrderInput | SortOrder;
    roles?: UsuarioRolOrderByRelationAggregateInput;
    cursosImpartidos?: CursoOrderByRelationAggregateInput;
    inscripciones?: InscripcionOrderByRelationAggregateInput;
    resenas?: ResenaOrderByRelationAggregateInput;
    resenaRespuestas?: ResenaRespuestaOrderByRelationAggregateInput;
    favoritos?: FavoritoOrderByRelationAggregateInput;
    resenaLikes?: ResenaLikeOrderByRelationAggregateInput;
    ordenes?: OrdenOrderByRelationAggregateInput;
    auditLogs?: AuditLogOrderByRelationAggregateInput;
    carrito?: CarritoOrderByWithRelationInput;
    notificaciones?: NotificacionOrderByRelationAggregateInput;
    _relevance?: UsuarioOrderByRelevanceInput;
  };

  export type UsuarioWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      email?: string;
      AND?: UsuarioWhereInput | UsuarioWhereInput[];
      OR?: UsuarioWhereInput[];
      NOT?: UsuarioWhereInput | UsuarioWhereInput[];
      nombre?: StringNullableFilter<'Usuario'> | string | null;
      passwordHash?: StringFilter<'Usuario'> | string;
      creadoEn?: DateTimeFilter<'Usuario'> | Date | string;
      actualizadoEn?: DateTimeFilter<'Usuario'> | Date | string;
      emailVerificadoEn?:
        | DateTimeNullableFilter<'Usuario'>
        | Date
        | string
        | null;
      roles?: UsuarioRolListRelationFilter;
      cursosImpartidos?: CursoListRelationFilter;
      inscripciones?: InscripcionListRelationFilter;
      resenas?: ResenaListRelationFilter;
      resenaRespuestas?: ResenaRespuestaListRelationFilter;
      favoritos?: FavoritoListRelationFilter;
      resenaLikes?: ResenaLikeListRelationFilter;
      ordenes?: OrdenListRelationFilter;
      auditLogs?: AuditLogListRelationFilter;
      carrito?: XOR<
        CarritoNullableScalarRelationFilter,
        CarritoWhereInput
      > | null;
      notificaciones?: NotificacionListRelationFilter;
    },
    'id' | 'email'
  >;

  export type UsuarioOrderByWithAggregationInput = {
    id?: SortOrder;
    email?: SortOrder;
    nombre?: SortOrderInput | SortOrder;
    passwordHash?: SortOrder;
    creadoEn?: SortOrder;
    actualizadoEn?: SortOrder;
    emailVerificadoEn?: SortOrderInput | SortOrder;
    _count?: UsuarioCountOrderByAggregateInput;
    _avg?: UsuarioAvgOrderByAggregateInput;
    _max?: UsuarioMaxOrderByAggregateInput;
    _min?: UsuarioMinOrderByAggregateInput;
    _sum?: UsuarioSumOrderByAggregateInput;
  };

  export type UsuarioScalarWhereWithAggregatesInput = {
    AND?:
      | UsuarioScalarWhereWithAggregatesInput
      | UsuarioScalarWhereWithAggregatesInput[];
    OR?: UsuarioScalarWhereWithAggregatesInput[];
    NOT?:
      | UsuarioScalarWhereWithAggregatesInput
      | UsuarioScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<'Usuario'> | number;
    email?: StringWithAggregatesFilter<'Usuario'> | string;
    nombre?: StringNullableWithAggregatesFilter<'Usuario'> | string | null;
    passwordHash?: StringWithAggregatesFilter<'Usuario'> | string;
    creadoEn?: DateTimeWithAggregatesFilter<'Usuario'> | Date | string;
    actualizadoEn?: DateTimeWithAggregatesFilter<'Usuario'> | Date | string;
    emailVerificadoEn?:
      | DateTimeNullableWithAggregatesFilter<'Usuario'>
      | Date
      | string
      | null;
  };

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[];
    OR?: RoleWhereInput[];
    NOT?: RoleWhereInput | RoleWhereInput[];
    id?: IntFilter<'Role'> | number;
    slug?: StringFilter<'Role'> | string;
    name?: StringFilter<'Role'> | string;
    createdAt?: DateTimeFilter<'Role'> | Date | string;
    usuarios?: UsuarioRolListRelationFilter;
  };

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder;
    slug?: SortOrder;
    name?: SortOrder;
    createdAt?: SortOrder;
    usuarios?: UsuarioRolOrderByRelationAggregateInput;
    _relevance?: RoleOrderByRelevanceInput;
  };

  export type RoleWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      slug?: string;
      AND?: RoleWhereInput | RoleWhereInput[];
      OR?: RoleWhereInput[];
      NOT?: RoleWhereInput | RoleWhereInput[];
      name?: StringFilter<'Role'> | string;
      createdAt?: DateTimeFilter<'Role'> | Date | string;
      usuarios?: UsuarioRolListRelationFilter;
    },
    'id' | 'slug'
  >;

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder;
    slug?: SortOrder;
    name?: SortOrder;
    createdAt?: SortOrder;
    _count?: RoleCountOrderByAggregateInput;
    _avg?: RoleAvgOrderByAggregateInput;
    _max?: RoleMaxOrderByAggregateInput;
    _min?: RoleMinOrderByAggregateInput;
    _sum?: RoleSumOrderByAggregateInput;
  };

  export type RoleScalarWhereWithAggregatesInput = {
    AND?:
      | RoleScalarWhereWithAggregatesInput
      | RoleScalarWhereWithAggregatesInput[];
    OR?: RoleScalarWhereWithAggregatesInput[];
    NOT?:
      | RoleScalarWhereWithAggregatesInput
      | RoleScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<'Role'> | number;
    slug?: StringWithAggregatesFilter<'Role'> | string;
    name?: StringWithAggregatesFilter<'Role'> | string;
    createdAt?: DateTimeWithAggregatesFilter<'Role'> | Date | string;
  };

  export type UsuarioRolWhereInput = {
    AND?: UsuarioRolWhereInput | UsuarioRolWhereInput[];
    OR?: UsuarioRolWhereInput[];
    NOT?: UsuarioRolWhereInput | UsuarioRolWhereInput[];
    usuarioId?: IntFilter<'UsuarioRol'> | number;
    roleId?: IntFilter<'UsuarioRol'> | number;
    usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>;
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>;
  };

  export type UsuarioRolOrderByWithRelationInput = {
    usuarioId?: SortOrder;
    roleId?: SortOrder;
    usuario?: UsuarioOrderByWithRelationInput;
    role?: RoleOrderByWithRelationInput;
  };

  export type UsuarioRolWhereUniqueInput = Prisma.AtLeast<
    {
      usuarioId_roleId?: UsuarioRolUsuarioIdRoleIdCompoundUniqueInput;
      AND?: UsuarioRolWhereInput | UsuarioRolWhereInput[];
      OR?: UsuarioRolWhereInput[];
      NOT?: UsuarioRolWhereInput | UsuarioRolWhereInput[];
      usuarioId?: IntFilter<'UsuarioRol'> | number;
      roleId?: IntFilter<'UsuarioRol'> | number;
      usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>;
      role?: XOR<RoleScalarRelationFilter, RoleWhereInput>;
    },
    'usuarioId_roleId'
  >;

  export type UsuarioRolOrderByWithAggregationInput = {
    usuarioId?: SortOrder;
    roleId?: SortOrder;
    _count?: UsuarioRolCountOrderByAggregateInput;
    _avg?: UsuarioRolAvgOrderByAggregateInput;
    _max?: UsuarioRolMaxOrderByAggregateInput;
    _min?: UsuarioRolMinOrderByAggregateInput;
    _sum?: UsuarioRolSumOrderByAggregateInput;
  };

  export type UsuarioRolScalarWhereWithAggregatesInput = {
    AND?:
      | UsuarioRolScalarWhereWithAggregatesInput
      | UsuarioRolScalarWhereWithAggregatesInput[];
    OR?: UsuarioRolScalarWhereWithAggregatesInput[];
    NOT?:
      | UsuarioRolScalarWhereWithAggregatesInput
      | UsuarioRolScalarWhereWithAggregatesInput[];
    usuarioId?: IntWithAggregatesFilter<'UsuarioRol'> | number;
    roleId?: IntWithAggregatesFilter<'UsuarioRol'> | number;
  };

  export type FavoritoWhereInput = {
    AND?: FavoritoWhereInput | FavoritoWhereInput[];
    OR?: FavoritoWhereInput[];
    NOT?: FavoritoWhereInput | FavoritoWhereInput[];
    id?: IntFilter<'Favorito'> | number;
    usuarioId?: IntFilter<'Favorito'> | number;
    productoId?: IntFilter<'Favorito'> | number;
    creadoEn?: DateTimeFilter<'Favorito'> | Date | string;
    usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>;
    producto?: XOR<ProductoScalarRelationFilter, ProductoWhereInput>;
  };

  export type FavoritoOrderByWithRelationInput = {
    id?: SortOrder;
    usuarioId?: SortOrder;
    productoId?: SortOrder;
    creadoEn?: SortOrder;
    usuario?: UsuarioOrderByWithRelationInput;
    producto?: ProductoOrderByWithRelationInput;
  };

  export type FavoritoWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      usuarioId_productoId?: FavoritoUsuarioIdProductoIdCompoundUniqueInput;
      AND?: FavoritoWhereInput | FavoritoWhereInput[];
      OR?: FavoritoWhereInput[];
      NOT?: FavoritoWhereInput | FavoritoWhereInput[];
      usuarioId?: IntFilter<'Favorito'> | number;
      productoId?: IntFilter<'Favorito'> | number;
      creadoEn?: DateTimeFilter<'Favorito'> | Date | string;
      usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>;
      producto?: XOR<ProductoScalarRelationFilter, ProductoWhereInput>;
    },
    'id' | 'usuarioId_productoId'
  >;

  export type FavoritoOrderByWithAggregationInput = {
    id?: SortOrder;
    usuarioId?: SortOrder;
    productoId?: SortOrder;
    creadoEn?: SortOrder;
    _count?: FavoritoCountOrderByAggregateInput;
    _avg?: FavoritoAvgOrderByAggregateInput;
    _max?: FavoritoMaxOrderByAggregateInput;
    _min?: FavoritoMinOrderByAggregateInput;
    _sum?: FavoritoSumOrderByAggregateInput;
  };

  export type FavoritoScalarWhereWithAggregatesInput = {
    AND?:
      | FavoritoScalarWhereWithAggregatesInput
      | FavoritoScalarWhereWithAggregatesInput[];
    OR?: FavoritoScalarWhereWithAggregatesInput[];
    NOT?:
      | FavoritoScalarWhereWithAggregatesInput
      | FavoritoScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<'Favorito'> | number;
    usuarioId?: IntWithAggregatesFilter<'Favorito'> | number;
    productoId?: IntWithAggregatesFilter<'Favorito'> | number;
    creadoEn?: DateTimeWithAggregatesFilter<'Favorito'> | Date | string;
  };

  export type CursoWhereInput = {
    AND?: CursoWhereInput | CursoWhereInput[];
    OR?: CursoWhereInput[];
    NOT?: CursoWhereInput | CursoWhereInput[];
    id?: IntFilter<'Curso'> | number;
    slug?: StringFilter<'Curso'> | string;
    titulo?: StringFilter<'Curso'> | string;
    resumen?: StringNullableFilter<'Curso'> | string | null;
    descripcionMD?: StringNullableFilter<'Curso'> | string | null;
    requisitos?: StringNullableFilter<'Curso'> | string | null;
    precio?: IntFilter<'Curso'> | number;
    publicado?: BoolFilter<'Curso'> | boolean;
    nivel?: EnumNivelCursoFilter<'Curso'> | $Enums.NivelCurso;
    portada?: StringNullableFilter<'Curso'> | string | null;
    destacado?: BoolFilter<'Curso'> | boolean;
    tags?: JsonNullableFilter<'Curso'>;
    ratingProm?:
      | DecimalNullableFilter<'Curso'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    ratingConteo?: IntFilter<'Curso'> | number;
    creadoEn?: DateTimeFilter<'Curso'> | Date | string;
    instructorId?: IntNullableFilter<'Curso'> | number | null;
    instructor?: XOR<
      UsuarioNullableScalarRelationFilter,
      UsuarioWhereInput
    > | null;
    modulos?: ModuloListRelationFilter;
    resenas?: ResenaListRelationFilter;
    inscripciones?: InscripcionListRelationFilter;
    itemsCarrito?: ItemCarritoListRelationFilter;
  };

  export type CursoOrderByWithRelationInput = {
    id?: SortOrder;
    slug?: SortOrder;
    titulo?: SortOrder;
    resumen?: SortOrderInput | SortOrder;
    descripcionMD?: SortOrderInput | SortOrder;
    requisitos?: SortOrderInput | SortOrder;
    precio?: SortOrder;
    publicado?: SortOrder;
    nivel?: SortOrder;
    portada?: SortOrderInput | SortOrder;
    destacado?: SortOrder;
    tags?: SortOrderInput | SortOrder;
    ratingProm?: SortOrderInput | SortOrder;
    ratingConteo?: SortOrder;
    creadoEn?: SortOrder;
    instructorId?: SortOrderInput | SortOrder;
    instructor?: UsuarioOrderByWithRelationInput;
    modulos?: ModuloOrderByRelationAggregateInput;
    resenas?: ResenaOrderByRelationAggregateInput;
    inscripciones?: InscripcionOrderByRelationAggregateInput;
    itemsCarrito?: ItemCarritoOrderByRelationAggregateInput;
    _relevance?: CursoOrderByRelevanceInput;
  };

  export type CursoWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      slug?: string;
      AND?: CursoWhereInput | CursoWhereInput[];
      OR?: CursoWhereInput[];
      NOT?: CursoWhereInput | CursoWhereInput[];
      titulo?: StringFilter<'Curso'> | string;
      resumen?: StringNullableFilter<'Curso'> | string | null;
      descripcionMD?: StringNullableFilter<'Curso'> | string | null;
      requisitos?: StringNullableFilter<'Curso'> | string | null;
      precio?: IntFilter<'Curso'> | number;
      publicado?: BoolFilter<'Curso'> | boolean;
      nivel?: EnumNivelCursoFilter<'Curso'> | $Enums.NivelCurso;
      portada?: StringNullableFilter<'Curso'> | string | null;
      destacado?: BoolFilter<'Curso'> | boolean;
      tags?: JsonNullableFilter<'Curso'>;
      ratingProm?:
        | DecimalNullableFilter<'Curso'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      ratingConteo?: IntFilter<'Curso'> | number;
      creadoEn?: DateTimeFilter<'Curso'> | Date | string;
      instructorId?: IntNullableFilter<'Curso'> | number | null;
      instructor?: XOR<
        UsuarioNullableScalarRelationFilter,
        UsuarioWhereInput
      > | null;
      modulos?: ModuloListRelationFilter;
      resenas?: ResenaListRelationFilter;
      inscripciones?: InscripcionListRelationFilter;
      itemsCarrito?: ItemCarritoListRelationFilter;
    },
    'id' | 'slug'
  >;

  export type CursoOrderByWithAggregationInput = {
    id?: SortOrder;
    slug?: SortOrder;
    titulo?: SortOrder;
    resumen?: SortOrderInput | SortOrder;
    descripcionMD?: SortOrderInput | SortOrder;
    requisitos?: SortOrderInput | SortOrder;
    precio?: SortOrder;
    publicado?: SortOrder;
    nivel?: SortOrder;
    portada?: SortOrderInput | SortOrder;
    destacado?: SortOrder;
    tags?: SortOrderInput | SortOrder;
    ratingProm?: SortOrderInput | SortOrder;
    ratingConteo?: SortOrder;
    creadoEn?: SortOrder;
    instructorId?: SortOrderInput | SortOrder;
    _count?: CursoCountOrderByAggregateInput;
    _avg?: CursoAvgOrderByAggregateInput;
    _max?: CursoMaxOrderByAggregateInput;
    _min?: CursoMinOrderByAggregateInput;
    _sum?: CursoSumOrderByAggregateInput;
  };

  export type CursoScalarWhereWithAggregatesInput = {
    AND?:
      | CursoScalarWhereWithAggregatesInput
      | CursoScalarWhereWithAggregatesInput[];
    OR?: CursoScalarWhereWithAggregatesInput[];
    NOT?:
      | CursoScalarWhereWithAggregatesInput
      | CursoScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<'Curso'> | number;
    slug?: StringWithAggregatesFilter<'Curso'> | string;
    titulo?: StringWithAggregatesFilter<'Curso'> | string;
    resumen?: StringNullableWithAggregatesFilter<'Curso'> | string | null;
    descripcionMD?: StringNullableWithAggregatesFilter<'Curso'> | string | null;
    requisitos?: StringNullableWithAggregatesFilter<'Curso'> | string | null;
    precio?: IntWithAggregatesFilter<'Curso'> | number;
    publicado?: BoolWithAggregatesFilter<'Curso'> | boolean;
    nivel?: EnumNivelCursoWithAggregatesFilter<'Curso'> | $Enums.NivelCurso;
    portada?: StringNullableWithAggregatesFilter<'Curso'> | string | null;
    destacado?: BoolWithAggregatesFilter<'Curso'> | boolean;
    tags?: JsonNullableWithAggregatesFilter<'Curso'>;
    ratingProm?:
      | DecimalNullableWithAggregatesFilter<'Curso'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    ratingConteo?: IntWithAggregatesFilter<'Curso'> | number;
    creadoEn?: DateTimeWithAggregatesFilter<'Curso'> | Date | string;
    instructorId?: IntNullableWithAggregatesFilter<'Curso'> | number | null;
  };

  export type InscripcionWhereInput = {
    AND?: InscripcionWhereInput | InscripcionWhereInput[];
    OR?: InscripcionWhereInput[];
    NOT?: InscripcionWhereInput | InscripcionWhereInput[];
    id?: IntFilter<'Inscripcion'> | number;
    usuarioId?: IntFilter<'Inscripcion'> | number;
    cursoId?: IntFilter<'Inscripcion'> | number;
    estado?:
      | EnumEstadoInscripcionFilter<'Inscripcion'>
      | $Enums.EstadoInscripcion;
    progreso?: JsonFilter<'Inscripcion'>;
    creadoEn?: DateTimeFilter<'Inscripcion'> | Date | string;
    actualizadoEn?: DateTimeFilter<'Inscripcion'> | Date | string;
    usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>;
    curso?: XOR<CursoScalarRelationFilter, CursoWhereInput>;
  };

  export type InscripcionOrderByWithRelationInput = {
    id?: SortOrder;
    usuarioId?: SortOrder;
    cursoId?: SortOrder;
    estado?: SortOrder;
    progreso?: SortOrder;
    creadoEn?: SortOrder;
    actualizadoEn?: SortOrder;
    usuario?: UsuarioOrderByWithRelationInput;
    curso?: CursoOrderByWithRelationInput;
  };

  export type InscripcionWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      usuarioId_cursoId?: InscripcionUsuarioIdCursoIdCompoundUniqueInput;
      AND?: InscripcionWhereInput | InscripcionWhereInput[];
      OR?: InscripcionWhereInput[];
      NOT?: InscripcionWhereInput | InscripcionWhereInput[];
      usuarioId?: IntFilter<'Inscripcion'> | number;
      cursoId?: IntFilter<'Inscripcion'> | number;
      estado?:
        | EnumEstadoInscripcionFilter<'Inscripcion'>
        | $Enums.EstadoInscripcion;
      progreso?: JsonFilter<'Inscripcion'>;
      creadoEn?: DateTimeFilter<'Inscripcion'> | Date | string;
      actualizadoEn?: DateTimeFilter<'Inscripcion'> | Date | string;
      usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>;
      curso?: XOR<CursoScalarRelationFilter, CursoWhereInput>;
    },
    'id' | 'usuarioId_cursoId'
  >;

  export type InscripcionOrderByWithAggregationInput = {
    id?: SortOrder;
    usuarioId?: SortOrder;
    cursoId?: SortOrder;
    estado?: SortOrder;
    progreso?: SortOrder;
    creadoEn?: SortOrder;
    actualizadoEn?: SortOrder;
    _count?: InscripcionCountOrderByAggregateInput;
    _avg?: InscripcionAvgOrderByAggregateInput;
    _max?: InscripcionMaxOrderByAggregateInput;
    _min?: InscripcionMinOrderByAggregateInput;
    _sum?: InscripcionSumOrderByAggregateInput;
  };

  export type InscripcionScalarWhereWithAggregatesInput = {
    AND?:
      | InscripcionScalarWhereWithAggregatesInput
      | InscripcionScalarWhereWithAggregatesInput[];
    OR?: InscripcionScalarWhereWithAggregatesInput[];
    NOT?:
      | InscripcionScalarWhereWithAggregatesInput
      | InscripcionScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<'Inscripcion'> | number;
    usuarioId?: IntWithAggregatesFilter<'Inscripcion'> | number;
    cursoId?: IntWithAggregatesFilter<'Inscripcion'> | number;
    estado?:
      | EnumEstadoInscripcionWithAggregatesFilter<'Inscripcion'>
      | $Enums.EstadoInscripcion;
    progreso?: JsonWithAggregatesFilter<'Inscripcion'>;
    creadoEn?: DateTimeWithAggregatesFilter<'Inscripcion'> | Date | string;
    actualizadoEn?: DateTimeWithAggregatesFilter<'Inscripcion'> | Date | string;
  };

  export type ModuloWhereInput = {
    AND?: ModuloWhereInput | ModuloWhereInput[];
    OR?: ModuloWhereInput[];
    NOT?: ModuloWhereInput | ModuloWhereInput[];
    id?: IntFilter<'Modulo'> | number;
    cursoId?: IntFilter<'Modulo'> | number;
    titulo?: StringFilter<'Modulo'> | string;
    orden?: IntFilter<'Modulo'> | number;
    parentId?: IntNullableFilter<'Modulo'> | number | null;
    curso?: XOR<CursoScalarRelationFilter, CursoWhereInput>;
    lecciones?: LeccionListRelationFilter;
  };

  export type ModuloOrderByWithRelationInput = {
    id?: SortOrder;
    cursoId?: SortOrder;
    titulo?: SortOrder;
    orden?: SortOrder;
    parentId?: SortOrderInput | SortOrder;
    curso?: CursoOrderByWithRelationInput;
    lecciones?: LeccionOrderByRelationAggregateInput;
    _relevance?: ModuloOrderByRelevanceInput;
  };

  export type ModuloWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      AND?: ModuloWhereInput | ModuloWhereInput[];
      OR?: ModuloWhereInput[];
      NOT?: ModuloWhereInput | ModuloWhereInput[];
      cursoId?: IntFilter<'Modulo'> | number;
      titulo?: StringFilter<'Modulo'> | string;
      orden?: IntFilter<'Modulo'> | number;
      parentId?: IntNullableFilter<'Modulo'> | number | null;
      curso?: XOR<CursoScalarRelationFilter, CursoWhereInput>;
      lecciones?: LeccionListRelationFilter;
    },
    'id'
  >;

  export type ModuloOrderByWithAggregationInput = {
    id?: SortOrder;
    cursoId?: SortOrder;
    titulo?: SortOrder;
    orden?: SortOrder;
    parentId?: SortOrderInput | SortOrder;
    _count?: ModuloCountOrderByAggregateInput;
    _avg?: ModuloAvgOrderByAggregateInput;
    _max?: ModuloMaxOrderByAggregateInput;
    _min?: ModuloMinOrderByAggregateInput;
    _sum?: ModuloSumOrderByAggregateInput;
  };

  export type ModuloScalarWhereWithAggregatesInput = {
    AND?:
      | ModuloScalarWhereWithAggregatesInput
      | ModuloScalarWhereWithAggregatesInput[];
    OR?: ModuloScalarWhereWithAggregatesInput[];
    NOT?:
      | ModuloScalarWhereWithAggregatesInput
      | ModuloScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<'Modulo'> | number;
    cursoId?: IntWithAggregatesFilter<'Modulo'> | number;
    titulo?: StringWithAggregatesFilter<'Modulo'> | string;
    orden?: IntWithAggregatesFilter<'Modulo'> | number;
    parentId?: IntNullableWithAggregatesFilter<'Modulo'> | number | null;
  };

  export type LeccionWhereInput = {
    AND?: LeccionWhereInput | LeccionWhereInput[];
    OR?: LeccionWhereInput[];
    NOT?: LeccionWhereInput | LeccionWhereInput[];
    id?: IntFilter<'Leccion'> | number;
    moduloId?: IntFilter<'Leccion'> | number;
    titulo?: StringFilter<'Leccion'> | string;
    rutaSrc?: StringNullableFilter<'Leccion'> | string | null;
    orden?: IntFilter<'Leccion'> | number;
    tipo?: EnumTipoLeccionFilter<'Leccion'> | $Enums.TipoLeccion;
    descripcion?: StringNullableFilter<'Leccion'> | string | null;
    contenido?: JsonNullableFilter<'Leccion'>;
    previewUrl?: StringNullableFilter<'Leccion'> | string | null;
    duracion?: FloatFilter<'Leccion'> | number;
    modulo?: XOR<ModuloScalarRelationFilter, ModuloWhereInput>;
  };

  export type LeccionOrderByWithRelationInput = {
    id?: SortOrder;
    moduloId?: SortOrder;
    titulo?: SortOrder;
    rutaSrc?: SortOrderInput | SortOrder;
    orden?: SortOrder;
    tipo?: SortOrder;
    descripcion?: SortOrderInput | SortOrder;
    contenido?: SortOrderInput | SortOrder;
    previewUrl?: SortOrderInput | SortOrder;
    duracion?: SortOrder;
    modulo?: ModuloOrderByWithRelationInput;
    _relevance?: LeccionOrderByRelevanceInput;
  };

  export type LeccionWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      AND?: LeccionWhereInput | LeccionWhereInput[];
      OR?: LeccionWhereInput[];
      NOT?: LeccionWhereInput | LeccionWhereInput[];
      moduloId?: IntFilter<'Leccion'> | number;
      titulo?: StringFilter<'Leccion'> | string;
      rutaSrc?: StringNullableFilter<'Leccion'> | string | null;
      orden?: IntFilter<'Leccion'> | number;
      tipo?: EnumTipoLeccionFilter<'Leccion'> | $Enums.TipoLeccion;
      descripcion?: StringNullableFilter<'Leccion'> | string | null;
      contenido?: JsonNullableFilter<'Leccion'>;
      previewUrl?: StringNullableFilter<'Leccion'> | string | null;
      duracion?: FloatFilter<'Leccion'> | number;
      modulo?: XOR<ModuloScalarRelationFilter, ModuloWhereInput>;
    },
    'id'
  >;

  export type LeccionOrderByWithAggregationInput = {
    id?: SortOrder;
    moduloId?: SortOrder;
    titulo?: SortOrder;
    rutaSrc?: SortOrderInput | SortOrder;
    orden?: SortOrder;
    tipo?: SortOrder;
    descripcion?: SortOrderInput | SortOrder;
    contenido?: SortOrderInput | SortOrder;
    previewUrl?: SortOrderInput | SortOrder;
    duracion?: SortOrder;
    _count?: LeccionCountOrderByAggregateInput;
    _avg?: LeccionAvgOrderByAggregateInput;
    _max?: LeccionMaxOrderByAggregateInput;
    _min?: LeccionMinOrderByAggregateInput;
    _sum?: LeccionSumOrderByAggregateInput;
  };

  export type LeccionScalarWhereWithAggregatesInput = {
    AND?:
      | LeccionScalarWhereWithAggregatesInput
      | LeccionScalarWhereWithAggregatesInput[];
    OR?: LeccionScalarWhereWithAggregatesInput[];
    NOT?:
      | LeccionScalarWhereWithAggregatesInput
      | LeccionScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<'Leccion'> | number;
    moduloId?: IntWithAggregatesFilter<'Leccion'> | number;
    titulo?: StringWithAggregatesFilter<'Leccion'> | string;
    rutaSrc?: StringNullableWithAggregatesFilter<'Leccion'> | string | null;
    orden?: IntWithAggregatesFilter<'Leccion'> | number;
    tipo?: EnumTipoLeccionWithAggregatesFilter<'Leccion'> | $Enums.TipoLeccion;
    descripcion?: StringNullableWithAggregatesFilter<'Leccion'> | string | null;
    contenido?: JsonNullableWithAggregatesFilter<'Leccion'>;
    previewUrl?: StringNullableWithAggregatesFilter<'Leccion'> | string | null;
    duracion?: FloatWithAggregatesFilter<'Leccion'> | number;
  };

  export type LeccionTipoConfigWhereInput = {
    AND?: LeccionTipoConfigWhereInput | LeccionTipoConfigWhereInput[];
    OR?: LeccionTipoConfigWhereInput[];
    NOT?: LeccionTipoConfigWhereInput | LeccionTipoConfigWhereInput[];
    id?: IntFilter<'LeccionTipoConfig'> | number;
    tipo?: EnumTipoLeccionFilter<'LeccionTipoConfig'> | $Enums.TipoLeccion;
    schema?: JsonFilter<'LeccionTipoConfig'>;
    ui?: JsonNullableFilter<'LeccionTipoConfig'>;
    version?: IntFilter<'LeccionTipoConfig'> | number;
    creadoEn?: DateTimeFilter<'LeccionTipoConfig'> | Date | string;
    actualizadoEn?: DateTimeFilter<'LeccionTipoConfig'> | Date | string;
  };

  export type LeccionTipoConfigOrderByWithRelationInput = {
    id?: SortOrder;
    tipo?: SortOrder;
    schema?: SortOrder;
    ui?: SortOrderInput | SortOrder;
    version?: SortOrder;
    creadoEn?: SortOrder;
    actualizadoEn?: SortOrder;
  };

  export type LeccionTipoConfigWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      tipo?: $Enums.TipoLeccion;
      AND?: LeccionTipoConfigWhereInput | LeccionTipoConfigWhereInput[];
      OR?: LeccionTipoConfigWhereInput[];
      NOT?: LeccionTipoConfigWhereInput | LeccionTipoConfigWhereInput[];
      schema?: JsonFilter<'LeccionTipoConfig'>;
      ui?: JsonNullableFilter<'LeccionTipoConfig'>;
      version?: IntFilter<'LeccionTipoConfig'> | number;
      creadoEn?: DateTimeFilter<'LeccionTipoConfig'> | Date | string;
      actualizadoEn?: DateTimeFilter<'LeccionTipoConfig'> | Date | string;
    },
    'id' | 'tipo'
  >;

  export type LeccionTipoConfigOrderByWithAggregationInput = {
    id?: SortOrder;
    tipo?: SortOrder;
    schema?: SortOrder;
    ui?: SortOrderInput | SortOrder;
    version?: SortOrder;
    creadoEn?: SortOrder;
    actualizadoEn?: SortOrder;
    _count?: LeccionTipoConfigCountOrderByAggregateInput;
    _avg?: LeccionTipoConfigAvgOrderByAggregateInput;
    _max?: LeccionTipoConfigMaxOrderByAggregateInput;
    _min?: LeccionTipoConfigMinOrderByAggregateInput;
    _sum?: LeccionTipoConfigSumOrderByAggregateInput;
  };

  export type LeccionTipoConfigScalarWhereWithAggregatesInput = {
    AND?:
      | LeccionTipoConfigScalarWhereWithAggregatesInput
      | LeccionTipoConfigScalarWhereWithAggregatesInput[];
    OR?: LeccionTipoConfigScalarWhereWithAggregatesInput[];
    NOT?:
      | LeccionTipoConfigScalarWhereWithAggregatesInput
      | LeccionTipoConfigScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<'LeccionTipoConfig'> | number;
    tipo?:
      | EnumTipoLeccionWithAggregatesFilter<'LeccionTipoConfig'>
      | $Enums.TipoLeccion;
    schema?: JsonWithAggregatesFilter<'LeccionTipoConfig'>;
    ui?: JsonNullableWithAggregatesFilter<'LeccionTipoConfig'>;
    version?: IntWithAggregatesFilter<'LeccionTipoConfig'> | number;
    creadoEn?:
      | DateTimeWithAggregatesFilter<'LeccionTipoConfig'>
      | Date
      | string;
    actualizadoEn?:
      | DateTimeWithAggregatesFilter<'LeccionTipoConfig'>
      | Date
      | string;
  };

  export type ProductoWhereInput = {
    AND?: ProductoWhereInput | ProductoWhereInput[];
    OR?: ProductoWhereInput[];
    NOT?: ProductoWhereInput | ProductoWhereInput[];
    id?: IntFilter<'Producto'> | number;
    slug?: StringFilter<'Producto'> | string;
    titulo?: StringFilter<'Producto'> | string;
    precio?: IntFilter<'Producto'> | number;
    stock?: IntFilter<'Producto'> | number;
    publicado?: BoolFilter<'Producto'> | boolean;
    destacado?: BoolFilter<'Producto'> | boolean;
    imagen?: StringNullableFilter<'Producto'> | string | null;
    descripcionMD?: StringNullableFilter<'Producto'> | string | null;
    precioLista?: IntNullableFilter<'Producto'> | number | null;
    ratingProm?:
      | DecimalNullableFilter<'Producto'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    ratingConteo?: IntFilter<'Producto'> | number;
    creadoEn?: DateTimeFilter<'Producto'> | Date | string;
    marcaId?: IntNullableFilter<'Producto'> | number | null;
    categoriaId?: IntNullableFilter<'Producto'> | number | null;
    marca?: XOR<MarcaNullableScalarRelationFilter, MarcaWhereInput> | null;
    categoria?: XOR<
      CategoriaNullableScalarRelationFilter,
      CategoriaWhereInput
    > | null;
    imagenes?: ProductoImagenListRelationFilter;
    resenas?: ResenaListRelationFilter;
    favoritos?: FavoritoListRelationFilter;
    itemsCarrito?: ItemCarritoListRelationFilter;
  };

  export type ProductoOrderByWithRelationInput = {
    id?: SortOrder;
    slug?: SortOrder;
    titulo?: SortOrder;
    precio?: SortOrder;
    stock?: SortOrder;
    publicado?: SortOrder;
    destacado?: SortOrder;
    imagen?: SortOrderInput | SortOrder;
    descripcionMD?: SortOrderInput | SortOrder;
    precioLista?: SortOrderInput | SortOrder;
    ratingProm?: SortOrderInput | SortOrder;
    ratingConteo?: SortOrder;
    creadoEn?: SortOrder;
    marcaId?: SortOrderInput | SortOrder;
    categoriaId?: SortOrderInput | SortOrder;
    marca?: MarcaOrderByWithRelationInput;
    categoria?: CategoriaOrderByWithRelationInput;
    imagenes?: ProductoImagenOrderByRelationAggregateInput;
    resenas?: ResenaOrderByRelationAggregateInput;
    favoritos?: FavoritoOrderByRelationAggregateInput;
    itemsCarrito?: ItemCarritoOrderByRelationAggregateInput;
    _relevance?: ProductoOrderByRelevanceInput;
  };

  export type ProductoWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      slug?: string;
      AND?: ProductoWhereInput | ProductoWhereInput[];
      OR?: ProductoWhereInput[];
      NOT?: ProductoWhereInput | ProductoWhereInput[];
      titulo?: StringFilter<'Producto'> | string;
      precio?: IntFilter<'Producto'> | number;
      stock?: IntFilter<'Producto'> | number;
      publicado?: BoolFilter<'Producto'> | boolean;
      destacado?: BoolFilter<'Producto'> | boolean;
      imagen?: StringNullableFilter<'Producto'> | string | null;
      descripcionMD?: StringNullableFilter<'Producto'> | string | null;
      precioLista?: IntNullableFilter<'Producto'> | number | null;
      ratingProm?:
        | DecimalNullableFilter<'Producto'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      ratingConteo?: IntFilter<'Producto'> | number;
      creadoEn?: DateTimeFilter<'Producto'> | Date | string;
      marcaId?: IntNullableFilter<'Producto'> | number | null;
      categoriaId?: IntNullableFilter<'Producto'> | number | null;
      marca?: XOR<MarcaNullableScalarRelationFilter, MarcaWhereInput> | null;
      categoria?: XOR<
        CategoriaNullableScalarRelationFilter,
        CategoriaWhereInput
      > | null;
      imagenes?: ProductoImagenListRelationFilter;
      resenas?: ResenaListRelationFilter;
      favoritos?: FavoritoListRelationFilter;
      itemsCarrito?: ItemCarritoListRelationFilter;
    },
    'id' | 'slug'
  >;

  export type ProductoOrderByWithAggregationInput = {
    id?: SortOrder;
    slug?: SortOrder;
    titulo?: SortOrder;
    precio?: SortOrder;
    stock?: SortOrder;
    publicado?: SortOrder;
    destacado?: SortOrder;
    imagen?: SortOrderInput | SortOrder;
    descripcionMD?: SortOrderInput | SortOrder;
    precioLista?: SortOrderInput | SortOrder;
    ratingProm?: SortOrderInput | SortOrder;
    ratingConteo?: SortOrder;
    creadoEn?: SortOrder;
    marcaId?: SortOrderInput | SortOrder;
    categoriaId?: SortOrderInput | SortOrder;
    _count?: ProductoCountOrderByAggregateInput;
    _avg?: ProductoAvgOrderByAggregateInput;
    _max?: ProductoMaxOrderByAggregateInput;
    _min?: ProductoMinOrderByAggregateInput;
    _sum?: ProductoSumOrderByAggregateInput;
  };

  export type ProductoScalarWhereWithAggregatesInput = {
    AND?:
      | ProductoScalarWhereWithAggregatesInput
      | ProductoScalarWhereWithAggregatesInput[];
    OR?: ProductoScalarWhereWithAggregatesInput[];
    NOT?:
      | ProductoScalarWhereWithAggregatesInput
      | ProductoScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<'Producto'> | number;
    slug?: StringWithAggregatesFilter<'Producto'> | string;
    titulo?: StringWithAggregatesFilter<'Producto'> | string;
    precio?: IntWithAggregatesFilter<'Producto'> | number;
    stock?: IntWithAggregatesFilter<'Producto'> | number;
    publicado?: BoolWithAggregatesFilter<'Producto'> | boolean;
    destacado?: BoolWithAggregatesFilter<'Producto'> | boolean;
    imagen?: StringNullableWithAggregatesFilter<'Producto'> | string | null;
    descripcionMD?:
      | StringNullableWithAggregatesFilter<'Producto'>
      | string
      | null;
    precioLista?: IntNullableWithAggregatesFilter<'Producto'> | number | null;
    ratingProm?:
      | DecimalNullableWithAggregatesFilter<'Producto'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    ratingConteo?: IntWithAggregatesFilter<'Producto'> | number;
    creadoEn?: DateTimeWithAggregatesFilter<'Producto'> | Date | string;
    marcaId?: IntNullableWithAggregatesFilter<'Producto'> | number | null;
    categoriaId?: IntNullableWithAggregatesFilter<'Producto'> | number | null;
  };

  export type ProductoImagenWhereInput = {
    AND?: ProductoImagenWhereInput | ProductoImagenWhereInput[];
    OR?: ProductoImagenWhereInput[];
    NOT?: ProductoImagenWhereInput | ProductoImagenWhereInput[];
    id?: IntFilter<'ProductoImagen'> | number;
    productoId?: IntFilter<'ProductoImagen'> | number;
    archivo?: StringFilter<'ProductoImagen'> | string;
    alt?: StringNullableFilter<'ProductoImagen'> | string | null;
    orden?: IntFilter<'ProductoImagen'> | number;
    producto?: XOR<ProductoScalarRelationFilter, ProductoWhereInput>;
  };

  export type ProductoImagenOrderByWithRelationInput = {
    id?: SortOrder;
    productoId?: SortOrder;
    archivo?: SortOrder;
    alt?: SortOrderInput | SortOrder;
    orden?: SortOrder;
    producto?: ProductoOrderByWithRelationInput;
    _relevance?: ProductoImagenOrderByRelevanceInput;
  };

  export type ProductoImagenWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      AND?: ProductoImagenWhereInput | ProductoImagenWhereInput[];
      OR?: ProductoImagenWhereInput[];
      NOT?: ProductoImagenWhereInput | ProductoImagenWhereInput[];
      productoId?: IntFilter<'ProductoImagen'> | number;
      archivo?: StringFilter<'ProductoImagen'> | string;
      alt?: StringNullableFilter<'ProductoImagen'> | string | null;
      orden?: IntFilter<'ProductoImagen'> | number;
      producto?: XOR<ProductoScalarRelationFilter, ProductoWhereInput>;
    },
    'id'
  >;

  export type ProductoImagenOrderByWithAggregationInput = {
    id?: SortOrder;
    productoId?: SortOrder;
    archivo?: SortOrder;
    alt?: SortOrderInput | SortOrder;
    orden?: SortOrder;
    _count?: ProductoImagenCountOrderByAggregateInput;
    _avg?: ProductoImagenAvgOrderByAggregateInput;
    _max?: ProductoImagenMaxOrderByAggregateInput;
    _min?: ProductoImagenMinOrderByAggregateInput;
    _sum?: ProductoImagenSumOrderByAggregateInput;
  };

  export type ProductoImagenScalarWhereWithAggregatesInput = {
    AND?:
      | ProductoImagenScalarWhereWithAggregatesInput
      | ProductoImagenScalarWhereWithAggregatesInput[];
    OR?: ProductoImagenScalarWhereWithAggregatesInput[];
    NOT?:
      | ProductoImagenScalarWhereWithAggregatesInput
      | ProductoImagenScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<'ProductoImagen'> | number;
    productoId?: IntWithAggregatesFilter<'ProductoImagen'> | number;
    archivo?: StringWithAggregatesFilter<'ProductoImagen'> | string;
    alt?: StringNullableWithAggregatesFilter<'ProductoImagen'> | string | null;
    orden?: IntWithAggregatesFilter<'ProductoImagen'> | number;
  };

  export type MarcaWhereInput = {
    AND?: MarcaWhereInput | MarcaWhereInput[];
    OR?: MarcaWhereInput[];
    NOT?: MarcaWhereInput | MarcaWhereInput[];
    id?: IntFilter<'Marca'> | number;
    slug?: StringFilter<'Marca'> | string;
    nombre?: StringFilter<'Marca'> | string;
    imagen?: StringNullableFilter<'Marca'> | string | null;
    activa?: BoolFilter<'Marca'> | boolean;
    orden?: IntFilter<'Marca'> | number;
    creadoEn?: DateTimeFilter<'Marca'> | Date | string;
    productos?: ProductoListRelationFilter;
  };

  export type MarcaOrderByWithRelationInput = {
    id?: SortOrder;
    slug?: SortOrder;
    nombre?: SortOrder;
    imagen?: SortOrderInput | SortOrder;
    activa?: SortOrder;
    orden?: SortOrder;
    creadoEn?: SortOrder;
    productos?: ProductoOrderByRelationAggregateInput;
    _relevance?: MarcaOrderByRelevanceInput;
  };

  export type MarcaWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      slug?: string;
      AND?: MarcaWhereInput | MarcaWhereInput[];
      OR?: MarcaWhereInput[];
      NOT?: MarcaWhereInput | MarcaWhereInput[];
      nombre?: StringFilter<'Marca'> | string;
      imagen?: StringNullableFilter<'Marca'> | string | null;
      activa?: BoolFilter<'Marca'> | boolean;
      orden?: IntFilter<'Marca'> | number;
      creadoEn?: DateTimeFilter<'Marca'> | Date | string;
      productos?: ProductoListRelationFilter;
    },
    'id' | 'slug'
  >;

  export type MarcaOrderByWithAggregationInput = {
    id?: SortOrder;
    slug?: SortOrder;
    nombre?: SortOrder;
    imagen?: SortOrderInput | SortOrder;
    activa?: SortOrder;
    orden?: SortOrder;
    creadoEn?: SortOrder;
    _count?: MarcaCountOrderByAggregateInput;
    _avg?: MarcaAvgOrderByAggregateInput;
    _max?: MarcaMaxOrderByAggregateInput;
    _min?: MarcaMinOrderByAggregateInput;
    _sum?: MarcaSumOrderByAggregateInput;
  };

  export type MarcaScalarWhereWithAggregatesInput = {
    AND?:
      | MarcaScalarWhereWithAggregatesInput
      | MarcaScalarWhereWithAggregatesInput[];
    OR?: MarcaScalarWhereWithAggregatesInput[];
    NOT?:
      | MarcaScalarWhereWithAggregatesInput
      | MarcaScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<'Marca'> | number;
    slug?: StringWithAggregatesFilter<'Marca'> | string;
    nombre?: StringWithAggregatesFilter<'Marca'> | string;
    imagen?: StringNullableWithAggregatesFilter<'Marca'> | string | null;
    activa?: BoolWithAggregatesFilter<'Marca'> | boolean;
    orden?: IntWithAggregatesFilter<'Marca'> | number;
    creadoEn?: DateTimeWithAggregatesFilter<'Marca'> | Date | string;
  };

  export type CategoriaWhereInput = {
    AND?: CategoriaWhereInput | CategoriaWhereInput[];
    OR?: CategoriaWhereInput[];
    NOT?: CategoriaWhereInput | CategoriaWhereInput[];
    id?: IntFilter<'Categoria'> | number;
    slug?: StringFilter<'Categoria'> | string;
    nombre?: StringFilter<'Categoria'> | string;
    descripcion?: StringNullableFilter<'Categoria'> | string | null;
    imagen?: StringNullableFilter<'Categoria'> | string | null;
    activa?: BoolFilter<'Categoria'> | boolean;
    orden?: IntFilter<'Categoria'> | number;
    creadoEn?: DateTimeFilter<'Categoria'> | Date | string;
    parentId?: IntNullableFilter<'Categoria'> | number | null;
    parent?: XOR<
      CategoriaNullableScalarRelationFilter,
      CategoriaWhereInput
    > | null;
    hijos?: CategoriaListRelationFilter;
    productos?: ProductoListRelationFilter;
  };

  export type CategoriaOrderByWithRelationInput = {
    id?: SortOrder;
    slug?: SortOrder;
    nombre?: SortOrder;
    descripcion?: SortOrderInput | SortOrder;
    imagen?: SortOrderInput | SortOrder;
    activa?: SortOrder;
    orden?: SortOrder;
    creadoEn?: SortOrder;
    parentId?: SortOrderInput | SortOrder;
    parent?: CategoriaOrderByWithRelationInput;
    hijos?: CategoriaOrderByRelationAggregateInput;
    productos?: ProductoOrderByRelationAggregateInput;
    _relevance?: CategoriaOrderByRelevanceInput;
  };

  export type CategoriaWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      slug?: string;
      AND?: CategoriaWhereInput | CategoriaWhereInput[];
      OR?: CategoriaWhereInput[];
      NOT?: CategoriaWhereInput | CategoriaWhereInput[];
      nombre?: StringFilter<'Categoria'> | string;
      descripcion?: StringNullableFilter<'Categoria'> | string | null;
      imagen?: StringNullableFilter<'Categoria'> | string | null;
      activa?: BoolFilter<'Categoria'> | boolean;
      orden?: IntFilter<'Categoria'> | number;
      creadoEn?: DateTimeFilter<'Categoria'> | Date | string;
      parentId?: IntNullableFilter<'Categoria'> | number | null;
      parent?: XOR<
        CategoriaNullableScalarRelationFilter,
        CategoriaWhereInput
      > | null;
      hijos?: CategoriaListRelationFilter;
      productos?: ProductoListRelationFilter;
    },
    'id' | 'slug'
  >;

  export type CategoriaOrderByWithAggregationInput = {
    id?: SortOrder;
    slug?: SortOrder;
    nombre?: SortOrder;
    descripcion?: SortOrderInput | SortOrder;
    imagen?: SortOrderInput | SortOrder;
    activa?: SortOrder;
    orden?: SortOrder;
    creadoEn?: SortOrder;
    parentId?: SortOrderInput | SortOrder;
    _count?: CategoriaCountOrderByAggregateInput;
    _avg?: CategoriaAvgOrderByAggregateInput;
    _max?: CategoriaMaxOrderByAggregateInput;
    _min?: CategoriaMinOrderByAggregateInput;
    _sum?: CategoriaSumOrderByAggregateInput;
  };

  export type CategoriaScalarWhereWithAggregatesInput = {
    AND?:
      | CategoriaScalarWhereWithAggregatesInput
      | CategoriaScalarWhereWithAggregatesInput[];
    OR?: CategoriaScalarWhereWithAggregatesInput[];
    NOT?:
      | CategoriaScalarWhereWithAggregatesInput
      | CategoriaScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<'Categoria'> | number;
    slug?: StringWithAggregatesFilter<'Categoria'> | string;
    nombre?: StringWithAggregatesFilter<'Categoria'> | string;
    descripcion?:
      | StringNullableWithAggregatesFilter<'Categoria'>
      | string
      | null;
    imagen?: StringNullableWithAggregatesFilter<'Categoria'> | string | null;
    activa?: BoolWithAggregatesFilter<'Categoria'> | boolean;
    orden?: IntWithAggregatesFilter<'Categoria'> | number;
    creadoEn?: DateTimeWithAggregatesFilter<'Categoria'> | Date | string;
    parentId?: IntNullableWithAggregatesFilter<'Categoria'> | number | null;
  };

  export type OrdenWhereInput = {
    AND?: OrdenWhereInput | OrdenWhereInput[];
    OR?: OrdenWhereInput[];
    NOT?: OrdenWhereInput | OrdenWhereInput[];
    id?: IntFilter<'Orden'> | number;
    usuarioId?: IntFilter<'Orden'> | number;
    estado?: EnumEstadoOrdenFilter<'Orden'> | $Enums.EstadoOrden;
    total?: IntFilter<'Orden'> | number;
    moneda?: StringFilter<'Orden'> | string;
    referenciaPago?: StringNullableFilter<'Orden'> | string | null;
    creadoEn?: DateTimeFilter<'Orden'> | Date | string;
    actualizadoEn?: DateTimeFilter<'Orden'> | Date | string;
    esSuscripcion?: BoolFilter<'Orden'> | boolean;
    suscripcionActiva?: BoolNullableFilter<'Orden'> | boolean | null;
    suscripcionId?: StringNullableFilter<'Orden'> | string | null;
    suscripcionFrecuencia?: IntNullableFilter<'Orden'> | number | null;
    suscripcionTipoFrecuencia?: StringNullableFilter<'Orden'> | string | null;
    metadatos?: JsonNullableFilter<'Orden'>;
    direccionEnvioId?: IntNullableFilter<'Orden'> | number | null;
    direccionFacturacionId?: IntNullableFilter<'Orden'> | number | null;
    usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>;
    direccionEnvio?: XOR<
      DireccionNullableScalarRelationFilter,
      DireccionWhereInput
    > | null;
    direccionFacturacion?: XOR<
      DireccionNullableScalarRelationFilter,
      DireccionWhereInput
    > | null;
    items?: ItemOrdenListRelationFilter;
  };

  export type OrdenOrderByWithRelationInput = {
    id?: SortOrder;
    usuarioId?: SortOrder;
    estado?: SortOrder;
    total?: SortOrder;
    moneda?: SortOrder;
    referenciaPago?: SortOrderInput | SortOrder;
    creadoEn?: SortOrder;
    actualizadoEn?: SortOrder;
    esSuscripcion?: SortOrder;
    suscripcionActiva?: SortOrderInput | SortOrder;
    suscripcionId?: SortOrderInput | SortOrder;
    suscripcionFrecuencia?: SortOrderInput | SortOrder;
    suscripcionTipoFrecuencia?: SortOrderInput | SortOrder;
    metadatos?: SortOrderInput | SortOrder;
    direccionEnvioId?: SortOrderInput | SortOrder;
    direccionFacturacionId?: SortOrderInput | SortOrder;
    usuario?: UsuarioOrderByWithRelationInput;
    direccionEnvio?: DireccionOrderByWithRelationInput;
    direccionFacturacion?: DireccionOrderByWithRelationInput;
    items?: ItemOrdenOrderByRelationAggregateInput;
    _relevance?: OrdenOrderByRelevanceInput;
  };

  export type OrdenWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      AND?: OrdenWhereInput | OrdenWhereInput[];
      OR?: OrdenWhereInput[];
      NOT?: OrdenWhereInput | OrdenWhereInput[];
      usuarioId?: IntFilter<'Orden'> | number;
      estado?: EnumEstadoOrdenFilter<'Orden'> | $Enums.EstadoOrden;
      total?: IntFilter<'Orden'> | number;
      moneda?: StringFilter<'Orden'> | string;
      referenciaPago?: StringNullableFilter<'Orden'> | string | null;
      creadoEn?: DateTimeFilter<'Orden'> | Date | string;
      actualizadoEn?: DateTimeFilter<'Orden'> | Date | string;
      esSuscripcion?: BoolFilter<'Orden'> | boolean;
      suscripcionActiva?: BoolNullableFilter<'Orden'> | boolean | null;
      suscripcionId?: StringNullableFilter<'Orden'> | string | null;
      suscripcionFrecuencia?: IntNullableFilter<'Orden'> | number | null;
      suscripcionTipoFrecuencia?: StringNullableFilter<'Orden'> | string | null;
      metadatos?: JsonNullableFilter<'Orden'>;
      direccionEnvioId?: IntNullableFilter<'Orden'> | number | null;
      direccionFacturacionId?: IntNullableFilter<'Orden'> | number | null;
      usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>;
      direccionEnvio?: XOR<
        DireccionNullableScalarRelationFilter,
        DireccionWhereInput
      > | null;
      direccionFacturacion?: XOR<
        DireccionNullableScalarRelationFilter,
        DireccionWhereInput
      > | null;
      items?: ItemOrdenListRelationFilter;
    },
    'id'
  >;

  export type OrdenOrderByWithAggregationInput = {
    id?: SortOrder;
    usuarioId?: SortOrder;
    estado?: SortOrder;
    total?: SortOrder;
    moneda?: SortOrder;
    referenciaPago?: SortOrderInput | SortOrder;
    creadoEn?: SortOrder;
    actualizadoEn?: SortOrder;
    esSuscripcion?: SortOrder;
    suscripcionActiva?: SortOrderInput | SortOrder;
    suscripcionId?: SortOrderInput | SortOrder;
    suscripcionFrecuencia?: SortOrderInput | SortOrder;
    suscripcionTipoFrecuencia?: SortOrderInput | SortOrder;
    metadatos?: SortOrderInput | SortOrder;
    direccionEnvioId?: SortOrderInput | SortOrder;
    direccionFacturacionId?: SortOrderInput | SortOrder;
    _count?: OrdenCountOrderByAggregateInput;
    _avg?: OrdenAvgOrderByAggregateInput;
    _max?: OrdenMaxOrderByAggregateInput;
    _min?: OrdenMinOrderByAggregateInput;
    _sum?: OrdenSumOrderByAggregateInput;
  };

  export type OrdenScalarWhereWithAggregatesInput = {
    AND?:
      | OrdenScalarWhereWithAggregatesInput
      | OrdenScalarWhereWithAggregatesInput[];
    OR?: OrdenScalarWhereWithAggregatesInput[];
    NOT?:
      | OrdenScalarWhereWithAggregatesInput
      | OrdenScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<'Orden'> | number;
    usuarioId?: IntWithAggregatesFilter<'Orden'> | number;
    estado?: EnumEstadoOrdenWithAggregatesFilter<'Orden'> | $Enums.EstadoOrden;
    total?: IntWithAggregatesFilter<'Orden'> | number;
    moneda?: StringWithAggregatesFilter<'Orden'> | string;
    referenciaPago?:
      | StringNullableWithAggregatesFilter<'Orden'>
      | string
      | null;
    creadoEn?: DateTimeWithAggregatesFilter<'Orden'> | Date | string;
    actualizadoEn?: DateTimeWithAggregatesFilter<'Orden'> | Date | string;
    esSuscripcion?: BoolWithAggregatesFilter<'Orden'> | boolean;
    suscripcionActiva?:
      | BoolNullableWithAggregatesFilter<'Orden'>
      | boolean
      | null;
    suscripcionId?: StringNullableWithAggregatesFilter<'Orden'> | string | null;
    suscripcionFrecuencia?:
      | IntNullableWithAggregatesFilter<'Orden'>
      | number
      | null;
    suscripcionTipoFrecuencia?:
      | StringNullableWithAggregatesFilter<'Orden'>
      | string
      | null;
    metadatos?: JsonNullableWithAggregatesFilter<'Orden'>;
    direccionEnvioId?: IntNullableWithAggregatesFilter<'Orden'> | number | null;
    direccionFacturacionId?:
      | IntNullableWithAggregatesFilter<'Orden'>
      | number
      | null;
  };

  export type ItemOrdenWhereInput = {
    AND?: ItemOrdenWhereInput | ItemOrdenWhereInput[];
    OR?: ItemOrdenWhereInput[];
    NOT?: ItemOrdenWhereInput | ItemOrdenWhereInput[];
    id?: IntFilter<'ItemOrden'> | number;
    ordenId?: IntFilter<'ItemOrden'> | number;
    tipo?: EnumTipoItemOrdenFilter<'ItemOrden'> | $Enums.TipoItemOrden;
    refId?: IntFilter<'ItemOrden'> | number;
    titulo?: StringFilter<'ItemOrden'> | string;
    cantidad?: IntFilter<'ItemOrden'> | number;
    precioUnitario?: IntFilter<'ItemOrden'> | number;
    orden?: XOR<OrdenScalarRelationFilter, OrdenWhereInput>;
  };

  export type ItemOrdenOrderByWithRelationInput = {
    id?: SortOrder;
    ordenId?: SortOrder;
    tipo?: SortOrder;
    refId?: SortOrder;
    titulo?: SortOrder;
    cantidad?: SortOrder;
    precioUnitario?: SortOrder;
    orden?: OrdenOrderByWithRelationInput;
    _relevance?: ItemOrdenOrderByRelevanceInput;
  };

  export type ItemOrdenWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      AND?: ItemOrdenWhereInput | ItemOrdenWhereInput[];
      OR?: ItemOrdenWhereInput[];
      NOT?: ItemOrdenWhereInput | ItemOrdenWhereInput[];
      ordenId?: IntFilter<'ItemOrden'> | number;
      tipo?: EnumTipoItemOrdenFilter<'ItemOrden'> | $Enums.TipoItemOrden;
      refId?: IntFilter<'ItemOrden'> | number;
      titulo?: StringFilter<'ItemOrden'> | string;
      cantidad?: IntFilter<'ItemOrden'> | number;
      precioUnitario?: IntFilter<'ItemOrden'> | number;
      orden?: XOR<OrdenScalarRelationFilter, OrdenWhereInput>;
    },
    'id'
  >;

  export type ItemOrdenOrderByWithAggregationInput = {
    id?: SortOrder;
    ordenId?: SortOrder;
    tipo?: SortOrder;
    refId?: SortOrder;
    titulo?: SortOrder;
    cantidad?: SortOrder;
    precioUnitario?: SortOrder;
    _count?: ItemOrdenCountOrderByAggregateInput;
    _avg?: ItemOrdenAvgOrderByAggregateInput;
    _max?: ItemOrdenMaxOrderByAggregateInput;
    _min?: ItemOrdenMinOrderByAggregateInput;
    _sum?: ItemOrdenSumOrderByAggregateInput;
  };

  export type ItemOrdenScalarWhereWithAggregatesInput = {
    AND?:
      | ItemOrdenScalarWhereWithAggregatesInput
      | ItemOrdenScalarWhereWithAggregatesInput[];
    OR?: ItemOrdenScalarWhereWithAggregatesInput[];
    NOT?:
      | ItemOrdenScalarWhereWithAggregatesInput
      | ItemOrdenScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<'ItemOrden'> | number;
    ordenId?: IntWithAggregatesFilter<'ItemOrden'> | number;
    tipo?:
      | EnumTipoItemOrdenWithAggregatesFilter<'ItemOrden'>
      | $Enums.TipoItemOrden;
    refId?: IntWithAggregatesFilter<'ItemOrden'> | number;
    titulo?: StringWithAggregatesFilter<'ItemOrden'> | string;
    cantidad?: IntWithAggregatesFilter<'ItemOrden'> | number;
    precioUnitario?: IntWithAggregatesFilter<'ItemOrden'> | number;
  };

  export type PagoSuscripcionWhereInput = {
    AND?: PagoSuscripcionWhereInput | PagoSuscripcionWhereInput[];
    OR?: PagoSuscripcionWhereInput[];
    NOT?: PagoSuscripcionWhereInput | PagoSuscripcionWhereInput[];
    id?: IntFilter<'PagoSuscripcion'> | number;
    ordenId?: IntFilter<'PagoSuscripcion'> | number;
    usuarioId?: IntFilter<'PagoSuscripcion'> | number;
    referenciaPago?: StringFilter<'PagoSuscripcion'> | string;
    monto?:
      | DecimalFilter<'PagoSuscripcion'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    estado?: StringFilter<'PagoSuscripcion'> | string;
    metadatos?: JsonNullableFilter<'PagoSuscripcion'>;
    creadoEn?: DateTimeFilter<'PagoSuscripcion'> | Date | string;
    actualizadoEn?: DateTimeFilter<'PagoSuscripcion'> | Date | string;
  };

  export type PagoSuscripcionOrderByWithRelationInput = {
    id?: SortOrder;
    ordenId?: SortOrder;
    usuarioId?: SortOrder;
    referenciaPago?: SortOrder;
    monto?: SortOrder;
    estado?: SortOrder;
    metadatos?: SortOrderInput | SortOrder;
    creadoEn?: SortOrder;
    actualizadoEn?: SortOrder;
    _relevance?: PagoSuscripcionOrderByRelevanceInput;
  };

  export type PagoSuscripcionWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      AND?: PagoSuscripcionWhereInput | PagoSuscripcionWhereInput[];
      OR?: PagoSuscripcionWhereInput[];
      NOT?: PagoSuscripcionWhereInput | PagoSuscripcionWhereInput[];
      ordenId?: IntFilter<'PagoSuscripcion'> | number;
      usuarioId?: IntFilter<'PagoSuscripcion'> | number;
      referenciaPago?: StringFilter<'PagoSuscripcion'> | string;
      monto?:
        | DecimalFilter<'PagoSuscripcion'>
        | Decimal
        | DecimalJsLike
        | number
        | string;
      estado?: StringFilter<'PagoSuscripcion'> | string;
      metadatos?: JsonNullableFilter<'PagoSuscripcion'>;
      creadoEn?: DateTimeFilter<'PagoSuscripcion'> | Date | string;
      actualizadoEn?: DateTimeFilter<'PagoSuscripcion'> | Date | string;
    },
    'id'
  >;

  export type PagoSuscripcionOrderByWithAggregationInput = {
    id?: SortOrder;
    ordenId?: SortOrder;
    usuarioId?: SortOrder;
    referenciaPago?: SortOrder;
    monto?: SortOrder;
    estado?: SortOrder;
    metadatos?: SortOrderInput | SortOrder;
    creadoEn?: SortOrder;
    actualizadoEn?: SortOrder;
    _count?: PagoSuscripcionCountOrderByAggregateInput;
    _avg?: PagoSuscripcionAvgOrderByAggregateInput;
    _max?: PagoSuscripcionMaxOrderByAggregateInput;
    _min?: PagoSuscripcionMinOrderByAggregateInput;
    _sum?: PagoSuscripcionSumOrderByAggregateInput;
  };

  export type PagoSuscripcionScalarWhereWithAggregatesInput = {
    AND?:
      | PagoSuscripcionScalarWhereWithAggregatesInput
      | PagoSuscripcionScalarWhereWithAggregatesInput[];
    OR?: PagoSuscripcionScalarWhereWithAggregatesInput[];
    NOT?:
      | PagoSuscripcionScalarWhereWithAggregatesInput
      | PagoSuscripcionScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<'PagoSuscripcion'> | number;
    ordenId?: IntWithAggregatesFilter<'PagoSuscripcion'> | number;
    usuarioId?: IntWithAggregatesFilter<'PagoSuscripcion'> | number;
    referenciaPago?: StringWithAggregatesFilter<'PagoSuscripcion'> | string;
    monto?:
      | DecimalWithAggregatesFilter<'PagoSuscripcion'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    estado?: StringWithAggregatesFilter<'PagoSuscripcion'> | string;
    metadatos?: JsonNullableWithAggregatesFilter<'PagoSuscripcion'>;
    creadoEn?: DateTimeWithAggregatesFilter<'PagoSuscripcion'> | Date | string;
    actualizadoEn?:
      | DateTimeWithAggregatesFilter<'PagoSuscripcion'>
      | Date
      | string;
  };

  export type DireccionWhereInput = {
    AND?: DireccionWhereInput | DireccionWhereInput[];
    OR?: DireccionWhereInput[];
    NOT?: DireccionWhereInput | DireccionWhereInput[];
    id?: IntFilter<'Direccion'> | number;
    usuarioId?: IntFilter<'Direccion'> | number;
    etiqueta?: StringNullableFilter<'Direccion'> | string | null;
    nombre?: StringFilter<'Direccion'> | string;
    telefono?: StringNullableFilter<'Direccion'> | string | null;
    calle?: StringFilter<'Direccion'> | string;
    numero?: StringNullableFilter<'Direccion'> | string | null;
    pisoDepto?: StringNullableFilter<'Direccion'> | string | null;
    ciudad?: StringFilter<'Direccion'> | string;
    provincia?: StringFilter<'Direccion'> | string;
    cp?: StringFilter<'Direccion'> | string;
    pais?: StringFilter<'Direccion'> | string;
    predeterminada?: BoolFilter<'Direccion'> | boolean;
    creadoEn?: DateTimeFilter<'Direccion'> | Date | string;
    actualizadoEn?: DateTimeFilter<'Direccion'> | Date | string;
    ordenesEnvio?: OrdenListRelationFilter;
    ordenesFacturacion?: OrdenListRelationFilter;
  };

  export type DireccionOrderByWithRelationInput = {
    id?: SortOrder;
    usuarioId?: SortOrder;
    etiqueta?: SortOrderInput | SortOrder;
    nombre?: SortOrder;
    telefono?: SortOrderInput | SortOrder;
    calle?: SortOrder;
    numero?: SortOrderInput | SortOrder;
    pisoDepto?: SortOrderInput | SortOrder;
    ciudad?: SortOrder;
    provincia?: SortOrder;
    cp?: SortOrder;
    pais?: SortOrder;
    predeterminada?: SortOrder;
    creadoEn?: SortOrder;
    actualizadoEn?: SortOrder;
    ordenesEnvio?: OrdenOrderByRelationAggregateInput;
    ordenesFacturacion?: OrdenOrderByRelationAggregateInput;
    _relevance?: DireccionOrderByRelevanceInput;
  };

  export type DireccionWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      AND?: DireccionWhereInput | DireccionWhereInput[];
      OR?: DireccionWhereInput[];
      NOT?: DireccionWhereInput | DireccionWhereInput[];
      usuarioId?: IntFilter<'Direccion'> | number;
      etiqueta?: StringNullableFilter<'Direccion'> | string | null;
      nombre?: StringFilter<'Direccion'> | string;
      telefono?: StringNullableFilter<'Direccion'> | string | null;
      calle?: StringFilter<'Direccion'> | string;
      numero?: StringNullableFilter<'Direccion'> | string | null;
      pisoDepto?: StringNullableFilter<'Direccion'> | string | null;
      ciudad?: StringFilter<'Direccion'> | string;
      provincia?: StringFilter<'Direccion'> | string;
      cp?: StringFilter<'Direccion'> | string;
      pais?: StringFilter<'Direccion'> | string;
      predeterminada?: BoolFilter<'Direccion'> | boolean;
      creadoEn?: DateTimeFilter<'Direccion'> | Date | string;
      actualizadoEn?: DateTimeFilter<'Direccion'> | Date | string;
      ordenesEnvio?: OrdenListRelationFilter;
      ordenesFacturacion?: OrdenListRelationFilter;
    },
    'id'
  >;

  export type DireccionOrderByWithAggregationInput = {
    id?: SortOrder;
    usuarioId?: SortOrder;
    etiqueta?: SortOrderInput | SortOrder;
    nombre?: SortOrder;
    telefono?: SortOrderInput | SortOrder;
    calle?: SortOrder;
    numero?: SortOrderInput | SortOrder;
    pisoDepto?: SortOrderInput | SortOrder;
    ciudad?: SortOrder;
    provincia?: SortOrder;
    cp?: SortOrder;
    pais?: SortOrder;
    predeterminada?: SortOrder;
    creadoEn?: SortOrder;
    actualizadoEn?: SortOrder;
    _count?: DireccionCountOrderByAggregateInput;
    _avg?: DireccionAvgOrderByAggregateInput;
    _max?: DireccionMaxOrderByAggregateInput;
    _min?: DireccionMinOrderByAggregateInput;
    _sum?: DireccionSumOrderByAggregateInput;
  };

  export type DireccionScalarWhereWithAggregatesInput = {
    AND?:
      | DireccionScalarWhereWithAggregatesInput
      | DireccionScalarWhereWithAggregatesInput[];
    OR?: DireccionScalarWhereWithAggregatesInput[];
    NOT?:
      | DireccionScalarWhereWithAggregatesInput
      | DireccionScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<'Direccion'> | number;
    usuarioId?: IntWithAggregatesFilter<'Direccion'> | number;
    etiqueta?: StringNullableWithAggregatesFilter<'Direccion'> | string | null;
    nombre?: StringWithAggregatesFilter<'Direccion'> | string;
    telefono?: StringNullableWithAggregatesFilter<'Direccion'> | string | null;
    calle?: StringWithAggregatesFilter<'Direccion'> | string;
    numero?: StringNullableWithAggregatesFilter<'Direccion'> | string | null;
    pisoDepto?: StringNullableWithAggregatesFilter<'Direccion'> | string | null;
    ciudad?: StringWithAggregatesFilter<'Direccion'> | string;
    provincia?: StringWithAggregatesFilter<'Direccion'> | string;
    cp?: StringWithAggregatesFilter<'Direccion'> | string;
    pais?: StringWithAggregatesFilter<'Direccion'> | string;
    predeterminada?: BoolWithAggregatesFilter<'Direccion'> | boolean;
    creadoEn?: DateTimeWithAggregatesFilter<'Direccion'> | Date | string;
    actualizadoEn?: DateTimeWithAggregatesFilter<'Direccion'> | Date | string;
  };

  export type SliderWhereInput = {
    AND?: SliderWhereInput | SliderWhereInput[];
    OR?: SliderWhereInput[];
    NOT?: SliderWhereInput | SliderWhereInput[];
    id?: IntFilter<'Slider'> | number;
    titulo?: StringFilter<'Slider'> | string;
    alt?: StringFilter<'Slider'> | string;
    archivo?: StringFilter<'Slider'> | string;
    activa?: BoolFilter<'Slider'> | boolean;
    orden?: IntFilter<'Slider'> | number;
    creadoEn?: DateTimeFilter<'Slider'> | Date | string;
    actualizadoEn?: DateTimeFilter<'Slider'> | Date | string;
    ctaPrimarioHref?: StringNullableFilter<'Slider'> | string | null;
    ctaPrimarioTexto?: StringNullableFilter<'Slider'> | string | null;
    ctaSecundarioHref?: StringNullableFilter<'Slider'> | string | null;
    ctaSecundarioTexto?: StringNullableFilter<'Slider'> | string | null;
    descripcion?: StringNullableFilter<'Slider'> | string | null;
    etiqueta?: StringNullableFilter<'Slider'> | string | null;
    subtitulo?: StringNullableFilter<'Slider'> | string | null;
  };

  export type SliderOrderByWithRelationInput = {
    id?: SortOrder;
    titulo?: SortOrder;
    alt?: SortOrder;
    archivo?: SortOrder;
    activa?: SortOrder;
    orden?: SortOrder;
    creadoEn?: SortOrder;
    actualizadoEn?: SortOrder;
    ctaPrimarioHref?: SortOrderInput | SortOrder;
    ctaPrimarioTexto?: SortOrderInput | SortOrder;
    ctaSecundarioHref?: SortOrderInput | SortOrder;
    ctaSecundarioTexto?: SortOrderInput | SortOrder;
    descripcion?: SortOrderInput | SortOrder;
    etiqueta?: SortOrderInput | SortOrder;
    subtitulo?: SortOrderInput | SortOrder;
    _relevance?: SliderOrderByRelevanceInput;
  };

  export type SliderWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      AND?: SliderWhereInput | SliderWhereInput[];
      OR?: SliderWhereInput[];
      NOT?: SliderWhereInput | SliderWhereInput[];
      titulo?: StringFilter<'Slider'> | string;
      alt?: StringFilter<'Slider'> | string;
      archivo?: StringFilter<'Slider'> | string;
      activa?: BoolFilter<'Slider'> | boolean;
      orden?: IntFilter<'Slider'> | number;
      creadoEn?: DateTimeFilter<'Slider'> | Date | string;
      actualizadoEn?: DateTimeFilter<'Slider'> | Date | string;
      ctaPrimarioHref?: StringNullableFilter<'Slider'> | string | null;
      ctaPrimarioTexto?: StringNullableFilter<'Slider'> | string | null;
      ctaSecundarioHref?: StringNullableFilter<'Slider'> | string | null;
      ctaSecundarioTexto?: StringNullableFilter<'Slider'> | string | null;
      descripcion?: StringNullableFilter<'Slider'> | string | null;
      etiqueta?: StringNullableFilter<'Slider'> | string | null;
      subtitulo?: StringNullableFilter<'Slider'> | string | null;
    },
    'id'
  >;

  export type SliderOrderByWithAggregationInput = {
    id?: SortOrder;
    titulo?: SortOrder;
    alt?: SortOrder;
    archivo?: SortOrder;
    activa?: SortOrder;
    orden?: SortOrder;
    creadoEn?: SortOrder;
    actualizadoEn?: SortOrder;
    ctaPrimarioHref?: SortOrderInput | SortOrder;
    ctaPrimarioTexto?: SortOrderInput | SortOrder;
    ctaSecundarioHref?: SortOrderInput | SortOrder;
    ctaSecundarioTexto?: SortOrderInput | SortOrder;
    descripcion?: SortOrderInput | SortOrder;
    etiqueta?: SortOrderInput | SortOrder;
    subtitulo?: SortOrderInput | SortOrder;
    _count?: SliderCountOrderByAggregateInput;
    _avg?: SliderAvgOrderByAggregateInput;
    _max?: SliderMaxOrderByAggregateInput;
    _min?: SliderMinOrderByAggregateInput;
    _sum?: SliderSumOrderByAggregateInput;
  };

  export type SliderScalarWhereWithAggregatesInput = {
    AND?:
      | SliderScalarWhereWithAggregatesInput
      | SliderScalarWhereWithAggregatesInput[];
    OR?: SliderScalarWhereWithAggregatesInput[];
    NOT?:
      | SliderScalarWhereWithAggregatesInput
      | SliderScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<'Slider'> | number;
    titulo?: StringWithAggregatesFilter<'Slider'> | string;
    alt?: StringWithAggregatesFilter<'Slider'> | string;
    archivo?: StringWithAggregatesFilter<'Slider'> | string;
    activa?: BoolWithAggregatesFilter<'Slider'> | boolean;
    orden?: IntWithAggregatesFilter<'Slider'> | number;
    creadoEn?: DateTimeWithAggregatesFilter<'Slider'> | Date | string;
    actualizadoEn?: DateTimeWithAggregatesFilter<'Slider'> | Date | string;
    ctaPrimarioHref?:
      | StringNullableWithAggregatesFilter<'Slider'>
      | string
      | null;
    ctaPrimarioTexto?:
      | StringNullableWithAggregatesFilter<'Slider'>
      | string
      | null;
    ctaSecundarioHref?:
      | StringNullableWithAggregatesFilter<'Slider'>
      | string
      | null;
    ctaSecundarioTexto?:
      | StringNullableWithAggregatesFilter<'Slider'>
      | string
      | null;
    descripcion?: StringNullableWithAggregatesFilter<'Slider'> | string | null;
    etiqueta?: StringNullableWithAggregatesFilter<'Slider'> | string | null;
    subtitulo?: StringNullableWithAggregatesFilter<'Slider'> | string | null;
  };

  export type ResenaWhereInput = {
    AND?: ResenaWhereInput | ResenaWhereInput[];
    OR?: ResenaWhereInput[];
    NOT?: ResenaWhereInput | ResenaWhereInput[];
    id?: IntFilter<'Resena'> | number;
    cursoId?: IntNullableFilter<'Resena'> | number | null;
    productoId?: IntNullableFilter<'Resena'> | number | null;
    usuarioId?: IntFilter<'Resena'> | number;
    puntaje?: IntFilter<'Resena'> | number;
    comentario?: StringNullableFilter<'Resena'> | string | null;
    creadoEn?: DateTimeFilter<'Resena'> | Date | string;
    curso?: XOR<CursoNullableScalarRelationFilter, CursoWhereInput> | null;
    producto?: XOR<
      ProductoNullableScalarRelationFilter,
      ProductoWhereInput
    > | null;
    usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>;
    respuestas?: ResenaRespuestaListRelationFilter;
    likes?: ResenaLikeListRelationFilter;
  };

  export type ResenaOrderByWithRelationInput = {
    id?: SortOrder;
    cursoId?: SortOrderInput | SortOrder;
    productoId?: SortOrderInput | SortOrder;
    usuarioId?: SortOrder;
    puntaje?: SortOrder;
    comentario?: SortOrderInput | SortOrder;
    creadoEn?: SortOrder;
    curso?: CursoOrderByWithRelationInput;
    producto?: ProductoOrderByWithRelationInput;
    usuario?: UsuarioOrderByWithRelationInput;
    respuestas?: ResenaRespuestaOrderByRelationAggregateInput;
    likes?: ResenaLikeOrderByRelationAggregateInput;
    _relevance?: ResenaOrderByRelevanceInput;
  };

  export type ResenaWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      cursoId_usuarioId?: ResenaCursoIdUsuarioIdCompoundUniqueInput;
      productoId_usuarioId?: ResenaProductoIdUsuarioIdCompoundUniqueInput;
      AND?: ResenaWhereInput | ResenaWhereInput[];
      OR?: ResenaWhereInput[];
      NOT?: ResenaWhereInput | ResenaWhereInput[];
      cursoId?: IntNullableFilter<'Resena'> | number | null;
      productoId?: IntNullableFilter<'Resena'> | number | null;
      usuarioId?: IntFilter<'Resena'> | number;
      puntaje?: IntFilter<'Resena'> | number;
      comentario?: StringNullableFilter<'Resena'> | string | null;
      creadoEn?: DateTimeFilter<'Resena'> | Date | string;
      curso?: XOR<CursoNullableScalarRelationFilter, CursoWhereInput> | null;
      producto?: XOR<
        ProductoNullableScalarRelationFilter,
        ProductoWhereInput
      > | null;
      usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>;
      respuestas?: ResenaRespuestaListRelationFilter;
      likes?: ResenaLikeListRelationFilter;
    },
    'id' | 'cursoId_usuarioId' | 'productoId_usuarioId'
  >;

  export type ResenaOrderByWithAggregationInput = {
    id?: SortOrder;
    cursoId?: SortOrderInput | SortOrder;
    productoId?: SortOrderInput | SortOrder;
    usuarioId?: SortOrder;
    puntaje?: SortOrder;
    comentario?: SortOrderInput | SortOrder;
    creadoEn?: SortOrder;
    _count?: ResenaCountOrderByAggregateInput;
    _avg?: ResenaAvgOrderByAggregateInput;
    _max?: ResenaMaxOrderByAggregateInput;
    _min?: ResenaMinOrderByAggregateInput;
    _sum?: ResenaSumOrderByAggregateInput;
  };

  export type ResenaScalarWhereWithAggregatesInput = {
    AND?:
      | ResenaScalarWhereWithAggregatesInput
      | ResenaScalarWhereWithAggregatesInput[];
    OR?: ResenaScalarWhereWithAggregatesInput[];
    NOT?:
      | ResenaScalarWhereWithAggregatesInput
      | ResenaScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<'Resena'> | number;
    cursoId?: IntNullableWithAggregatesFilter<'Resena'> | number | null;
    productoId?: IntNullableWithAggregatesFilter<'Resena'> | number | null;
    usuarioId?: IntWithAggregatesFilter<'Resena'> | number;
    puntaje?: IntWithAggregatesFilter<'Resena'> | number;
    comentario?: StringNullableWithAggregatesFilter<'Resena'> | string | null;
    creadoEn?: DateTimeWithAggregatesFilter<'Resena'> | Date | string;
  };

  export type ResenaLikeWhereInput = {
    AND?: ResenaLikeWhereInput | ResenaLikeWhereInput[];
    OR?: ResenaLikeWhereInput[];
    NOT?: ResenaLikeWhereInput | ResenaLikeWhereInput[];
    id?: IntFilter<'ResenaLike'> | number;
    resenaId?: IntFilter<'ResenaLike'> | number;
    usuarioId?: IntFilter<'ResenaLike'> | number;
    tipo?: EnumTipoLikeFilter<'ResenaLike'> | $Enums.TipoLike;
    creadoEn?: DateTimeFilter<'ResenaLike'> | Date | string;
    resena?: XOR<ResenaScalarRelationFilter, ResenaWhereInput>;
    usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>;
  };

  export type ResenaLikeOrderByWithRelationInput = {
    id?: SortOrder;
    resenaId?: SortOrder;
    usuarioId?: SortOrder;
    tipo?: SortOrder;
    creadoEn?: SortOrder;
    resena?: ResenaOrderByWithRelationInput;
    usuario?: UsuarioOrderByWithRelationInput;
  };

  export type ResenaLikeWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      resenaId_usuarioId?: ResenaLikeResenaIdUsuarioIdCompoundUniqueInput;
      AND?: ResenaLikeWhereInput | ResenaLikeWhereInput[];
      OR?: ResenaLikeWhereInput[];
      NOT?: ResenaLikeWhereInput | ResenaLikeWhereInput[];
      resenaId?: IntFilter<'ResenaLike'> | number;
      usuarioId?: IntFilter<'ResenaLike'> | number;
      tipo?: EnumTipoLikeFilter<'ResenaLike'> | $Enums.TipoLike;
      creadoEn?: DateTimeFilter<'ResenaLike'> | Date | string;
      resena?: XOR<ResenaScalarRelationFilter, ResenaWhereInput>;
      usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>;
    },
    'id' | 'resenaId_usuarioId'
  >;

  export type ResenaLikeOrderByWithAggregationInput = {
    id?: SortOrder;
    resenaId?: SortOrder;
    usuarioId?: SortOrder;
    tipo?: SortOrder;
    creadoEn?: SortOrder;
    _count?: ResenaLikeCountOrderByAggregateInput;
    _avg?: ResenaLikeAvgOrderByAggregateInput;
    _max?: ResenaLikeMaxOrderByAggregateInput;
    _min?: ResenaLikeMinOrderByAggregateInput;
    _sum?: ResenaLikeSumOrderByAggregateInput;
  };

  export type ResenaLikeScalarWhereWithAggregatesInput = {
    AND?:
      | ResenaLikeScalarWhereWithAggregatesInput
      | ResenaLikeScalarWhereWithAggregatesInput[];
    OR?: ResenaLikeScalarWhereWithAggregatesInput[];
    NOT?:
      | ResenaLikeScalarWhereWithAggregatesInput
      | ResenaLikeScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<'ResenaLike'> | number;
    resenaId?: IntWithAggregatesFilter<'ResenaLike'> | number;
    usuarioId?: IntWithAggregatesFilter<'ResenaLike'> | number;
    tipo?: EnumTipoLikeWithAggregatesFilter<'ResenaLike'> | $Enums.TipoLike;
    creadoEn?: DateTimeWithAggregatesFilter<'ResenaLike'> | Date | string;
  };

  export type ResenaRespuestaWhereInput = {
    AND?: ResenaRespuestaWhereInput | ResenaRespuestaWhereInput[];
    OR?: ResenaRespuestaWhereInput[];
    NOT?: ResenaRespuestaWhereInput | ResenaRespuestaWhereInput[];
    id?: IntFilter<'ResenaRespuesta'> | number;
    resenaId?: IntFilter<'ResenaRespuesta'> | number;
    usuarioId?: IntFilter<'ResenaRespuesta'> | number;
    parentId?: IntNullableFilter<'ResenaRespuesta'> | number | null;
    contenido?: StringFilter<'ResenaRespuesta'> | string;
    eliminado?: BoolFilter<'ResenaRespuesta'> | boolean;
    creadoEn?: DateTimeFilter<'ResenaRespuesta'> | Date | string;
    actualizadoEn?: DateTimeFilter<'ResenaRespuesta'> | Date | string;
    resena?: XOR<ResenaScalarRelationFilter, ResenaWhereInput>;
    usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>;
    parent?: XOR<
      ResenaRespuestaNullableScalarRelationFilter,
      ResenaRespuestaWhereInput
    > | null;
    hijos?: ResenaRespuestaListRelationFilter;
  };

  export type ResenaRespuestaOrderByWithRelationInput = {
    id?: SortOrder;
    resenaId?: SortOrder;
    usuarioId?: SortOrder;
    parentId?: SortOrderInput | SortOrder;
    contenido?: SortOrder;
    eliminado?: SortOrder;
    creadoEn?: SortOrder;
    actualizadoEn?: SortOrder;
    resena?: ResenaOrderByWithRelationInput;
    usuario?: UsuarioOrderByWithRelationInput;
    parent?: ResenaRespuestaOrderByWithRelationInput;
    hijos?: ResenaRespuestaOrderByRelationAggregateInput;
    _relevance?: ResenaRespuestaOrderByRelevanceInput;
  };

  export type ResenaRespuestaWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      AND?: ResenaRespuestaWhereInput | ResenaRespuestaWhereInput[];
      OR?: ResenaRespuestaWhereInput[];
      NOT?: ResenaRespuestaWhereInput | ResenaRespuestaWhereInput[];
      resenaId?: IntFilter<'ResenaRespuesta'> | number;
      usuarioId?: IntFilter<'ResenaRespuesta'> | number;
      parentId?: IntNullableFilter<'ResenaRespuesta'> | number | null;
      contenido?: StringFilter<'ResenaRespuesta'> | string;
      eliminado?: BoolFilter<'ResenaRespuesta'> | boolean;
      creadoEn?: DateTimeFilter<'ResenaRespuesta'> | Date | string;
      actualizadoEn?: DateTimeFilter<'ResenaRespuesta'> | Date | string;
      resena?: XOR<ResenaScalarRelationFilter, ResenaWhereInput>;
      usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>;
      parent?: XOR<
        ResenaRespuestaNullableScalarRelationFilter,
        ResenaRespuestaWhereInput
      > | null;
      hijos?: ResenaRespuestaListRelationFilter;
    },
    'id'
  >;

  export type ResenaRespuestaOrderByWithAggregationInput = {
    id?: SortOrder;
    resenaId?: SortOrder;
    usuarioId?: SortOrder;
    parentId?: SortOrderInput | SortOrder;
    contenido?: SortOrder;
    eliminado?: SortOrder;
    creadoEn?: SortOrder;
    actualizadoEn?: SortOrder;
    _count?: ResenaRespuestaCountOrderByAggregateInput;
    _avg?: ResenaRespuestaAvgOrderByAggregateInput;
    _max?: ResenaRespuestaMaxOrderByAggregateInput;
    _min?: ResenaRespuestaMinOrderByAggregateInput;
    _sum?: ResenaRespuestaSumOrderByAggregateInput;
  };

  export type ResenaRespuestaScalarWhereWithAggregatesInput = {
    AND?:
      | ResenaRespuestaScalarWhereWithAggregatesInput
      | ResenaRespuestaScalarWhereWithAggregatesInput[];
    OR?: ResenaRespuestaScalarWhereWithAggregatesInput[];
    NOT?:
      | ResenaRespuestaScalarWhereWithAggregatesInput
      | ResenaRespuestaScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<'ResenaRespuesta'> | number;
    resenaId?: IntWithAggregatesFilter<'ResenaRespuesta'> | number;
    usuarioId?: IntWithAggregatesFilter<'ResenaRespuesta'> | number;
    parentId?:
      | IntNullableWithAggregatesFilter<'ResenaRespuesta'>
      | number
      | null;
    contenido?: StringWithAggregatesFilter<'ResenaRespuesta'> | string;
    eliminado?: BoolWithAggregatesFilter<'ResenaRespuesta'> | boolean;
    creadoEn?: DateTimeWithAggregatesFilter<'ResenaRespuesta'> | Date | string;
    actualizadoEn?:
      | DateTimeWithAggregatesFilter<'ResenaRespuesta'>
      | Date
      | string;
  };

  export type NotificacionWhereInput = {
    AND?: NotificacionWhereInput | NotificacionWhereInput[];
    OR?: NotificacionWhereInput[];
    NOT?: NotificacionWhereInput | NotificacionWhereInput[];
    id?: IntFilter<'Notificacion'> | number;
    usuarioId?: IntFilter<'Notificacion'> | number;
    tipo?: EnumTipoNotificacionFilter<'Notificacion'> | $Enums.TipoNotificacion;
    titulo?: StringFilter<'Notificacion'> | string;
    mensaje?: StringFilter<'Notificacion'> | string;
    leida?: BoolFilter<'Notificacion'> | boolean;
    url?: StringNullableFilter<'Notificacion'> | string | null;
    metadata?: JsonNullableFilter<'Notificacion'>;
    creadoEn?: DateTimeFilter<'Notificacion'> | Date | string;
    usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>;
  };

  export type NotificacionOrderByWithRelationInput = {
    id?: SortOrder;
    usuarioId?: SortOrder;
    tipo?: SortOrder;
    titulo?: SortOrder;
    mensaje?: SortOrder;
    leida?: SortOrder;
    url?: SortOrderInput | SortOrder;
    metadata?: SortOrderInput | SortOrder;
    creadoEn?: SortOrder;
    usuario?: UsuarioOrderByWithRelationInput;
    _relevance?: NotificacionOrderByRelevanceInput;
  };

  export type NotificacionWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      AND?: NotificacionWhereInput | NotificacionWhereInput[];
      OR?: NotificacionWhereInput[];
      NOT?: NotificacionWhereInput | NotificacionWhereInput[];
      usuarioId?: IntFilter<'Notificacion'> | number;
      tipo?:
        | EnumTipoNotificacionFilter<'Notificacion'>
        | $Enums.TipoNotificacion;
      titulo?: StringFilter<'Notificacion'> | string;
      mensaje?: StringFilter<'Notificacion'> | string;
      leida?: BoolFilter<'Notificacion'> | boolean;
      url?: StringNullableFilter<'Notificacion'> | string | null;
      metadata?: JsonNullableFilter<'Notificacion'>;
      creadoEn?: DateTimeFilter<'Notificacion'> | Date | string;
      usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>;
    },
    'id'
  >;

  export type NotificacionOrderByWithAggregationInput = {
    id?: SortOrder;
    usuarioId?: SortOrder;
    tipo?: SortOrder;
    titulo?: SortOrder;
    mensaje?: SortOrder;
    leida?: SortOrder;
    url?: SortOrderInput | SortOrder;
    metadata?: SortOrderInput | SortOrder;
    creadoEn?: SortOrder;
    _count?: NotificacionCountOrderByAggregateInput;
    _avg?: NotificacionAvgOrderByAggregateInput;
    _max?: NotificacionMaxOrderByAggregateInput;
    _min?: NotificacionMinOrderByAggregateInput;
    _sum?: NotificacionSumOrderByAggregateInput;
  };

  export type NotificacionScalarWhereWithAggregatesInput = {
    AND?:
      | NotificacionScalarWhereWithAggregatesInput
      | NotificacionScalarWhereWithAggregatesInput[];
    OR?: NotificacionScalarWhereWithAggregatesInput[];
    NOT?:
      | NotificacionScalarWhereWithAggregatesInput
      | NotificacionScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<'Notificacion'> | number;
    usuarioId?: IntWithAggregatesFilter<'Notificacion'> | number;
    tipo?:
      | EnumTipoNotificacionWithAggregatesFilter<'Notificacion'>
      | $Enums.TipoNotificacion;
    titulo?: StringWithAggregatesFilter<'Notificacion'> | string;
    mensaje?: StringWithAggregatesFilter<'Notificacion'> | string;
    leida?: BoolWithAggregatesFilter<'Notificacion'> | boolean;
    url?: StringNullableWithAggregatesFilter<'Notificacion'> | string | null;
    metadata?: JsonNullableWithAggregatesFilter<'Notificacion'>;
    creadoEn?: DateTimeWithAggregatesFilter<'Notificacion'> | Date | string;
  };

  export type PreferenciasNotificacionWhereInput = {
    AND?:
      | PreferenciasNotificacionWhereInput
      | PreferenciasNotificacionWhereInput[];
    OR?: PreferenciasNotificacionWhereInput[];
    NOT?:
      | PreferenciasNotificacionWhereInput
      | PreferenciasNotificacionWhereInput[];
    id?: IntFilter<'PreferenciasNotificacion'> | number;
    usuarioId?: IntFilter<'PreferenciasNotificacion'> | number;
    nuevaResena?: BoolFilter<'PreferenciasNotificacion'> | boolean;
    respuestaResena?: BoolFilter<'PreferenciasNotificacion'> | boolean;
    actualizacionesSistema?: BoolFilter<'PreferenciasNotificacion'> | boolean;
    mantenimiento?: BoolFilter<'PreferenciasNotificacion'> | boolean;
    reporteContenido?: BoolFilter<'PreferenciasNotificacion'> | boolean;
    contenidoPendiente?: BoolFilter<'PreferenciasNotificacion'> | boolean;
    resumenDiario?: BoolFilter<'PreferenciasNotificacion'> | boolean;
    notificacionesInstantaneas?:
      | BoolFilter<'PreferenciasNotificacion'>
      | boolean;
    creadoEn?: DateTimeFilter<'PreferenciasNotificacion'> | Date | string;
    actualizadoEn?: DateTimeFilter<'PreferenciasNotificacion'> | Date | string;
  };

  export type PreferenciasNotificacionOrderByWithRelationInput = {
    id?: SortOrder;
    usuarioId?: SortOrder;
    nuevaResena?: SortOrder;
    respuestaResena?: SortOrder;
    actualizacionesSistema?: SortOrder;
    mantenimiento?: SortOrder;
    reporteContenido?: SortOrder;
    contenidoPendiente?: SortOrder;
    resumenDiario?: SortOrder;
    notificacionesInstantaneas?: SortOrder;
    creadoEn?: SortOrder;
    actualizadoEn?: SortOrder;
  };

  export type PreferenciasNotificacionWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      usuarioId?: number;
      AND?:
        | PreferenciasNotificacionWhereInput
        | PreferenciasNotificacionWhereInput[];
      OR?: PreferenciasNotificacionWhereInput[];
      NOT?:
        | PreferenciasNotificacionWhereInput
        | PreferenciasNotificacionWhereInput[];
      nuevaResena?: BoolFilter<'PreferenciasNotificacion'> | boolean;
      respuestaResena?: BoolFilter<'PreferenciasNotificacion'> | boolean;
      actualizacionesSistema?: BoolFilter<'PreferenciasNotificacion'> | boolean;
      mantenimiento?: BoolFilter<'PreferenciasNotificacion'> | boolean;
      reporteContenido?: BoolFilter<'PreferenciasNotificacion'> | boolean;
      contenidoPendiente?: BoolFilter<'PreferenciasNotificacion'> | boolean;
      resumenDiario?: BoolFilter<'PreferenciasNotificacion'> | boolean;
      notificacionesInstantaneas?:
        | BoolFilter<'PreferenciasNotificacion'>
        | boolean;
      creadoEn?: DateTimeFilter<'PreferenciasNotificacion'> | Date | string;
      actualizadoEn?:
        | DateTimeFilter<'PreferenciasNotificacion'>
        | Date
        | string;
    },
    'id' | 'usuarioId'
  >;

  export type PreferenciasNotificacionOrderByWithAggregationInput = {
    id?: SortOrder;
    usuarioId?: SortOrder;
    nuevaResena?: SortOrder;
    respuestaResena?: SortOrder;
    actualizacionesSistema?: SortOrder;
    mantenimiento?: SortOrder;
    reporteContenido?: SortOrder;
    contenidoPendiente?: SortOrder;
    resumenDiario?: SortOrder;
    notificacionesInstantaneas?: SortOrder;
    creadoEn?: SortOrder;
    actualizadoEn?: SortOrder;
    _count?: PreferenciasNotificacionCountOrderByAggregateInput;
    _avg?: PreferenciasNotificacionAvgOrderByAggregateInput;
    _max?: PreferenciasNotificacionMaxOrderByAggregateInput;
    _min?: PreferenciasNotificacionMinOrderByAggregateInput;
    _sum?: PreferenciasNotificacionSumOrderByAggregateInput;
  };

  export type PreferenciasNotificacionScalarWhereWithAggregatesInput = {
    AND?:
      | PreferenciasNotificacionScalarWhereWithAggregatesInput
      | PreferenciasNotificacionScalarWhereWithAggregatesInput[];
    OR?: PreferenciasNotificacionScalarWhereWithAggregatesInput[];
    NOT?:
      | PreferenciasNotificacionScalarWhereWithAggregatesInput
      | PreferenciasNotificacionScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<'PreferenciasNotificacion'> | number;
    usuarioId?: IntWithAggregatesFilter<'PreferenciasNotificacion'> | number;
    nuevaResena?:
      | BoolWithAggregatesFilter<'PreferenciasNotificacion'>
      | boolean;
    respuestaResena?:
      | BoolWithAggregatesFilter<'PreferenciasNotificacion'>
      | boolean;
    actualizacionesSistema?:
      | BoolWithAggregatesFilter<'PreferenciasNotificacion'>
      | boolean;
    mantenimiento?:
      | BoolWithAggregatesFilter<'PreferenciasNotificacion'>
      | boolean;
    reporteContenido?:
      | BoolWithAggregatesFilter<'PreferenciasNotificacion'>
      | boolean;
    contenidoPendiente?:
      | BoolWithAggregatesFilter<'PreferenciasNotificacion'>
      | boolean;
    resumenDiario?:
      | BoolWithAggregatesFilter<'PreferenciasNotificacion'>
      | boolean;
    notificacionesInstantaneas?:
      | BoolWithAggregatesFilter<'PreferenciasNotificacion'>
      | boolean;
    creadoEn?:
      | DateTimeWithAggregatesFilter<'PreferenciasNotificacion'>
      | Date
      | string;
    actualizadoEn?:
      | DateTimeWithAggregatesFilter<'PreferenciasNotificacion'>
      | Date
      | string;
  };

  export type ResenaBorradorWhereInput = {
    AND?: ResenaBorradorWhereInput | ResenaBorradorWhereInput[];
    OR?: ResenaBorradorWhereInput[];
    NOT?: ResenaBorradorWhereInput | ResenaBorradorWhereInput[];
    id?: IntFilter<'ResenaBorrador'> | number;
    usuarioId?: IntFilter<'ResenaBorrador'> | number;
    cursoId?: IntNullableFilter<'ResenaBorrador'> | number | null;
    productoId?: IntNullableFilter<'ResenaBorrador'> | number | null;
    puntaje?: IntNullableFilter<'ResenaBorrador'> | number | null;
    comentario?: StringNullableFilter<'ResenaBorrador'> | string | null;
    creadoEn?: DateTimeFilter<'ResenaBorrador'> | Date | string;
    actualizadoEn?: DateTimeFilter<'ResenaBorrador'> | Date | string;
  };

  export type ResenaBorradorOrderByWithRelationInput = {
    id?: SortOrder;
    usuarioId?: SortOrder;
    cursoId?: SortOrderInput | SortOrder;
    productoId?: SortOrderInput | SortOrder;
    puntaje?: SortOrderInput | SortOrder;
    comentario?: SortOrderInput | SortOrder;
    creadoEn?: SortOrder;
    actualizadoEn?: SortOrder;
    _relevance?: ResenaBorradorOrderByRelevanceInput;
  };

  export type ResenaBorradorWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      cursoId_usuarioId?: ResenaBorradorCursoIdUsuarioIdCompoundUniqueInput;
      productoId_usuarioId?: ResenaBorradorProductoIdUsuarioIdCompoundUniqueInput;
      AND?: ResenaBorradorWhereInput | ResenaBorradorWhereInput[];
      OR?: ResenaBorradorWhereInput[];
      NOT?: ResenaBorradorWhereInput | ResenaBorradorWhereInput[];
      usuarioId?: IntFilter<'ResenaBorrador'> | number;
      cursoId?: IntNullableFilter<'ResenaBorrador'> | number | null;
      productoId?: IntNullableFilter<'ResenaBorrador'> | number | null;
      puntaje?: IntNullableFilter<'ResenaBorrador'> | number | null;
      comentario?: StringNullableFilter<'ResenaBorrador'> | string | null;
      creadoEn?: DateTimeFilter<'ResenaBorrador'> | Date | string;
      actualizadoEn?: DateTimeFilter<'ResenaBorrador'> | Date | string;
    },
    'id' | 'cursoId_usuarioId' | 'productoId_usuarioId'
  >;

  export type ResenaBorradorOrderByWithAggregationInput = {
    id?: SortOrder;
    usuarioId?: SortOrder;
    cursoId?: SortOrderInput | SortOrder;
    productoId?: SortOrderInput | SortOrder;
    puntaje?: SortOrderInput | SortOrder;
    comentario?: SortOrderInput | SortOrder;
    creadoEn?: SortOrder;
    actualizadoEn?: SortOrder;
    _count?: ResenaBorradorCountOrderByAggregateInput;
    _avg?: ResenaBorradorAvgOrderByAggregateInput;
    _max?: ResenaBorradorMaxOrderByAggregateInput;
    _min?: ResenaBorradorMinOrderByAggregateInput;
    _sum?: ResenaBorradorSumOrderByAggregateInput;
  };

  export type ResenaBorradorScalarWhereWithAggregatesInput = {
    AND?:
      | ResenaBorradorScalarWhereWithAggregatesInput
      | ResenaBorradorScalarWhereWithAggregatesInput[];
    OR?: ResenaBorradorScalarWhereWithAggregatesInput[];
    NOT?:
      | ResenaBorradorScalarWhereWithAggregatesInput
      | ResenaBorradorScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<'ResenaBorrador'> | number;
    usuarioId?: IntWithAggregatesFilter<'ResenaBorrador'> | number;
    cursoId?: IntNullableWithAggregatesFilter<'ResenaBorrador'> | number | null;
    productoId?:
      | IntNullableWithAggregatesFilter<'ResenaBorrador'>
      | number
      | null;
    puntaje?: IntNullableWithAggregatesFilter<'ResenaBorrador'> | number | null;
    comentario?:
      | StringNullableWithAggregatesFilter<'ResenaBorrador'>
      | string
      | null;
    creadoEn?: DateTimeWithAggregatesFilter<'ResenaBorrador'> | Date | string;
    actualizadoEn?:
      | DateTimeWithAggregatesFilter<'ResenaBorrador'>
      | Date
      | string;
  };

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[];
    OR?: AuditLogWhereInput[];
    NOT?: AuditLogWhereInput | AuditLogWhereInput[];
    id?: IntFilter<'AuditLog'> | number;
    tableName?: StringFilter<'AuditLog'> | string;
    recordId?: StringFilter<'AuditLog'> | string;
    action?: StringFilter<'AuditLog'> | string;
    oldData?: JsonNullableFilter<'AuditLog'>;
    newData?: JsonNullableFilter<'AuditLog'>;
    userId?: IntFilter<'AuditLog'> | number;
    userAgent?: StringNullableFilter<'AuditLog'> | string | null;
    ipAddress?: StringNullableFilter<'AuditLog'> | string | null;
    endpoint?: StringNullableFilter<'AuditLog'> | string | null;
    timestamp?: DateTimeFilter<'AuditLog'> | Date | string;
    user?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>;
  };

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder;
    tableName?: SortOrder;
    recordId?: SortOrder;
    action?: SortOrder;
    oldData?: SortOrderInput | SortOrder;
    newData?: SortOrderInput | SortOrder;
    userId?: SortOrder;
    userAgent?: SortOrderInput | SortOrder;
    ipAddress?: SortOrderInput | SortOrder;
    endpoint?: SortOrderInput | SortOrder;
    timestamp?: SortOrder;
    user?: UsuarioOrderByWithRelationInput;
    _relevance?: AuditLogOrderByRelevanceInput;
  };

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      AND?: AuditLogWhereInput | AuditLogWhereInput[];
      OR?: AuditLogWhereInput[];
      NOT?: AuditLogWhereInput | AuditLogWhereInput[];
      tableName?: StringFilter<'AuditLog'> | string;
      recordId?: StringFilter<'AuditLog'> | string;
      action?: StringFilter<'AuditLog'> | string;
      oldData?: JsonNullableFilter<'AuditLog'>;
      newData?: JsonNullableFilter<'AuditLog'>;
      userId?: IntFilter<'AuditLog'> | number;
      userAgent?: StringNullableFilter<'AuditLog'> | string | null;
      ipAddress?: StringNullableFilter<'AuditLog'> | string | null;
      endpoint?: StringNullableFilter<'AuditLog'> | string | null;
      timestamp?: DateTimeFilter<'AuditLog'> | Date | string;
      user?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>;
    },
    'id'
  >;

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder;
    tableName?: SortOrder;
    recordId?: SortOrder;
    action?: SortOrder;
    oldData?: SortOrderInput | SortOrder;
    newData?: SortOrderInput | SortOrder;
    userId?: SortOrder;
    userAgent?: SortOrderInput | SortOrder;
    ipAddress?: SortOrderInput | SortOrder;
    endpoint?: SortOrderInput | SortOrder;
    timestamp?: SortOrder;
    _count?: AuditLogCountOrderByAggregateInput;
    _avg?: AuditLogAvgOrderByAggregateInput;
    _max?: AuditLogMaxOrderByAggregateInput;
    _min?: AuditLogMinOrderByAggregateInput;
    _sum?: AuditLogSumOrderByAggregateInput;
  };

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?:
      | AuditLogScalarWhereWithAggregatesInput
      | AuditLogScalarWhereWithAggregatesInput[];
    OR?: AuditLogScalarWhereWithAggregatesInput[];
    NOT?:
      | AuditLogScalarWhereWithAggregatesInput
      | AuditLogScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<'AuditLog'> | number;
    tableName?: StringWithAggregatesFilter<'AuditLog'> | string;
    recordId?: StringWithAggregatesFilter<'AuditLog'> | string;
    action?: StringWithAggregatesFilter<'AuditLog'> | string;
    oldData?: JsonNullableWithAggregatesFilter<'AuditLog'>;
    newData?: JsonNullableWithAggregatesFilter<'AuditLog'>;
    userId?: IntWithAggregatesFilter<'AuditLog'> | number;
    userAgent?: StringNullableWithAggregatesFilter<'AuditLog'> | string | null;
    ipAddress?: StringNullableWithAggregatesFilter<'AuditLog'> | string | null;
    endpoint?: StringNullableWithAggregatesFilter<'AuditLog'> | string | null;
    timestamp?: DateTimeWithAggregatesFilter<'AuditLog'> | Date | string;
  };

  export type CarritoWhereInput = {
    AND?: CarritoWhereInput | CarritoWhereInput[];
    OR?: CarritoWhereInput[];
    NOT?: CarritoWhereInput | CarritoWhereInput[];
    id?: IntFilter<'Carrito'> | number;
    usuarioId?: IntFilter<'Carrito'> | number;
    creadoEn?: DateTimeFilter<'Carrito'> | Date | string;
    actualizadoEn?: DateTimeFilter<'Carrito'> | Date | string;
    usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>;
    items?: ItemCarritoListRelationFilter;
  };

  export type CarritoOrderByWithRelationInput = {
    id?: SortOrder;
    usuarioId?: SortOrder;
    creadoEn?: SortOrder;
    actualizadoEn?: SortOrder;
    usuario?: UsuarioOrderByWithRelationInput;
    items?: ItemCarritoOrderByRelationAggregateInput;
  };

  export type CarritoWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      usuarioId?: number;
      AND?: CarritoWhereInput | CarritoWhereInput[];
      OR?: CarritoWhereInput[];
      NOT?: CarritoWhereInput | CarritoWhereInput[];
      creadoEn?: DateTimeFilter<'Carrito'> | Date | string;
      actualizadoEn?: DateTimeFilter<'Carrito'> | Date | string;
      usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>;
      items?: ItemCarritoListRelationFilter;
    },
    'id' | 'usuarioId'
  >;

  export type CarritoOrderByWithAggregationInput = {
    id?: SortOrder;
    usuarioId?: SortOrder;
    creadoEn?: SortOrder;
    actualizadoEn?: SortOrder;
    _count?: CarritoCountOrderByAggregateInput;
    _avg?: CarritoAvgOrderByAggregateInput;
    _max?: CarritoMaxOrderByAggregateInput;
    _min?: CarritoMinOrderByAggregateInput;
    _sum?: CarritoSumOrderByAggregateInput;
  };

  export type CarritoScalarWhereWithAggregatesInput = {
    AND?:
      | CarritoScalarWhereWithAggregatesInput
      | CarritoScalarWhereWithAggregatesInput[];
    OR?: CarritoScalarWhereWithAggregatesInput[];
    NOT?:
      | CarritoScalarWhereWithAggregatesInput
      | CarritoScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<'Carrito'> | number;
    usuarioId?: IntWithAggregatesFilter<'Carrito'> | number;
    creadoEn?: DateTimeWithAggregatesFilter<'Carrito'> | Date | string;
    actualizadoEn?: DateTimeWithAggregatesFilter<'Carrito'> | Date | string;
  };

  export type ItemCarritoWhereInput = {
    AND?: ItemCarritoWhereInput | ItemCarritoWhereInput[];
    OR?: ItemCarritoWhereInput[];
    NOT?: ItemCarritoWhereInput | ItemCarritoWhereInput[];
    id?: IntFilter<'ItemCarrito'> | number;
    carritoId?: IntFilter<'ItemCarrito'> | number;
    tipo?: EnumTipoItemOrdenFilter<'ItemCarrito'> | $Enums.TipoItemOrden;
    productoId?: IntNullableFilter<'ItemCarrito'> | number | null;
    cursoId?: IntNullableFilter<'ItemCarrito'> | number | null;
    cantidad?: IntFilter<'ItemCarrito'> | number;
    creadoEn?: DateTimeFilter<'ItemCarrito'> | Date | string;
    carrito?: XOR<CarritoScalarRelationFilter, CarritoWhereInput>;
    producto?: XOR<
      ProductoNullableScalarRelationFilter,
      ProductoWhereInput
    > | null;
    curso?: XOR<CursoNullableScalarRelationFilter, CursoWhereInput> | null;
  };

  export type ItemCarritoOrderByWithRelationInput = {
    id?: SortOrder;
    carritoId?: SortOrder;
    tipo?: SortOrder;
    productoId?: SortOrderInput | SortOrder;
    cursoId?: SortOrderInput | SortOrder;
    cantidad?: SortOrder;
    creadoEn?: SortOrder;
    carrito?: CarritoOrderByWithRelationInput;
    producto?: ProductoOrderByWithRelationInput;
    curso?: CursoOrderByWithRelationInput;
  };

  export type ItemCarritoWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      carritoId_tipo_productoId_cursoId?: ItemCarritoCarritoIdTipoProductoIdCursoIdCompoundUniqueInput;
      AND?: ItemCarritoWhereInput | ItemCarritoWhereInput[];
      OR?: ItemCarritoWhereInput[];
      NOT?: ItemCarritoWhereInput | ItemCarritoWhereInput[];
      carritoId?: IntFilter<'ItemCarrito'> | number;
      tipo?: EnumTipoItemOrdenFilter<'ItemCarrito'> | $Enums.TipoItemOrden;
      productoId?: IntNullableFilter<'ItemCarrito'> | number | null;
      cursoId?: IntNullableFilter<'ItemCarrito'> | number | null;
      cantidad?: IntFilter<'ItemCarrito'> | number;
      creadoEn?: DateTimeFilter<'ItemCarrito'> | Date | string;
      carrito?: XOR<CarritoScalarRelationFilter, CarritoWhereInput>;
      producto?: XOR<
        ProductoNullableScalarRelationFilter,
        ProductoWhereInput
      > | null;
      curso?: XOR<CursoNullableScalarRelationFilter, CursoWhereInput> | null;
    },
    'id' | 'carritoId_tipo_productoId_cursoId'
  >;

  export type ItemCarritoOrderByWithAggregationInput = {
    id?: SortOrder;
    carritoId?: SortOrder;
    tipo?: SortOrder;
    productoId?: SortOrderInput | SortOrder;
    cursoId?: SortOrderInput | SortOrder;
    cantidad?: SortOrder;
    creadoEn?: SortOrder;
    _count?: ItemCarritoCountOrderByAggregateInput;
    _avg?: ItemCarritoAvgOrderByAggregateInput;
    _max?: ItemCarritoMaxOrderByAggregateInput;
    _min?: ItemCarritoMinOrderByAggregateInput;
    _sum?: ItemCarritoSumOrderByAggregateInput;
  };

  export type ItemCarritoScalarWhereWithAggregatesInput = {
    AND?:
      | ItemCarritoScalarWhereWithAggregatesInput
      | ItemCarritoScalarWhereWithAggregatesInput[];
    OR?: ItemCarritoScalarWhereWithAggregatesInput[];
    NOT?:
      | ItemCarritoScalarWhereWithAggregatesInput
      | ItemCarritoScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<'ItemCarrito'> | number;
    carritoId?: IntWithAggregatesFilter<'ItemCarrito'> | number;
    tipo?:
      | EnumTipoItemOrdenWithAggregatesFilter<'ItemCarrito'>
      | $Enums.TipoItemOrden;
    productoId?: IntNullableWithAggregatesFilter<'ItemCarrito'> | number | null;
    cursoId?: IntNullableWithAggregatesFilter<'ItemCarrito'> | number | null;
    cantidad?: IntWithAggregatesFilter<'ItemCarrito'> | number;
    creadoEn?: DateTimeWithAggregatesFilter<'ItemCarrito'> | Date | string;
  };

  export type UsuarioCreateInput = {
    email: string;
    nombre?: string | null;
    passwordHash: string;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
    emailVerificadoEn?: Date | string | null;
    roles?: UsuarioRolCreateNestedManyWithoutUsuarioInput;
    cursosImpartidos?: CursoCreateNestedManyWithoutInstructorInput;
    inscripciones?: InscripcionCreateNestedManyWithoutUsuarioInput;
    resenas?: ResenaCreateNestedManyWithoutUsuarioInput;
    resenaRespuestas?: ResenaRespuestaCreateNestedManyWithoutUsuarioInput;
    favoritos?: FavoritoCreateNestedManyWithoutUsuarioInput;
    resenaLikes?: ResenaLikeCreateNestedManyWithoutUsuarioInput;
    ordenes?: OrdenCreateNestedManyWithoutUsuarioInput;
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput;
    carrito?: CarritoCreateNestedOneWithoutUsuarioInput;
    notificaciones?: NotificacionCreateNestedManyWithoutUsuarioInput;
  };

  export type UsuarioUncheckedCreateInput = {
    id?: number;
    email: string;
    nombre?: string | null;
    passwordHash: string;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
    emailVerificadoEn?: Date | string | null;
    roles?: UsuarioRolUncheckedCreateNestedManyWithoutUsuarioInput;
    cursosImpartidos?: CursoUncheckedCreateNestedManyWithoutInstructorInput;
    inscripciones?: InscripcionUncheckedCreateNestedManyWithoutUsuarioInput;
    resenas?: ResenaUncheckedCreateNestedManyWithoutUsuarioInput;
    resenaRespuestas?: ResenaRespuestaUncheckedCreateNestedManyWithoutUsuarioInput;
    favoritos?: FavoritoUncheckedCreateNestedManyWithoutUsuarioInput;
    resenaLikes?: ResenaLikeUncheckedCreateNestedManyWithoutUsuarioInput;
    ordenes?: OrdenUncheckedCreateNestedManyWithoutUsuarioInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    carrito?: CarritoUncheckedCreateNestedOneWithoutUsuarioInput;
    notificaciones?: NotificacionUncheckedCreateNestedManyWithoutUsuarioInput;
  };

  export type UsuarioUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string;
    nombre?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    emailVerificadoEn?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    roles?: UsuarioRolUpdateManyWithoutUsuarioNestedInput;
    cursosImpartidos?: CursoUpdateManyWithoutInstructorNestedInput;
    inscripciones?: InscripcionUpdateManyWithoutUsuarioNestedInput;
    resenas?: ResenaUpdateManyWithoutUsuarioNestedInput;
    resenaRespuestas?: ResenaRespuestaUpdateManyWithoutUsuarioNestedInput;
    favoritos?: FavoritoUpdateManyWithoutUsuarioNestedInput;
    resenaLikes?: ResenaLikeUpdateManyWithoutUsuarioNestedInput;
    ordenes?: OrdenUpdateManyWithoutUsuarioNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput;
    carrito?: CarritoUpdateOneWithoutUsuarioNestedInput;
    notificaciones?: NotificacionUpdateManyWithoutUsuarioNestedInput;
  };

  export type UsuarioUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    email?: StringFieldUpdateOperationsInput | string;
    nombre?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    emailVerificadoEn?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    roles?: UsuarioRolUncheckedUpdateManyWithoutUsuarioNestedInput;
    cursosImpartidos?: CursoUncheckedUpdateManyWithoutInstructorNestedInput;
    inscripciones?: InscripcionUncheckedUpdateManyWithoutUsuarioNestedInput;
    resenas?: ResenaUncheckedUpdateManyWithoutUsuarioNestedInput;
    resenaRespuestas?: ResenaRespuestaUncheckedUpdateManyWithoutUsuarioNestedInput;
    favoritos?: FavoritoUncheckedUpdateManyWithoutUsuarioNestedInput;
    resenaLikes?: ResenaLikeUncheckedUpdateManyWithoutUsuarioNestedInput;
    ordenes?: OrdenUncheckedUpdateManyWithoutUsuarioNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    carrito?: CarritoUncheckedUpdateOneWithoutUsuarioNestedInput;
    notificaciones?: NotificacionUncheckedUpdateManyWithoutUsuarioNestedInput;
  };

  export type UsuarioCreateManyInput = {
    id?: number;
    email: string;
    nombre?: string | null;
    passwordHash: string;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
    emailVerificadoEn?: Date | string | null;
  };

  export type UsuarioUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string;
    nombre?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    emailVerificadoEn?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type UsuarioUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    email?: StringFieldUpdateOperationsInput | string;
    nombre?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    emailVerificadoEn?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type RoleCreateInput = {
    slug: string;
    name: string;
    createdAt?: Date | string;
    usuarios?: UsuarioRolCreateNestedManyWithoutRoleInput;
  };

  export type RoleUncheckedCreateInput = {
    id?: number;
    slug: string;
    name: string;
    createdAt?: Date | string;
    usuarios?: UsuarioRolUncheckedCreateNestedManyWithoutRoleInput;
  };

  export type RoleUpdateInput = {
    slug?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    usuarios?: UsuarioRolUpdateManyWithoutRoleNestedInput;
  };

  export type RoleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    slug?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    usuarios?: UsuarioRolUncheckedUpdateManyWithoutRoleNestedInput;
  };

  export type RoleCreateManyInput = {
    id?: number;
    slug: string;
    name: string;
    createdAt?: Date | string;
  };

  export type RoleUpdateManyMutationInput = {
    slug?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type RoleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    slug?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UsuarioRolCreateInput = {
    usuario: UsuarioCreateNestedOneWithoutRolesInput;
    role: RoleCreateNestedOneWithoutUsuariosInput;
  };

  export type UsuarioRolUncheckedCreateInput = {
    usuarioId: number;
    roleId: number;
  };

  export type UsuarioRolUpdateInput = {
    usuario?: UsuarioUpdateOneRequiredWithoutRolesNestedInput;
    role?: RoleUpdateOneRequiredWithoutUsuariosNestedInput;
  };

  export type UsuarioRolUncheckedUpdateInput = {
    usuarioId?: IntFieldUpdateOperationsInput | number;
    roleId?: IntFieldUpdateOperationsInput | number;
  };

  export type UsuarioRolCreateManyInput = {
    usuarioId: number;
    roleId: number;
  };

  export type UsuarioRolUpdateManyMutationInput = {};

  export type UsuarioRolUncheckedUpdateManyInput = {
    usuarioId?: IntFieldUpdateOperationsInput | number;
    roleId?: IntFieldUpdateOperationsInput | number;
  };

  export type FavoritoCreateInput = {
    creadoEn?: Date | string;
    usuario: UsuarioCreateNestedOneWithoutFavoritosInput;
    producto: ProductoCreateNestedOneWithoutFavoritosInput;
  };

  export type FavoritoUncheckedCreateInput = {
    id?: number;
    usuarioId: number;
    productoId: number;
    creadoEn?: Date | string;
  };

  export type FavoritoUpdateInput = {
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    usuario?: UsuarioUpdateOneRequiredWithoutFavoritosNestedInput;
    producto?: ProductoUpdateOneRequiredWithoutFavoritosNestedInput;
  };

  export type FavoritoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    usuarioId?: IntFieldUpdateOperationsInput | number;
    productoId?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FavoritoCreateManyInput = {
    id?: number;
    usuarioId: number;
    productoId: number;
    creadoEn?: Date | string;
  };

  export type FavoritoUpdateManyMutationInput = {
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FavoritoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    usuarioId?: IntFieldUpdateOperationsInput | number;
    productoId?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type CursoCreateInput = {
    slug: string;
    titulo: string;
    resumen?: string | null;
    descripcionMD?: string | null;
    requisitos?: string | null;
    precio: number;
    publicado?: boolean;
    nivel?: $Enums.NivelCurso;
    portada?: string | null;
    destacado?: boolean;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    ratingProm?: Decimal | DecimalJsLike | number | string | null;
    ratingConteo?: number;
    creadoEn?: Date | string;
    instructor?: UsuarioCreateNestedOneWithoutCursosImpartidosInput;
    modulos?: ModuloCreateNestedManyWithoutCursoInput;
    resenas?: ResenaCreateNestedManyWithoutCursoInput;
    inscripciones?: InscripcionCreateNestedManyWithoutCursoInput;
    itemsCarrito?: ItemCarritoCreateNestedManyWithoutCursoInput;
  };

  export type CursoUncheckedCreateInput = {
    id?: number;
    slug: string;
    titulo: string;
    resumen?: string | null;
    descripcionMD?: string | null;
    requisitos?: string | null;
    precio: number;
    publicado?: boolean;
    nivel?: $Enums.NivelCurso;
    portada?: string | null;
    destacado?: boolean;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    ratingProm?: Decimal | DecimalJsLike | number | string | null;
    ratingConteo?: number;
    creadoEn?: Date | string;
    instructorId?: number | null;
    modulos?: ModuloUncheckedCreateNestedManyWithoutCursoInput;
    resenas?: ResenaUncheckedCreateNestedManyWithoutCursoInput;
    inscripciones?: InscripcionUncheckedCreateNestedManyWithoutCursoInput;
    itemsCarrito?: ItemCarritoUncheckedCreateNestedManyWithoutCursoInput;
  };

  export type CursoUpdateInput = {
    slug?: StringFieldUpdateOperationsInput | string;
    titulo?: StringFieldUpdateOperationsInput | string;
    resumen?: NullableStringFieldUpdateOperationsInput | string | null;
    descripcionMD?: NullableStringFieldUpdateOperationsInput | string | null;
    requisitos?: NullableStringFieldUpdateOperationsInput | string | null;
    precio?: IntFieldUpdateOperationsInput | number;
    publicado?: BoolFieldUpdateOperationsInput | boolean;
    nivel?: EnumNivelCursoFieldUpdateOperationsInput | $Enums.NivelCurso;
    portada?: NullableStringFieldUpdateOperationsInput | string | null;
    destacado?: BoolFieldUpdateOperationsInput | boolean;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    ratingProm?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    ratingConteo?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    instructor?: UsuarioUpdateOneWithoutCursosImpartidosNestedInput;
    modulos?: ModuloUpdateManyWithoutCursoNestedInput;
    resenas?: ResenaUpdateManyWithoutCursoNestedInput;
    inscripciones?: InscripcionUpdateManyWithoutCursoNestedInput;
    itemsCarrito?: ItemCarritoUpdateManyWithoutCursoNestedInput;
  };

  export type CursoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    slug?: StringFieldUpdateOperationsInput | string;
    titulo?: StringFieldUpdateOperationsInput | string;
    resumen?: NullableStringFieldUpdateOperationsInput | string | null;
    descripcionMD?: NullableStringFieldUpdateOperationsInput | string | null;
    requisitos?: NullableStringFieldUpdateOperationsInput | string | null;
    precio?: IntFieldUpdateOperationsInput | number;
    publicado?: BoolFieldUpdateOperationsInput | boolean;
    nivel?: EnumNivelCursoFieldUpdateOperationsInput | $Enums.NivelCurso;
    portada?: NullableStringFieldUpdateOperationsInput | string | null;
    destacado?: BoolFieldUpdateOperationsInput | boolean;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    ratingProm?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    ratingConteo?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    instructorId?: NullableIntFieldUpdateOperationsInput | number | null;
    modulos?: ModuloUncheckedUpdateManyWithoutCursoNestedInput;
    resenas?: ResenaUncheckedUpdateManyWithoutCursoNestedInput;
    inscripciones?: InscripcionUncheckedUpdateManyWithoutCursoNestedInput;
    itemsCarrito?: ItemCarritoUncheckedUpdateManyWithoutCursoNestedInput;
  };

  export type CursoCreateManyInput = {
    id?: number;
    slug: string;
    titulo: string;
    resumen?: string | null;
    descripcionMD?: string | null;
    requisitos?: string | null;
    precio: number;
    publicado?: boolean;
    nivel?: $Enums.NivelCurso;
    portada?: string | null;
    destacado?: boolean;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    ratingProm?: Decimal | DecimalJsLike | number | string | null;
    ratingConteo?: number;
    creadoEn?: Date | string;
    instructorId?: number | null;
  };

  export type CursoUpdateManyMutationInput = {
    slug?: StringFieldUpdateOperationsInput | string;
    titulo?: StringFieldUpdateOperationsInput | string;
    resumen?: NullableStringFieldUpdateOperationsInput | string | null;
    descripcionMD?: NullableStringFieldUpdateOperationsInput | string | null;
    requisitos?: NullableStringFieldUpdateOperationsInput | string | null;
    precio?: IntFieldUpdateOperationsInput | number;
    publicado?: BoolFieldUpdateOperationsInput | boolean;
    nivel?: EnumNivelCursoFieldUpdateOperationsInput | $Enums.NivelCurso;
    portada?: NullableStringFieldUpdateOperationsInput | string | null;
    destacado?: BoolFieldUpdateOperationsInput | boolean;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    ratingProm?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    ratingConteo?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type CursoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    slug?: StringFieldUpdateOperationsInput | string;
    titulo?: StringFieldUpdateOperationsInput | string;
    resumen?: NullableStringFieldUpdateOperationsInput | string | null;
    descripcionMD?: NullableStringFieldUpdateOperationsInput | string | null;
    requisitos?: NullableStringFieldUpdateOperationsInput | string | null;
    precio?: IntFieldUpdateOperationsInput | number;
    publicado?: BoolFieldUpdateOperationsInput | boolean;
    nivel?: EnumNivelCursoFieldUpdateOperationsInput | $Enums.NivelCurso;
    portada?: NullableStringFieldUpdateOperationsInput | string | null;
    destacado?: BoolFieldUpdateOperationsInput | boolean;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    ratingProm?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    ratingConteo?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    instructorId?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type InscripcionCreateInput = {
    estado?: $Enums.EstadoInscripcion;
    progreso: JsonNullValueInput | InputJsonValue;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
    usuario: UsuarioCreateNestedOneWithoutInscripcionesInput;
    curso: CursoCreateNestedOneWithoutInscripcionesInput;
  };

  export type InscripcionUncheckedCreateInput = {
    id?: number;
    usuarioId: number;
    cursoId: number;
    estado?: $Enums.EstadoInscripcion;
    progreso: JsonNullValueInput | InputJsonValue;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
  };

  export type InscripcionUpdateInput = {
    estado?:
      | EnumEstadoInscripcionFieldUpdateOperationsInput
      | $Enums.EstadoInscripcion;
    progreso?: JsonNullValueInput | InputJsonValue;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    usuario?: UsuarioUpdateOneRequiredWithoutInscripcionesNestedInput;
    curso?: CursoUpdateOneRequiredWithoutInscripcionesNestedInput;
  };

  export type InscripcionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    usuarioId?: IntFieldUpdateOperationsInput | number;
    cursoId?: IntFieldUpdateOperationsInput | number;
    estado?:
      | EnumEstadoInscripcionFieldUpdateOperationsInput
      | $Enums.EstadoInscripcion;
    progreso?: JsonNullValueInput | InputJsonValue;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type InscripcionCreateManyInput = {
    id?: number;
    usuarioId: number;
    cursoId: number;
    estado?: $Enums.EstadoInscripcion;
    progreso: JsonNullValueInput | InputJsonValue;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
  };

  export type InscripcionUpdateManyMutationInput = {
    estado?:
      | EnumEstadoInscripcionFieldUpdateOperationsInput
      | $Enums.EstadoInscripcion;
    progreso?: JsonNullValueInput | InputJsonValue;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type InscripcionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    usuarioId?: IntFieldUpdateOperationsInput | number;
    cursoId?: IntFieldUpdateOperationsInput | number;
    estado?:
      | EnumEstadoInscripcionFieldUpdateOperationsInput
      | $Enums.EstadoInscripcion;
    progreso?: JsonNullValueInput | InputJsonValue;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ModuloCreateInput = {
    titulo: string;
    orden: number;
    parentId?: number | null;
    curso: CursoCreateNestedOneWithoutModulosInput;
    lecciones?: LeccionCreateNestedManyWithoutModuloInput;
  };

  export type ModuloUncheckedCreateInput = {
    id?: number;
    cursoId: number;
    titulo: string;
    orden: number;
    parentId?: number | null;
    lecciones?: LeccionUncheckedCreateNestedManyWithoutModuloInput;
  };

  export type ModuloUpdateInput = {
    titulo?: StringFieldUpdateOperationsInput | string;
    orden?: IntFieldUpdateOperationsInput | number;
    parentId?: NullableIntFieldUpdateOperationsInput | number | null;
    curso?: CursoUpdateOneRequiredWithoutModulosNestedInput;
    lecciones?: LeccionUpdateManyWithoutModuloNestedInput;
  };

  export type ModuloUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    cursoId?: IntFieldUpdateOperationsInput | number;
    titulo?: StringFieldUpdateOperationsInput | string;
    orden?: IntFieldUpdateOperationsInput | number;
    parentId?: NullableIntFieldUpdateOperationsInput | number | null;
    lecciones?: LeccionUncheckedUpdateManyWithoutModuloNestedInput;
  };

  export type ModuloCreateManyInput = {
    id?: number;
    cursoId: number;
    titulo: string;
    orden: number;
    parentId?: number | null;
  };

  export type ModuloUpdateManyMutationInput = {
    titulo?: StringFieldUpdateOperationsInput | string;
    orden?: IntFieldUpdateOperationsInput | number;
    parentId?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type ModuloUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    cursoId?: IntFieldUpdateOperationsInput | number;
    titulo?: StringFieldUpdateOperationsInput | string;
    orden?: IntFieldUpdateOperationsInput | number;
    parentId?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type LeccionCreateInput = {
    titulo: string;
    rutaSrc?: string | null;
    orden: number;
    tipo?: $Enums.TipoLeccion;
    descripcion?: string | null;
    contenido?: NullableJsonNullValueInput | InputJsonValue;
    previewUrl?: string | null;
    duracion?: number;
    modulo: ModuloCreateNestedOneWithoutLeccionesInput;
  };

  export type LeccionUncheckedCreateInput = {
    id?: number;
    moduloId: number;
    titulo: string;
    rutaSrc?: string | null;
    orden: number;
    tipo?: $Enums.TipoLeccion;
    descripcion?: string | null;
    contenido?: NullableJsonNullValueInput | InputJsonValue;
    previewUrl?: string | null;
    duracion?: number;
  };

  export type LeccionUpdateInput = {
    titulo?: StringFieldUpdateOperationsInput | string;
    rutaSrc?: NullableStringFieldUpdateOperationsInput | string | null;
    orden?: IntFieldUpdateOperationsInput | number;
    tipo?: EnumTipoLeccionFieldUpdateOperationsInput | $Enums.TipoLeccion;
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null;
    contenido?: NullableJsonNullValueInput | InputJsonValue;
    previewUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    duracion?: FloatFieldUpdateOperationsInput | number;
    modulo?: ModuloUpdateOneRequiredWithoutLeccionesNestedInput;
  };

  export type LeccionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    moduloId?: IntFieldUpdateOperationsInput | number;
    titulo?: StringFieldUpdateOperationsInput | string;
    rutaSrc?: NullableStringFieldUpdateOperationsInput | string | null;
    orden?: IntFieldUpdateOperationsInput | number;
    tipo?: EnumTipoLeccionFieldUpdateOperationsInput | $Enums.TipoLeccion;
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null;
    contenido?: NullableJsonNullValueInput | InputJsonValue;
    previewUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    duracion?: FloatFieldUpdateOperationsInput | number;
  };

  export type LeccionCreateManyInput = {
    id?: number;
    moduloId: number;
    titulo: string;
    rutaSrc?: string | null;
    orden: number;
    tipo?: $Enums.TipoLeccion;
    descripcion?: string | null;
    contenido?: NullableJsonNullValueInput | InputJsonValue;
    previewUrl?: string | null;
    duracion?: number;
  };

  export type LeccionUpdateManyMutationInput = {
    titulo?: StringFieldUpdateOperationsInput | string;
    rutaSrc?: NullableStringFieldUpdateOperationsInput | string | null;
    orden?: IntFieldUpdateOperationsInput | number;
    tipo?: EnumTipoLeccionFieldUpdateOperationsInput | $Enums.TipoLeccion;
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null;
    contenido?: NullableJsonNullValueInput | InputJsonValue;
    previewUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    duracion?: FloatFieldUpdateOperationsInput | number;
  };

  export type LeccionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    moduloId?: IntFieldUpdateOperationsInput | number;
    titulo?: StringFieldUpdateOperationsInput | string;
    rutaSrc?: NullableStringFieldUpdateOperationsInput | string | null;
    orden?: IntFieldUpdateOperationsInput | number;
    tipo?: EnumTipoLeccionFieldUpdateOperationsInput | $Enums.TipoLeccion;
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null;
    contenido?: NullableJsonNullValueInput | InputJsonValue;
    previewUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    duracion?: FloatFieldUpdateOperationsInput | number;
  };

  export type LeccionTipoConfigCreateInput = {
    tipo: $Enums.TipoLeccion;
    schema: JsonNullValueInput | InputJsonValue;
    ui?: NullableJsonNullValueInput | InputJsonValue;
    version?: number;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
  };

  export type LeccionTipoConfigUncheckedCreateInput = {
    id?: number;
    tipo: $Enums.TipoLeccion;
    schema: JsonNullValueInput | InputJsonValue;
    ui?: NullableJsonNullValueInput | InputJsonValue;
    version?: number;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
  };

  export type LeccionTipoConfigUpdateInput = {
    tipo?: EnumTipoLeccionFieldUpdateOperationsInput | $Enums.TipoLeccion;
    schema?: JsonNullValueInput | InputJsonValue;
    ui?: NullableJsonNullValueInput | InputJsonValue;
    version?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type LeccionTipoConfigUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    tipo?: EnumTipoLeccionFieldUpdateOperationsInput | $Enums.TipoLeccion;
    schema?: JsonNullValueInput | InputJsonValue;
    ui?: NullableJsonNullValueInput | InputJsonValue;
    version?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type LeccionTipoConfigCreateManyInput = {
    id?: number;
    tipo: $Enums.TipoLeccion;
    schema: JsonNullValueInput | InputJsonValue;
    ui?: NullableJsonNullValueInput | InputJsonValue;
    version?: number;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
  };

  export type LeccionTipoConfigUpdateManyMutationInput = {
    tipo?: EnumTipoLeccionFieldUpdateOperationsInput | $Enums.TipoLeccion;
    schema?: JsonNullValueInput | InputJsonValue;
    ui?: NullableJsonNullValueInput | InputJsonValue;
    version?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type LeccionTipoConfigUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    tipo?: EnumTipoLeccionFieldUpdateOperationsInput | $Enums.TipoLeccion;
    schema?: JsonNullValueInput | InputJsonValue;
    ui?: NullableJsonNullValueInput | InputJsonValue;
    version?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ProductoCreateInput = {
    slug: string;
    titulo: string;
    precio: number;
    stock?: number;
    publicado?: boolean;
    destacado?: boolean;
    imagen?: string | null;
    descripcionMD?: string | null;
    precioLista?: number | null;
    ratingProm?: Decimal | DecimalJsLike | number | string | null;
    ratingConteo?: number;
    creadoEn?: Date | string;
    marca?: MarcaCreateNestedOneWithoutProductosInput;
    categoria?: CategoriaCreateNestedOneWithoutProductosInput;
    imagenes?: ProductoImagenCreateNestedManyWithoutProductoInput;
    resenas?: ResenaCreateNestedManyWithoutProductoInput;
    favoritos?: FavoritoCreateNestedManyWithoutProductoInput;
    itemsCarrito?: ItemCarritoCreateNestedManyWithoutProductoInput;
  };

  export type ProductoUncheckedCreateInput = {
    id?: number;
    slug: string;
    titulo: string;
    precio: number;
    stock?: number;
    publicado?: boolean;
    destacado?: boolean;
    imagen?: string | null;
    descripcionMD?: string | null;
    precioLista?: number | null;
    ratingProm?: Decimal | DecimalJsLike | number | string | null;
    ratingConteo?: number;
    creadoEn?: Date | string;
    marcaId?: number | null;
    categoriaId?: number | null;
    imagenes?: ProductoImagenUncheckedCreateNestedManyWithoutProductoInput;
    resenas?: ResenaUncheckedCreateNestedManyWithoutProductoInput;
    favoritos?: FavoritoUncheckedCreateNestedManyWithoutProductoInput;
    itemsCarrito?: ItemCarritoUncheckedCreateNestedManyWithoutProductoInput;
  };

  export type ProductoUpdateInput = {
    slug?: StringFieldUpdateOperationsInput | string;
    titulo?: StringFieldUpdateOperationsInput | string;
    precio?: IntFieldUpdateOperationsInput | number;
    stock?: IntFieldUpdateOperationsInput | number;
    publicado?: BoolFieldUpdateOperationsInput | boolean;
    destacado?: BoolFieldUpdateOperationsInput | boolean;
    imagen?: NullableStringFieldUpdateOperationsInput | string | null;
    descripcionMD?: NullableStringFieldUpdateOperationsInput | string | null;
    precioLista?: NullableIntFieldUpdateOperationsInput | number | null;
    ratingProm?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    ratingConteo?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    marca?: MarcaUpdateOneWithoutProductosNestedInput;
    categoria?: CategoriaUpdateOneWithoutProductosNestedInput;
    imagenes?: ProductoImagenUpdateManyWithoutProductoNestedInput;
    resenas?: ResenaUpdateManyWithoutProductoNestedInput;
    favoritos?: FavoritoUpdateManyWithoutProductoNestedInput;
    itemsCarrito?: ItemCarritoUpdateManyWithoutProductoNestedInput;
  };

  export type ProductoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    slug?: StringFieldUpdateOperationsInput | string;
    titulo?: StringFieldUpdateOperationsInput | string;
    precio?: IntFieldUpdateOperationsInput | number;
    stock?: IntFieldUpdateOperationsInput | number;
    publicado?: BoolFieldUpdateOperationsInput | boolean;
    destacado?: BoolFieldUpdateOperationsInput | boolean;
    imagen?: NullableStringFieldUpdateOperationsInput | string | null;
    descripcionMD?: NullableStringFieldUpdateOperationsInput | string | null;
    precioLista?: NullableIntFieldUpdateOperationsInput | number | null;
    ratingProm?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    ratingConteo?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    marcaId?: NullableIntFieldUpdateOperationsInput | number | null;
    categoriaId?: NullableIntFieldUpdateOperationsInput | number | null;
    imagenes?: ProductoImagenUncheckedUpdateManyWithoutProductoNestedInput;
    resenas?: ResenaUncheckedUpdateManyWithoutProductoNestedInput;
    favoritos?: FavoritoUncheckedUpdateManyWithoutProductoNestedInput;
    itemsCarrito?: ItemCarritoUncheckedUpdateManyWithoutProductoNestedInput;
  };

  export type ProductoCreateManyInput = {
    id?: number;
    slug: string;
    titulo: string;
    precio: number;
    stock?: number;
    publicado?: boolean;
    destacado?: boolean;
    imagen?: string | null;
    descripcionMD?: string | null;
    precioLista?: number | null;
    ratingProm?: Decimal | DecimalJsLike | number | string | null;
    ratingConteo?: number;
    creadoEn?: Date | string;
    marcaId?: number | null;
    categoriaId?: number | null;
  };

  export type ProductoUpdateManyMutationInput = {
    slug?: StringFieldUpdateOperationsInput | string;
    titulo?: StringFieldUpdateOperationsInput | string;
    precio?: IntFieldUpdateOperationsInput | number;
    stock?: IntFieldUpdateOperationsInput | number;
    publicado?: BoolFieldUpdateOperationsInput | boolean;
    destacado?: BoolFieldUpdateOperationsInput | boolean;
    imagen?: NullableStringFieldUpdateOperationsInput | string | null;
    descripcionMD?: NullableStringFieldUpdateOperationsInput | string | null;
    precioLista?: NullableIntFieldUpdateOperationsInput | number | null;
    ratingProm?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    ratingConteo?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ProductoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    slug?: StringFieldUpdateOperationsInput | string;
    titulo?: StringFieldUpdateOperationsInput | string;
    precio?: IntFieldUpdateOperationsInput | number;
    stock?: IntFieldUpdateOperationsInput | number;
    publicado?: BoolFieldUpdateOperationsInput | boolean;
    destacado?: BoolFieldUpdateOperationsInput | boolean;
    imagen?: NullableStringFieldUpdateOperationsInput | string | null;
    descripcionMD?: NullableStringFieldUpdateOperationsInput | string | null;
    precioLista?: NullableIntFieldUpdateOperationsInput | number | null;
    ratingProm?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    ratingConteo?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    marcaId?: NullableIntFieldUpdateOperationsInput | number | null;
    categoriaId?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type ProductoImagenCreateInput = {
    archivo: string;
    alt?: string | null;
    orden?: number;
    producto: ProductoCreateNestedOneWithoutImagenesInput;
  };

  export type ProductoImagenUncheckedCreateInput = {
    id?: number;
    productoId: number;
    archivo: string;
    alt?: string | null;
    orden?: number;
  };

  export type ProductoImagenUpdateInput = {
    archivo?: StringFieldUpdateOperationsInput | string;
    alt?: NullableStringFieldUpdateOperationsInput | string | null;
    orden?: IntFieldUpdateOperationsInput | number;
    producto?: ProductoUpdateOneRequiredWithoutImagenesNestedInput;
  };

  export type ProductoImagenUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    productoId?: IntFieldUpdateOperationsInput | number;
    archivo?: StringFieldUpdateOperationsInput | string;
    alt?: NullableStringFieldUpdateOperationsInput | string | null;
    orden?: IntFieldUpdateOperationsInput | number;
  };

  export type ProductoImagenCreateManyInput = {
    id?: number;
    productoId: number;
    archivo: string;
    alt?: string | null;
    orden?: number;
  };

  export type ProductoImagenUpdateManyMutationInput = {
    archivo?: StringFieldUpdateOperationsInput | string;
    alt?: NullableStringFieldUpdateOperationsInput | string | null;
    orden?: IntFieldUpdateOperationsInput | number;
  };

  export type ProductoImagenUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    productoId?: IntFieldUpdateOperationsInput | number;
    archivo?: StringFieldUpdateOperationsInput | string;
    alt?: NullableStringFieldUpdateOperationsInput | string | null;
    orden?: IntFieldUpdateOperationsInput | number;
  };

  export type MarcaCreateInput = {
    slug: string;
    nombre: string;
    imagen?: string | null;
    activa?: boolean;
    orden?: number;
    creadoEn?: Date | string;
    productos?: ProductoCreateNestedManyWithoutMarcaInput;
  };

  export type MarcaUncheckedCreateInput = {
    id?: number;
    slug: string;
    nombre: string;
    imagen?: string | null;
    activa?: boolean;
    orden?: number;
    creadoEn?: Date | string;
    productos?: ProductoUncheckedCreateNestedManyWithoutMarcaInput;
  };

  export type MarcaUpdateInput = {
    slug?: StringFieldUpdateOperationsInput | string;
    nombre?: StringFieldUpdateOperationsInput | string;
    imagen?: NullableStringFieldUpdateOperationsInput | string | null;
    activa?: BoolFieldUpdateOperationsInput | boolean;
    orden?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    productos?: ProductoUpdateManyWithoutMarcaNestedInput;
  };

  export type MarcaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    slug?: StringFieldUpdateOperationsInput | string;
    nombre?: StringFieldUpdateOperationsInput | string;
    imagen?: NullableStringFieldUpdateOperationsInput | string | null;
    activa?: BoolFieldUpdateOperationsInput | boolean;
    orden?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    productos?: ProductoUncheckedUpdateManyWithoutMarcaNestedInput;
  };

  export type MarcaCreateManyInput = {
    id?: number;
    slug: string;
    nombre: string;
    imagen?: string | null;
    activa?: boolean;
    orden?: number;
    creadoEn?: Date | string;
  };

  export type MarcaUpdateManyMutationInput = {
    slug?: StringFieldUpdateOperationsInput | string;
    nombre?: StringFieldUpdateOperationsInput | string;
    imagen?: NullableStringFieldUpdateOperationsInput | string | null;
    activa?: BoolFieldUpdateOperationsInput | boolean;
    orden?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type MarcaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    slug?: StringFieldUpdateOperationsInput | string;
    nombre?: StringFieldUpdateOperationsInput | string;
    imagen?: NullableStringFieldUpdateOperationsInput | string | null;
    activa?: BoolFieldUpdateOperationsInput | boolean;
    orden?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type CategoriaCreateInput = {
    slug: string;
    nombre: string;
    descripcion?: string | null;
    imagen?: string | null;
    activa?: boolean;
    orden?: number;
    creadoEn?: Date | string;
    parent?: CategoriaCreateNestedOneWithoutHijosInput;
    hijos?: CategoriaCreateNestedManyWithoutParentInput;
    productos?: ProductoCreateNestedManyWithoutCategoriaInput;
  };

  export type CategoriaUncheckedCreateInput = {
    id?: number;
    slug: string;
    nombre: string;
    descripcion?: string | null;
    imagen?: string | null;
    activa?: boolean;
    orden?: number;
    creadoEn?: Date | string;
    parentId?: number | null;
    hijos?: CategoriaUncheckedCreateNestedManyWithoutParentInput;
    productos?: ProductoUncheckedCreateNestedManyWithoutCategoriaInput;
  };

  export type CategoriaUpdateInput = {
    slug?: StringFieldUpdateOperationsInput | string;
    nombre?: StringFieldUpdateOperationsInput | string;
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null;
    imagen?: NullableStringFieldUpdateOperationsInput | string | null;
    activa?: BoolFieldUpdateOperationsInput | boolean;
    orden?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    parent?: CategoriaUpdateOneWithoutHijosNestedInput;
    hijos?: CategoriaUpdateManyWithoutParentNestedInput;
    productos?: ProductoUpdateManyWithoutCategoriaNestedInput;
  };

  export type CategoriaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    slug?: StringFieldUpdateOperationsInput | string;
    nombre?: StringFieldUpdateOperationsInput | string;
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null;
    imagen?: NullableStringFieldUpdateOperationsInput | string | null;
    activa?: BoolFieldUpdateOperationsInput | boolean;
    orden?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    parentId?: NullableIntFieldUpdateOperationsInput | number | null;
    hijos?: CategoriaUncheckedUpdateManyWithoutParentNestedInput;
    productos?: ProductoUncheckedUpdateManyWithoutCategoriaNestedInput;
  };

  export type CategoriaCreateManyInput = {
    id?: number;
    slug: string;
    nombre: string;
    descripcion?: string | null;
    imagen?: string | null;
    activa?: boolean;
    orden?: number;
    creadoEn?: Date | string;
    parentId?: number | null;
  };

  export type CategoriaUpdateManyMutationInput = {
    slug?: StringFieldUpdateOperationsInput | string;
    nombre?: StringFieldUpdateOperationsInput | string;
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null;
    imagen?: NullableStringFieldUpdateOperationsInput | string | null;
    activa?: BoolFieldUpdateOperationsInput | boolean;
    orden?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type CategoriaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    slug?: StringFieldUpdateOperationsInput | string;
    nombre?: StringFieldUpdateOperationsInput | string;
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null;
    imagen?: NullableStringFieldUpdateOperationsInput | string | null;
    activa?: BoolFieldUpdateOperationsInput | boolean;
    orden?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    parentId?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type OrdenCreateInput = {
    estado?: $Enums.EstadoOrden;
    total: number;
    moneda?: string;
    referenciaPago?: string | null;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
    esSuscripcion?: boolean;
    suscripcionActiva?: boolean | null;
    suscripcionId?: string | null;
    suscripcionFrecuencia?: number | null;
    suscripcionTipoFrecuencia?: string | null;
    metadatos?: NullableJsonNullValueInput | InputJsonValue;
    usuario: UsuarioCreateNestedOneWithoutOrdenesInput;
    direccionEnvio?: DireccionCreateNestedOneWithoutOrdenesEnvioInput;
    direccionFacturacion?: DireccionCreateNestedOneWithoutOrdenesFacturacionInput;
    items?: ItemOrdenCreateNestedManyWithoutOrdenInput;
  };

  export type OrdenUncheckedCreateInput = {
    id?: number;
    usuarioId: number;
    estado?: $Enums.EstadoOrden;
    total: number;
    moneda?: string;
    referenciaPago?: string | null;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
    esSuscripcion?: boolean;
    suscripcionActiva?: boolean | null;
    suscripcionId?: string | null;
    suscripcionFrecuencia?: number | null;
    suscripcionTipoFrecuencia?: string | null;
    metadatos?: NullableJsonNullValueInput | InputJsonValue;
    direccionEnvioId?: number | null;
    direccionFacturacionId?: number | null;
    items?: ItemOrdenUncheckedCreateNestedManyWithoutOrdenInput;
  };

  export type OrdenUpdateInput = {
    estado?: EnumEstadoOrdenFieldUpdateOperationsInput | $Enums.EstadoOrden;
    total?: IntFieldUpdateOperationsInput | number;
    moneda?: StringFieldUpdateOperationsInput | string;
    referenciaPago?: NullableStringFieldUpdateOperationsInput | string | null;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    esSuscripcion?: BoolFieldUpdateOperationsInput | boolean;
    suscripcionActiva?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    suscripcionId?: NullableStringFieldUpdateOperationsInput | string | null;
    suscripcionFrecuencia?:
      | NullableIntFieldUpdateOperationsInput
      | number
      | null;
    suscripcionTipoFrecuencia?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    metadatos?: NullableJsonNullValueInput | InputJsonValue;
    usuario?: UsuarioUpdateOneRequiredWithoutOrdenesNestedInput;
    direccionEnvio?: DireccionUpdateOneWithoutOrdenesEnvioNestedInput;
    direccionFacturacion?: DireccionUpdateOneWithoutOrdenesFacturacionNestedInput;
    items?: ItemOrdenUpdateManyWithoutOrdenNestedInput;
  };

  export type OrdenUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    usuarioId?: IntFieldUpdateOperationsInput | number;
    estado?: EnumEstadoOrdenFieldUpdateOperationsInput | $Enums.EstadoOrden;
    total?: IntFieldUpdateOperationsInput | number;
    moneda?: StringFieldUpdateOperationsInput | string;
    referenciaPago?: NullableStringFieldUpdateOperationsInput | string | null;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    esSuscripcion?: BoolFieldUpdateOperationsInput | boolean;
    suscripcionActiva?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    suscripcionId?: NullableStringFieldUpdateOperationsInput | string | null;
    suscripcionFrecuencia?:
      | NullableIntFieldUpdateOperationsInput
      | number
      | null;
    suscripcionTipoFrecuencia?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    metadatos?: NullableJsonNullValueInput | InputJsonValue;
    direccionEnvioId?: NullableIntFieldUpdateOperationsInput | number | null;
    direccionFacturacionId?:
      | NullableIntFieldUpdateOperationsInput
      | number
      | null;
    items?: ItemOrdenUncheckedUpdateManyWithoutOrdenNestedInput;
  };

  export type OrdenCreateManyInput = {
    id?: number;
    usuarioId: number;
    estado?: $Enums.EstadoOrden;
    total: number;
    moneda?: string;
    referenciaPago?: string | null;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
    esSuscripcion?: boolean;
    suscripcionActiva?: boolean | null;
    suscripcionId?: string | null;
    suscripcionFrecuencia?: number | null;
    suscripcionTipoFrecuencia?: string | null;
    metadatos?: NullableJsonNullValueInput | InputJsonValue;
    direccionEnvioId?: number | null;
    direccionFacturacionId?: number | null;
  };

  export type OrdenUpdateManyMutationInput = {
    estado?: EnumEstadoOrdenFieldUpdateOperationsInput | $Enums.EstadoOrden;
    total?: IntFieldUpdateOperationsInput | number;
    moneda?: StringFieldUpdateOperationsInput | string;
    referenciaPago?: NullableStringFieldUpdateOperationsInput | string | null;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    esSuscripcion?: BoolFieldUpdateOperationsInput | boolean;
    suscripcionActiva?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    suscripcionId?: NullableStringFieldUpdateOperationsInput | string | null;
    suscripcionFrecuencia?:
      | NullableIntFieldUpdateOperationsInput
      | number
      | null;
    suscripcionTipoFrecuencia?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    metadatos?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type OrdenUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    usuarioId?: IntFieldUpdateOperationsInput | number;
    estado?: EnumEstadoOrdenFieldUpdateOperationsInput | $Enums.EstadoOrden;
    total?: IntFieldUpdateOperationsInput | number;
    moneda?: StringFieldUpdateOperationsInput | string;
    referenciaPago?: NullableStringFieldUpdateOperationsInput | string | null;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    esSuscripcion?: BoolFieldUpdateOperationsInput | boolean;
    suscripcionActiva?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    suscripcionId?: NullableStringFieldUpdateOperationsInput | string | null;
    suscripcionFrecuencia?:
      | NullableIntFieldUpdateOperationsInput
      | number
      | null;
    suscripcionTipoFrecuencia?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    metadatos?: NullableJsonNullValueInput | InputJsonValue;
    direccionEnvioId?: NullableIntFieldUpdateOperationsInput | number | null;
    direccionFacturacionId?:
      | NullableIntFieldUpdateOperationsInput
      | number
      | null;
  };

  export type ItemOrdenCreateInput = {
    tipo: $Enums.TipoItemOrden;
    refId: number;
    titulo: string;
    cantidad?: number;
    precioUnitario: number;
    orden: OrdenCreateNestedOneWithoutItemsInput;
  };

  export type ItemOrdenUncheckedCreateInput = {
    id?: number;
    ordenId: number;
    tipo: $Enums.TipoItemOrden;
    refId: number;
    titulo: string;
    cantidad?: number;
    precioUnitario: number;
  };

  export type ItemOrdenUpdateInput = {
    tipo?: EnumTipoItemOrdenFieldUpdateOperationsInput | $Enums.TipoItemOrden;
    refId?: IntFieldUpdateOperationsInput | number;
    titulo?: StringFieldUpdateOperationsInput | string;
    cantidad?: IntFieldUpdateOperationsInput | number;
    precioUnitario?: IntFieldUpdateOperationsInput | number;
    orden?: OrdenUpdateOneRequiredWithoutItemsNestedInput;
  };

  export type ItemOrdenUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    ordenId?: IntFieldUpdateOperationsInput | number;
    tipo?: EnumTipoItemOrdenFieldUpdateOperationsInput | $Enums.TipoItemOrden;
    refId?: IntFieldUpdateOperationsInput | number;
    titulo?: StringFieldUpdateOperationsInput | string;
    cantidad?: IntFieldUpdateOperationsInput | number;
    precioUnitario?: IntFieldUpdateOperationsInput | number;
  };

  export type ItemOrdenCreateManyInput = {
    id?: number;
    ordenId: number;
    tipo: $Enums.TipoItemOrden;
    refId: number;
    titulo: string;
    cantidad?: number;
    precioUnitario: number;
  };

  export type ItemOrdenUpdateManyMutationInput = {
    tipo?: EnumTipoItemOrdenFieldUpdateOperationsInput | $Enums.TipoItemOrden;
    refId?: IntFieldUpdateOperationsInput | number;
    titulo?: StringFieldUpdateOperationsInput | string;
    cantidad?: IntFieldUpdateOperationsInput | number;
    precioUnitario?: IntFieldUpdateOperationsInput | number;
  };

  export type ItemOrdenUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    ordenId?: IntFieldUpdateOperationsInput | number;
    tipo?: EnumTipoItemOrdenFieldUpdateOperationsInput | $Enums.TipoItemOrden;
    refId?: IntFieldUpdateOperationsInput | number;
    titulo?: StringFieldUpdateOperationsInput | string;
    cantidad?: IntFieldUpdateOperationsInput | number;
    precioUnitario?: IntFieldUpdateOperationsInput | number;
  };

  export type PagoSuscripcionCreateInput = {
    ordenId: number;
    usuarioId: number;
    referenciaPago: string;
    monto: Decimal | DecimalJsLike | number | string;
    estado: string;
    metadatos?: NullableJsonNullValueInput | InputJsonValue;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
  };

  export type PagoSuscripcionUncheckedCreateInput = {
    id?: number;
    ordenId: number;
    usuarioId: number;
    referenciaPago: string;
    monto: Decimal | DecimalJsLike | number | string;
    estado: string;
    metadatos?: NullableJsonNullValueInput | InputJsonValue;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
  };

  export type PagoSuscripcionUpdateInput = {
    ordenId?: IntFieldUpdateOperationsInput | number;
    usuarioId?: IntFieldUpdateOperationsInput | number;
    referenciaPago?: StringFieldUpdateOperationsInput | string;
    monto?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    estado?: StringFieldUpdateOperationsInput | string;
    metadatos?: NullableJsonNullValueInput | InputJsonValue;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PagoSuscripcionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    ordenId?: IntFieldUpdateOperationsInput | number;
    usuarioId?: IntFieldUpdateOperationsInput | number;
    referenciaPago?: StringFieldUpdateOperationsInput | string;
    monto?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    estado?: StringFieldUpdateOperationsInput | string;
    metadatos?: NullableJsonNullValueInput | InputJsonValue;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PagoSuscripcionCreateManyInput = {
    id?: number;
    ordenId: number;
    usuarioId: number;
    referenciaPago: string;
    monto: Decimal | DecimalJsLike | number | string;
    estado: string;
    metadatos?: NullableJsonNullValueInput | InputJsonValue;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
  };

  export type PagoSuscripcionUpdateManyMutationInput = {
    ordenId?: IntFieldUpdateOperationsInput | number;
    usuarioId?: IntFieldUpdateOperationsInput | number;
    referenciaPago?: StringFieldUpdateOperationsInput | string;
    monto?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    estado?: StringFieldUpdateOperationsInput | string;
    metadatos?: NullableJsonNullValueInput | InputJsonValue;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PagoSuscripcionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    ordenId?: IntFieldUpdateOperationsInput | number;
    usuarioId?: IntFieldUpdateOperationsInput | number;
    referenciaPago?: StringFieldUpdateOperationsInput | string;
    monto?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    estado?: StringFieldUpdateOperationsInput | string;
    metadatos?: NullableJsonNullValueInput | InputJsonValue;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type DireccionCreateInput = {
    usuarioId: number;
    etiqueta?: string | null;
    nombre: string;
    telefono?: string | null;
    calle: string;
    numero?: string | null;
    pisoDepto?: string | null;
    ciudad: string;
    provincia: string;
    cp: string;
    pais?: string;
    predeterminada?: boolean;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
    ordenesEnvio?: OrdenCreateNestedManyWithoutDireccionEnvioInput;
    ordenesFacturacion?: OrdenCreateNestedManyWithoutDireccionFacturacionInput;
  };

  export type DireccionUncheckedCreateInput = {
    id?: number;
    usuarioId: number;
    etiqueta?: string | null;
    nombre: string;
    telefono?: string | null;
    calle: string;
    numero?: string | null;
    pisoDepto?: string | null;
    ciudad: string;
    provincia: string;
    cp: string;
    pais?: string;
    predeterminada?: boolean;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
    ordenesEnvio?: OrdenUncheckedCreateNestedManyWithoutDireccionEnvioInput;
    ordenesFacturacion?: OrdenUncheckedCreateNestedManyWithoutDireccionFacturacionInput;
  };

  export type DireccionUpdateInput = {
    usuarioId?: IntFieldUpdateOperationsInput | number;
    etiqueta?: NullableStringFieldUpdateOperationsInput | string | null;
    nombre?: StringFieldUpdateOperationsInput | string;
    telefono?: NullableStringFieldUpdateOperationsInput | string | null;
    calle?: StringFieldUpdateOperationsInput | string;
    numero?: NullableStringFieldUpdateOperationsInput | string | null;
    pisoDepto?: NullableStringFieldUpdateOperationsInput | string | null;
    ciudad?: StringFieldUpdateOperationsInput | string;
    provincia?: StringFieldUpdateOperationsInput | string;
    cp?: StringFieldUpdateOperationsInput | string;
    pais?: StringFieldUpdateOperationsInput | string;
    predeterminada?: BoolFieldUpdateOperationsInput | boolean;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    ordenesEnvio?: OrdenUpdateManyWithoutDireccionEnvioNestedInput;
    ordenesFacturacion?: OrdenUpdateManyWithoutDireccionFacturacionNestedInput;
  };

  export type DireccionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    usuarioId?: IntFieldUpdateOperationsInput | number;
    etiqueta?: NullableStringFieldUpdateOperationsInput | string | null;
    nombre?: StringFieldUpdateOperationsInput | string;
    telefono?: NullableStringFieldUpdateOperationsInput | string | null;
    calle?: StringFieldUpdateOperationsInput | string;
    numero?: NullableStringFieldUpdateOperationsInput | string | null;
    pisoDepto?: NullableStringFieldUpdateOperationsInput | string | null;
    ciudad?: StringFieldUpdateOperationsInput | string;
    provincia?: StringFieldUpdateOperationsInput | string;
    cp?: StringFieldUpdateOperationsInput | string;
    pais?: StringFieldUpdateOperationsInput | string;
    predeterminada?: BoolFieldUpdateOperationsInput | boolean;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    ordenesEnvio?: OrdenUncheckedUpdateManyWithoutDireccionEnvioNestedInput;
    ordenesFacturacion?: OrdenUncheckedUpdateManyWithoutDireccionFacturacionNestedInput;
  };

  export type DireccionCreateManyInput = {
    id?: number;
    usuarioId: number;
    etiqueta?: string | null;
    nombre: string;
    telefono?: string | null;
    calle: string;
    numero?: string | null;
    pisoDepto?: string | null;
    ciudad: string;
    provincia: string;
    cp: string;
    pais?: string;
    predeterminada?: boolean;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
  };

  export type DireccionUpdateManyMutationInput = {
    usuarioId?: IntFieldUpdateOperationsInput | number;
    etiqueta?: NullableStringFieldUpdateOperationsInput | string | null;
    nombre?: StringFieldUpdateOperationsInput | string;
    telefono?: NullableStringFieldUpdateOperationsInput | string | null;
    calle?: StringFieldUpdateOperationsInput | string;
    numero?: NullableStringFieldUpdateOperationsInput | string | null;
    pisoDepto?: NullableStringFieldUpdateOperationsInput | string | null;
    ciudad?: StringFieldUpdateOperationsInput | string;
    provincia?: StringFieldUpdateOperationsInput | string;
    cp?: StringFieldUpdateOperationsInput | string;
    pais?: StringFieldUpdateOperationsInput | string;
    predeterminada?: BoolFieldUpdateOperationsInput | boolean;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type DireccionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    usuarioId?: IntFieldUpdateOperationsInput | number;
    etiqueta?: NullableStringFieldUpdateOperationsInput | string | null;
    nombre?: StringFieldUpdateOperationsInput | string;
    telefono?: NullableStringFieldUpdateOperationsInput | string | null;
    calle?: StringFieldUpdateOperationsInput | string;
    numero?: NullableStringFieldUpdateOperationsInput | string | null;
    pisoDepto?: NullableStringFieldUpdateOperationsInput | string | null;
    ciudad?: StringFieldUpdateOperationsInput | string;
    provincia?: StringFieldUpdateOperationsInput | string;
    cp?: StringFieldUpdateOperationsInput | string;
    pais?: StringFieldUpdateOperationsInput | string;
    predeterminada?: BoolFieldUpdateOperationsInput | boolean;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SliderCreateInput = {
    titulo: string;
    alt: string;
    archivo: string;
    activa?: boolean;
    orden?: number;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
    ctaPrimarioHref?: string | null;
    ctaPrimarioTexto?: string | null;
    ctaSecundarioHref?: string | null;
    ctaSecundarioTexto?: string | null;
    descripcion?: string | null;
    etiqueta?: string | null;
    subtitulo?: string | null;
  };

  export type SliderUncheckedCreateInput = {
    id?: number;
    titulo: string;
    alt: string;
    archivo: string;
    activa?: boolean;
    orden?: number;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
    ctaPrimarioHref?: string | null;
    ctaPrimarioTexto?: string | null;
    ctaSecundarioHref?: string | null;
    ctaSecundarioTexto?: string | null;
    descripcion?: string | null;
    etiqueta?: string | null;
    subtitulo?: string | null;
  };

  export type SliderUpdateInput = {
    titulo?: StringFieldUpdateOperationsInput | string;
    alt?: StringFieldUpdateOperationsInput | string;
    archivo?: StringFieldUpdateOperationsInput | string;
    activa?: BoolFieldUpdateOperationsInput | boolean;
    orden?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    ctaPrimarioHref?: NullableStringFieldUpdateOperationsInput | string | null;
    ctaPrimarioTexto?: NullableStringFieldUpdateOperationsInput | string | null;
    ctaSecundarioHref?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    ctaSecundarioTexto?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null;
    etiqueta?: NullableStringFieldUpdateOperationsInput | string | null;
    subtitulo?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type SliderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    titulo?: StringFieldUpdateOperationsInput | string;
    alt?: StringFieldUpdateOperationsInput | string;
    archivo?: StringFieldUpdateOperationsInput | string;
    activa?: BoolFieldUpdateOperationsInput | boolean;
    orden?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    ctaPrimarioHref?: NullableStringFieldUpdateOperationsInput | string | null;
    ctaPrimarioTexto?: NullableStringFieldUpdateOperationsInput | string | null;
    ctaSecundarioHref?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    ctaSecundarioTexto?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null;
    etiqueta?: NullableStringFieldUpdateOperationsInput | string | null;
    subtitulo?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type SliderCreateManyInput = {
    id?: number;
    titulo: string;
    alt: string;
    archivo: string;
    activa?: boolean;
    orden?: number;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
    ctaPrimarioHref?: string | null;
    ctaPrimarioTexto?: string | null;
    ctaSecundarioHref?: string | null;
    ctaSecundarioTexto?: string | null;
    descripcion?: string | null;
    etiqueta?: string | null;
    subtitulo?: string | null;
  };

  export type SliderUpdateManyMutationInput = {
    titulo?: StringFieldUpdateOperationsInput | string;
    alt?: StringFieldUpdateOperationsInput | string;
    archivo?: StringFieldUpdateOperationsInput | string;
    activa?: BoolFieldUpdateOperationsInput | boolean;
    orden?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    ctaPrimarioHref?: NullableStringFieldUpdateOperationsInput | string | null;
    ctaPrimarioTexto?: NullableStringFieldUpdateOperationsInput | string | null;
    ctaSecundarioHref?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    ctaSecundarioTexto?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null;
    etiqueta?: NullableStringFieldUpdateOperationsInput | string | null;
    subtitulo?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type SliderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    titulo?: StringFieldUpdateOperationsInput | string;
    alt?: StringFieldUpdateOperationsInput | string;
    archivo?: StringFieldUpdateOperationsInput | string;
    activa?: BoolFieldUpdateOperationsInput | boolean;
    orden?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    ctaPrimarioHref?: NullableStringFieldUpdateOperationsInput | string | null;
    ctaPrimarioTexto?: NullableStringFieldUpdateOperationsInput | string | null;
    ctaSecundarioHref?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    ctaSecundarioTexto?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null;
    etiqueta?: NullableStringFieldUpdateOperationsInput | string | null;
    subtitulo?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type ResenaCreateInput = {
    puntaje: number;
    comentario?: string | null;
    creadoEn?: Date | string;
    curso?: CursoCreateNestedOneWithoutResenasInput;
    producto?: ProductoCreateNestedOneWithoutResenasInput;
    usuario: UsuarioCreateNestedOneWithoutResenasInput;
    respuestas?: ResenaRespuestaCreateNestedManyWithoutResenaInput;
    likes?: ResenaLikeCreateNestedManyWithoutResenaInput;
  };

  export type ResenaUncheckedCreateInput = {
    id?: number;
    cursoId?: number | null;
    productoId?: number | null;
    usuarioId: number;
    puntaje: number;
    comentario?: string | null;
    creadoEn?: Date | string;
    respuestas?: ResenaRespuestaUncheckedCreateNestedManyWithoutResenaInput;
    likes?: ResenaLikeUncheckedCreateNestedManyWithoutResenaInput;
  };

  export type ResenaUpdateInput = {
    puntaje?: IntFieldUpdateOperationsInput | number;
    comentario?: NullableStringFieldUpdateOperationsInput | string | null;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    curso?: CursoUpdateOneWithoutResenasNestedInput;
    producto?: ProductoUpdateOneWithoutResenasNestedInput;
    usuario?: UsuarioUpdateOneRequiredWithoutResenasNestedInput;
    respuestas?: ResenaRespuestaUpdateManyWithoutResenaNestedInput;
    likes?: ResenaLikeUpdateManyWithoutResenaNestedInput;
  };

  export type ResenaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    cursoId?: NullableIntFieldUpdateOperationsInput | number | null;
    productoId?: NullableIntFieldUpdateOperationsInput | number | null;
    usuarioId?: IntFieldUpdateOperationsInput | number;
    puntaje?: IntFieldUpdateOperationsInput | number;
    comentario?: NullableStringFieldUpdateOperationsInput | string | null;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    respuestas?: ResenaRespuestaUncheckedUpdateManyWithoutResenaNestedInput;
    likes?: ResenaLikeUncheckedUpdateManyWithoutResenaNestedInput;
  };

  export type ResenaCreateManyInput = {
    id?: number;
    cursoId?: number | null;
    productoId?: number | null;
    usuarioId: number;
    puntaje: number;
    comentario?: string | null;
    creadoEn?: Date | string;
  };

  export type ResenaUpdateManyMutationInput = {
    puntaje?: IntFieldUpdateOperationsInput | number;
    comentario?: NullableStringFieldUpdateOperationsInput | string | null;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ResenaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    cursoId?: NullableIntFieldUpdateOperationsInput | number | null;
    productoId?: NullableIntFieldUpdateOperationsInput | number | null;
    usuarioId?: IntFieldUpdateOperationsInput | number;
    puntaje?: IntFieldUpdateOperationsInput | number;
    comentario?: NullableStringFieldUpdateOperationsInput | string | null;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ResenaLikeCreateInput = {
    tipo: $Enums.TipoLike;
    creadoEn?: Date | string;
    resena: ResenaCreateNestedOneWithoutLikesInput;
    usuario: UsuarioCreateNestedOneWithoutResenaLikesInput;
  };

  export type ResenaLikeUncheckedCreateInput = {
    id?: number;
    resenaId: number;
    usuarioId: number;
    tipo: $Enums.TipoLike;
    creadoEn?: Date | string;
  };

  export type ResenaLikeUpdateInput = {
    tipo?: EnumTipoLikeFieldUpdateOperationsInput | $Enums.TipoLike;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    resena?: ResenaUpdateOneRequiredWithoutLikesNestedInput;
    usuario?: UsuarioUpdateOneRequiredWithoutResenaLikesNestedInput;
  };

  export type ResenaLikeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    resenaId?: IntFieldUpdateOperationsInput | number;
    usuarioId?: IntFieldUpdateOperationsInput | number;
    tipo?: EnumTipoLikeFieldUpdateOperationsInput | $Enums.TipoLike;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ResenaLikeCreateManyInput = {
    id?: number;
    resenaId: number;
    usuarioId: number;
    tipo: $Enums.TipoLike;
    creadoEn?: Date | string;
  };

  export type ResenaLikeUpdateManyMutationInput = {
    tipo?: EnumTipoLikeFieldUpdateOperationsInput | $Enums.TipoLike;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ResenaLikeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    resenaId?: IntFieldUpdateOperationsInput | number;
    usuarioId?: IntFieldUpdateOperationsInput | number;
    tipo?: EnumTipoLikeFieldUpdateOperationsInput | $Enums.TipoLike;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ResenaRespuestaCreateInput = {
    contenido: string;
    eliminado?: boolean;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
    resena: ResenaCreateNestedOneWithoutRespuestasInput;
    usuario: UsuarioCreateNestedOneWithoutResenaRespuestasInput;
    parent?: ResenaRespuestaCreateNestedOneWithoutHijosInput;
    hijos?: ResenaRespuestaCreateNestedManyWithoutParentInput;
  };

  export type ResenaRespuestaUncheckedCreateInput = {
    id?: number;
    resenaId: number;
    usuarioId: number;
    parentId?: number | null;
    contenido: string;
    eliminado?: boolean;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
    hijos?: ResenaRespuestaUncheckedCreateNestedManyWithoutParentInput;
  };

  export type ResenaRespuestaUpdateInput = {
    contenido?: StringFieldUpdateOperationsInput | string;
    eliminado?: BoolFieldUpdateOperationsInput | boolean;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    resena?: ResenaUpdateOneRequiredWithoutRespuestasNestedInput;
    usuario?: UsuarioUpdateOneRequiredWithoutResenaRespuestasNestedInput;
    parent?: ResenaRespuestaUpdateOneWithoutHijosNestedInput;
    hijos?: ResenaRespuestaUpdateManyWithoutParentNestedInput;
  };

  export type ResenaRespuestaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    resenaId?: IntFieldUpdateOperationsInput | number;
    usuarioId?: IntFieldUpdateOperationsInput | number;
    parentId?: NullableIntFieldUpdateOperationsInput | number | null;
    contenido?: StringFieldUpdateOperationsInput | string;
    eliminado?: BoolFieldUpdateOperationsInput | boolean;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    hijos?: ResenaRespuestaUncheckedUpdateManyWithoutParentNestedInput;
  };

  export type ResenaRespuestaCreateManyInput = {
    id?: number;
    resenaId: number;
    usuarioId: number;
    parentId?: number | null;
    contenido: string;
    eliminado?: boolean;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
  };

  export type ResenaRespuestaUpdateManyMutationInput = {
    contenido?: StringFieldUpdateOperationsInput | string;
    eliminado?: BoolFieldUpdateOperationsInput | boolean;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ResenaRespuestaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    resenaId?: IntFieldUpdateOperationsInput | number;
    usuarioId?: IntFieldUpdateOperationsInput | number;
    parentId?: NullableIntFieldUpdateOperationsInput | number | null;
    contenido?: StringFieldUpdateOperationsInput | string;
    eliminado?: BoolFieldUpdateOperationsInput | boolean;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificacionCreateInput = {
    tipo: $Enums.TipoNotificacion;
    titulo: string;
    mensaje: string;
    leida?: boolean;
    url?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    creadoEn?: Date | string;
    usuario: UsuarioCreateNestedOneWithoutNotificacionesInput;
  };

  export type NotificacionUncheckedCreateInput = {
    id?: number;
    usuarioId: number;
    tipo: $Enums.TipoNotificacion;
    titulo: string;
    mensaje: string;
    leida?: boolean;
    url?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    creadoEn?: Date | string;
  };

  export type NotificacionUpdateInput = {
    tipo?:
      | EnumTipoNotificacionFieldUpdateOperationsInput
      | $Enums.TipoNotificacion;
    titulo?: StringFieldUpdateOperationsInput | string;
    mensaje?: StringFieldUpdateOperationsInput | string;
    leida?: BoolFieldUpdateOperationsInput | boolean;
    url?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    usuario?: UsuarioUpdateOneRequiredWithoutNotificacionesNestedInput;
  };

  export type NotificacionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    usuarioId?: IntFieldUpdateOperationsInput | number;
    tipo?:
      | EnumTipoNotificacionFieldUpdateOperationsInput
      | $Enums.TipoNotificacion;
    titulo?: StringFieldUpdateOperationsInput | string;
    mensaje?: StringFieldUpdateOperationsInput | string;
    leida?: BoolFieldUpdateOperationsInput | boolean;
    url?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificacionCreateManyInput = {
    id?: number;
    usuarioId: number;
    tipo: $Enums.TipoNotificacion;
    titulo: string;
    mensaje: string;
    leida?: boolean;
    url?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    creadoEn?: Date | string;
  };

  export type NotificacionUpdateManyMutationInput = {
    tipo?:
      | EnumTipoNotificacionFieldUpdateOperationsInput
      | $Enums.TipoNotificacion;
    titulo?: StringFieldUpdateOperationsInput | string;
    mensaje?: StringFieldUpdateOperationsInput | string;
    leida?: BoolFieldUpdateOperationsInput | boolean;
    url?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificacionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    usuarioId?: IntFieldUpdateOperationsInput | number;
    tipo?:
      | EnumTipoNotificacionFieldUpdateOperationsInput
      | $Enums.TipoNotificacion;
    titulo?: StringFieldUpdateOperationsInput | string;
    mensaje?: StringFieldUpdateOperationsInput | string;
    leida?: BoolFieldUpdateOperationsInput | boolean;
    url?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PreferenciasNotificacionCreateInput = {
    usuarioId: number;
    nuevaResena?: boolean;
    respuestaResena?: boolean;
    actualizacionesSistema?: boolean;
    mantenimiento?: boolean;
    reporteContenido?: boolean;
    contenidoPendiente?: boolean;
    resumenDiario?: boolean;
    notificacionesInstantaneas?: boolean;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
  };

  export type PreferenciasNotificacionUncheckedCreateInput = {
    id?: number;
    usuarioId: number;
    nuevaResena?: boolean;
    respuestaResena?: boolean;
    actualizacionesSistema?: boolean;
    mantenimiento?: boolean;
    reporteContenido?: boolean;
    contenidoPendiente?: boolean;
    resumenDiario?: boolean;
    notificacionesInstantaneas?: boolean;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
  };

  export type PreferenciasNotificacionUpdateInput = {
    usuarioId?: IntFieldUpdateOperationsInput | number;
    nuevaResena?: BoolFieldUpdateOperationsInput | boolean;
    respuestaResena?: BoolFieldUpdateOperationsInput | boolean;
    actualizacionesSistema?: BoolFieldUpdateOperationsInput | boolean;
    mantenimiento?: BoolFieldUpdateOperationsInput | boolean;
    reporteContenido?: BoolFieldUpdateOperationsInput | boolean;
    contenidoPendiente?: BoolFieldUpdateOperationsInput | boolean;
    resumenDiario?: BoolFieldUpdateOperationsInput | boolean;
    notificacionesInstantaneas?: BoolFieldUpdateOperationsInput | boolean;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PreferenciasNotificacionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    usuarioId?: IntFieldUpdateOperationsInput | number;
    nuevaResena?: BoolFieldUpdateOperationsInput | boolean;
    respuestaResena?: BoolFieldUpdateOperationsInput | boolean;
    actualizacionesSistema?: BoolFieldUpdateOperationsInput | boolean;
    mantenimiento?: BoolFieldUpdateOperationsInput | boolean;
    reporteContenido?: BoolFieldUpdateOperationsInput | boolean;
    contenidoPendiente?: BoolFieldUpdateOperationsInput | boolean;
    resumenDiario?: BoolFieldUpdateOperationsInput | boolean;
    notificacionesInstantaneas?: BoolFieldUpdateOperationsInput | boolean;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PreferenciasNotificacionCreateManyInput = {
    id?: number;
    usuarioId: number;
    nuevaResena?: boolean;
    respuestaResena?: boolean;
    actualizacionesSistema?: boolean;
    mantenimiento?: boolean;
    reporteContenido?: boolean;
    contenidoPendiente?: boolean;
    resumenDiario?: boolean;
    notificacionesInstantaneas?: boolean;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
  };

  export type PreferenciasNotificacionUpdateManyMutationInput = {
    usuarioId?: IntFieldUpdateOperationsInput | number;
    nuevaResena?: BoolFieldUpdateOperationsInput | boolean;
    respuestaResena?: BoolFieldUpdateOperationsInput | boolean;
    actualizacionesSistema?: BoolFieldUpdateOperationsInput | boolean;
    mantenimiento?: BoolFieldUpdateOperationsInput | boolean;
    reporteContenido?: BoolFieldUpdateOperationsInput | boolean;
    contenidoPendiente?: BoolFieldUpdateOperationsInput | boolean;
    resumenDiario?: BoolFieldUpdateOperationsInput | boolean;
    notificacionesInstantaneas?: BoolFieldUpdateOperationsInput | boolean;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PreferenciasNotificacionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    usuarioId?: IntFieldUpdateOperationsInput | number;
    nuevaResena?: BoolFieldUpdateOperationsInput | boolean;
    respuestaResena?: BoolFieldUpdateOperationsInput | boolean;
    actualizacionesSistema?: BoolFieldUpdateOperationsInput | boolean;
    mantenimiento?: BoolFieldUpdateOperationsInput | boolean;
    reporteContenido?: BoolFieldUpdateOperationsInput | boolean;
    contenidoPendiente?: BoolFieldUpdateOperationsInput | boolean;
    resumenDiario?: BoolFieldUpdateOperationsInput | boolean;
    notificacionesInstantaneas?: BoolFieldUpdateOperationsInput | boolean;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ResenaBorradorCreateInput = {
    usuarioId: number;
    cursoId?: number | null;
    productoId?: number | null;
    puntaje?: number | null;
    comentario?: string | null;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
  };

  export type ResenaBorradorUncheckedCreateInput = {
    id?: number;
    usuarioId: number;
    cursoId?: number | null;
    productoId?: number | null;
    puntaje?: number | null;
    comentario?: string | null;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
  };

  export type ResenaBorradorUpdateInput = {
    usuarioId?: IntFieldUpdateOperationsInput | number;
    cursoId?: NullableIntFieldUpdateOperationsInput | number | null;
    productoId?: NullableIntFieldUpdateOperationsInput | number | null;
    puntaje?: NullableIntFieldUpdateOperationsInput | number | null;
    comentario?: NullableStringFieldUpdateOperationsInput | string | null;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ResenaBorradorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    usuarioId?: IntFieldUpdateOperationsInput | number;
    cursoId?: NullableIntFieldUpdateOperationsInput | number | null;
    productoId?: NullableIntFieldUpdateOperationsInput | number | null;
    puntaje?: NullableIntFieldUpdateOperationsInput | number | null;
    comentario?: NullableStringFieldUpdateOperationsInput | string | null;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ResenaBorradorCreateManyInput = {
    id?: number;
    usuarioId: number;
    cursoId?: number | null;
    productoId?: number | null;
    puntaje?: number | null;
    comentario?: string | null;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
  };

  export type ResenaBorradorUpdateManyMutationInput = {
    usuarioId?: IntFieldUpdateOperationsInput | number;
    cursoId?: NullableIntFieldUpdateOperationsInput | number | null;
    productoId?: NullableIntFieldUpdateOperationsInput | number | null;
    puntaje?: NullableIntFieldUpdateOperationsInput | number | null;
    comentario?: NullableStringFieldUpdateOperationsInput | string | null;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ResenaBorradorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    usuarioId?: IntFieldUpdateOperationsInput | number;
    cursoId?: NullableIntFieldUpdateOperationsInput | number | null;
    productoId?: NullableIntFieldUpdateOperationsInput | number | null;
    puntaje?: NullableIntFieldUpdateOperationsInput | number | null;
    comentario?: NullableStringFieldUpdateOperationsInput | string | null;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AuditLogCreateInput = {
    tableName: string;
    recordId: string;
    action: string;
    oldData?: NullableJsonNullValueInput | InputJsonValue;
    newData?: NullableJsonNullValueInput | InputJsonValue;
    userAgent?: string | null;
    ipAddress?: string | null;
    endpoint?: string | null;
    timestamp?: Date | string;
    user: UsuarioCreateNestedOneWithoutAuditLogsInput;
  };

  export type AuditLogUncheckedCreateInput = {
    id?: number;
    tableName: string;
    recordId: string;
    action: string;
    oldData?: NullableJsonNullValueInput | InputJsonValue;
    newData?: NullableJsonNullValueInput | InputJsonValue;
    userId: number;
    userAgent?: string | null;
    ipAddress?: string | null;
    endpoint?: string | null;
    timestamp?: Date | string;
  };

  export type AuditLogUpdateInput = {
    tableName?: StringFieldUpdateOperationsInput | string;
    recordId?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    oldData?: NullableJsonNullValueInput | InputJsonValue;
    newData?: NullableJsonNullValueInput | InputJsonValue;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UsuarioUpdateOneRequiredWithoutAuditLogsNestedInput;
  };

  export type AuditLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    tableName?: StringFieldUpdateOperationsInput | string;
    recordId?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    oldData?: NullableJsonNullValueInput | InputJsonValue;
    newData?: NullableJsonNullValueInput | InputJsonValue;
    userId?: IntFieldUpdateOperationsInput | number;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AuditLogCreateManyInput = {
    id?: number;
    tableName: string;
    recordId: string;
    action: string;
    oldData?: NullableJsonNullValueInput | InputJsonValue;
    newData?: NullableJsonNullValueInput | InputJsonValue;
    userId: number;
    userAgent?: string | null;
    ipAddress?: string | null;
    endpoint?: string | null;
    timestamp?: Date | string;
  };

  export type AuditLogUpdateManyMutationInput = {
    tableName?: StringFieldUpdateOperationsInput | string;
    recordId?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    oldData?: NullableJsonNullValueInput | InputJsonValue;
    newData?: NullableJsonNullValueInput | InputJsonValue;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AuditLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    tableName?: StringFieldUpdateOperationsInput | string;
    recordId?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    oldData?: NullableJsonNullValueInput | InputJsonValue;
    newData?: NullableJsonNullValueInput | InputJsonValue;
    userId?: IntFieldUpdateOperationsInput | number;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type CarritoCreateInput = {
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
    usuario: UsuarioCreateNestedOneWithoutCarritoInput;
    items?: ItemCarritoCreateNestedManyWithoutCarritoInput;
  };

  export type CarritoUncheckedCreateInput = {
    id?: number;
    usuarioId: number;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
    items?: ItemCarritoUncheckedCreateNestedManyWithoutCarritoInput;
  };

  export type CarritoUpdateInput = {
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    usuario?: UsuarioUpdateOneRequiredWithoutCarritoNestedInput;
    items?: ItemCarritoUpdateManyWithoutCarritoNestedInput;
  };

  export type CarritoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    usuarioId?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    items?: ItemCarritoUncheckedUpdateManyWithoutCarritoNestedInput;
  };

  export type CarritoCreateManyInput = {
    id?: number;
    usuarioId: number;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
  };

  export type CarritoUpdateManyMutationInput = {
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type CarritoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    usuarioId?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ItemCarritoCreateInput = {
    tipo: $Enums.TipoItemOrden;
    cantidad?: number;
    creadoEn?: Date | string;
    carrito: CarritoCreateNestedOneWithoutItemsInput;
    producto?: ProductoCreateNestedOneWithoutItemsCarritoInput;
    curso?: CursoCreateNestedOneWithoutItemsCarritoInput;
  };

  export type ItemCarritoUncheckedCreateInput = {
    id?: number;
    carritoId: number;
    tipo: $Enums.TipoItemOrden;
    productoId?: number | null;
    cursoId?: number | null;
    cantidad?: number;
    creadoEn?: Date | string;
  };

  export type ItemCarritoUpdateInput = {
    tipo?: EnumTipoItemOrdenFieldUpdateOperationsInput | $Enums.TipoItemOrden;
    cantidad?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    carrito?: CarritoUpdateOneRequiredWithoutItemsNestedInput;
    producto?: ProductoUpdateOneWithoutItemsCarritoNestedInput;
    curso?: CursoUpdateOneWithoutItemsCarritoNestedInput;
  };

  export type ItemCarritoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    carritoId?: IntFieldUpdateOperationsInput | number;
    tipo?: EnumTipoItemOrdenFieldUpdateOperationsInput | $Enums.TipoItemOrden;
    productoId?: NullableIntFieldUpdateOperationsInput | number | null;
    cursoId?: NullableIntFieldUpdateOperationsInput | number | null;
    cantidad?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ItemCarritoCreateManyInput = {
    id?: number;
    carritoId: number;
    tipo: $Enums.TipoItemOrden;
    productoId?: number | null;
    cursoId?: number | null;
    cantidad?: number;
    creadoEn?: Date | string;
  };

  export type ItemCarritoUpdateManyMutationInput = {
    tipo?: EnumTipoItemOrdenFieldUpdateOperationsInput | $Enums.TipoItemOrden;
    cantidad?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ItemCarritoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    carritoId?: IntFieldUpdateOperationsInput | number;
    tipo?: EnumTipoItemOrdenFieldUpdateOperationsInput | $Enums.TipoItemOrden;
    productoId?: NullableIntFieldUpdateOperationsInput | number | null;
    cursoId?: NullableIntFieldUpdateOperationsInput | number | null;
    cantidad?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[];
    notIn?: number[];
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
  };

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[];
    notIn?: string[];
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    search?: string;
    not?: NestedStringFilter<$PrismaModel> | string;
  };

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | null;
    notIn?: string[] | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    search?: string;
    not?: NestedStringNullableFilter<$PrismaModel> | string | null;
  };

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[];
    notIn?: Date[] | string[];
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
  };

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | null;
    notIn?: Date[] | string[] | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
  };

  export type UsuarioRolListRelationFilter = {
    every?: UsuarioRolWhereInput;
    some?: UsuarioRolWhereInput;
    none?: UsuarioRolWhereInput;
  };

  export type CursoListRelationFilter = {
    every?: CursoWhereInput;
    some?: CursoWhereInput;
    none?: CursoWhereInput;
  };

  export type InscripcionListRelationFilter = {
    every?: InscripcionWhereInput;
    some?: InscripcionWhereInput;
    none?: InscripcionWhereInput;
  };

  export type ResenaListRelationFilter = {
    every?: ResenaWhereInput;
    some?: ResenaWhereInput;
    none?: ResenaWhereInput;
  };

  export type ResenaRespuestaListRelationFilter = {
    every?: ResenaRespuestaWhereInput;
    some?: ResenaRespuestaWhereInput;
    none?: ResenaRespuestaWhereInput;
  };

  export type FavoritoListRelationFilter = {
    every?: FavoritoWhereInput;
    some?: FavoritoWhereInput;
    none?: FavoritoWhereInput;
  };

  export type ResenaLikeListRelationFilter = {
    every?: ResenaLikeWhereInput;
    some?: ResenaLikeWhereInput;
    none?: ResenaLikeWhereInput;
  };

  export type OrdenListRelationFilter = {
    every?: OrdenWhereInput;
    some?: OrdenWhereInput;
    none?: OrdenWhereInput;
  };

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput;
    some?: AuditLogWhereInput;
    none?: AuditLogWhereInput;
  };

  export type CarritoNullableScalarRelationFilter = {
    is?: CarritoWhereInput | null;
    isNot?: CarritoWhereInput | null;
  };

  export type NotificacionListRelationFilter = {
    every?: NotificacionWhereInput;
    some?: NotificacionWhereInput;
    none?: NotificacionWhereInput;
  };

  export type SortOrderInput = {
    sort: SortOrder;
    nulls?: NullsOrder;
  };

  export type UsuarioRolOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type CursoOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type InscripcionOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type ResenaOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type ResenaRespuestaOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type FavoritoOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type ResenaLikeOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type OrdenOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type NotificacionOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type UsuarioOrderByRelevanceInput = {
    fields:
      | UsuarioOrderByRelevanceFieldEnum
      | UsuarioOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type UsuarioCountOrderByAggregateInput = {
    id?: SortOrder;
    email?: SortOrder;
    nombre?: SortOrder;
    passwordHash?: SortOrder;
    creadoEn?: SortOrder;
    actualizadoEn?: SortOrder;
    emailVerificadoEn?: SortOrder;
  };

  export type UsuarioAvgOrderByAggregateInput = {
    id?: SortOrder;
  };

  export type UsuarioMaxOrderByAggregateInput = {
    id?: SortOrder;
    email?: SortOrder;
    nombre?: SortOrder;
    passwordHash?: SortOrder;
    creadoEn?: SortOrder;
    actualizadoEn?: SortOrder;
    emailVerificadoEn?: SortOrder;
  };

  export type UsuarioMinOrderByAggregateInput = {
    id?: SortOrder;
    email?: SortOrder;
    nombre?: SortOrder;
    passwordHash?: SortOrder;
    creadoEn?: SortOrder;
    actualizadoEn?: SortOrder;
    emailVerificadoEn?: SortOrder;
  };

  export type UsuarioSumOrderByAggregateInput = {
    id?: SortOrder;
  };

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[];
    notIn?: number[];
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
  };

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[];
    notIn?: string[];
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    search?: string;
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | null;
    notIn?: string[] | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    search?: string;
    not?:
      | NestedStringNullableWithAggregatesFilter<$PrismaModel>
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
  };

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[];
    notIn?: Date[] | string[];
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedDateTimeFilter<$PrismaModel>;
    _max?: NestedDateTimeFilter<$PrismaModel>;
  };

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | null;
    notIn?: Date[] | string[] | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?:
      | NestedDateTimeNullableWithAggregatesFilter<$PrismaModel>
      | Date
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedDateTimeNullableFilter<$PrismaModel>;
    _max?: NestedDateTimeNullableFilter<$PrismaModel>;
  };

  export type RoleOrderByRelevanceInput = {
    fields: RoleOrderByRelevanceFieldEnum | RoleOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder;
    slug?: SortOrder;
    name?: SortOrder;
    createdAt?: SortOrder;
  };

  export type RoleAvgOrderByAggregateInput = {
    id?: SortOrder;
  };

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder;
    slug?: SortOrder;
    name?: SortOrder;
    createdAt?: SortOrder;
  };

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder;
    slug?: SortOrder;
    name?: SortOrder;
    createdAt?: SortOrder;
  };

  export type RoleSumOrderByAggregateInput = {
    id?: SortOrder;
  };

  export type UsuarioScalarRelationFilter = {
    is?: UsuarioWhereInput;
    isNot?: UsuarioWhereInput;
  };

  export type RoleScalarRelationFilter = {
    is?: RoleWhereInput;
    isNot?: RoleWhereInput;
  };

  export type UsuarioRolUsuarioIdRoleIdCompoundUniqueInput = {
    usuarioId: number;
    roleId: number;
  };

  export type UsuarioRolCountOrderByAggregateInput = {
    usuarioId?: SortOrder;
    roleId?: SortOrder;
  };

  export type UsuarioRolAvgOrderByAggregateInput = {
    usuarioId?: SortOrder;
    roleId?: SortOrder;
  };

  export type UsuarioRolMaxOrderByAggregateInput = {
    usuarioId?: SortOrder;
    roleId?: SortOrder;
  };

  export type UsuarioRolMinOrderByAggregateInput = {
    usuarioId?: SortOrder;
    roleId?: SortOrder;
  };

  export type UsuarioRolSumOrderByAggregateInput = {
    usuarioId?: SortOrder;
    roleId?: SortOrder;
  };

  export type ProductoScalarRelationFilter = {
    is?: ProductoWhereInput;
    isNot?: ProductoWhereInput;
  };

  export type FavoritoUsuarioIdProductoIdCompoundUniqueInput = {
    usuarioId: number;
    productoId: number;
  };

  export type FavoritoCountOrderByAggregateInput = {
    id?: SortOrder;
    usuarioId?: SortOrder;
    productoId?: SortOrder;
    creadoEn?: SortOrder;
  };

  export type FavoritoAvgOrderByAggregateInput = {
    id?: SortOrder;
    usuarioId?: SortOrder;
    productoId?: SortOrder;
  };

  export type FavoritoMaxOrderByAggregateInput = {
    id?: SortOrder;
    usuarioId?: SortOrder;
    productoId?: SortOrder;
    creadoEn?: SortOrder;
  };

  export type FavoritoMinOrderByAggregateInput = {
    id?: SortOrder;
    usuarioId?: SortOrder;
    productoId?: SortOrder;
    creadoEn?: SortOrder;
  };

  export type FavoritoSumOrderByAggregateInput = {
    id?: SortOrder;
    usuarioId?: SortOrder;
    productoId?: SortOrder;
  };

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolFilter<$PrismaModel> | boolean;
  };

  export type EnumNivelCursoFilter<$PrismaModel = never> = {
    equals?: $Enums.NivelCurso | EnumNivelCursoFieldRefInput<$PrismaModel>;
    in?: $Enums.NivelCurso[];
    notIn?: $Enums.NivelCurso[];
    not?: NestedEnumNivelCursoFilter<$PrismaModel> | $Enums.NivelCurso;
  };
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonNullableFilterBase<$PrismaModel>>,
          Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>
        >,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<
        Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>
      >;

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    path?: string;
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue;
    lte?: InputJsonValue;
    gt?: InputJsonValue;
    gte?: InputJsonValue;
    not?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
  };

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>
      | null;
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null;
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null;
    lt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    lte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    not?:
      | NestedDecimalNullableFilter<$PrismaModel>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
  };

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | null;
    notIn?: number[] | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableFilter<$PrismaModel> | number | null;
  };

  export type UsuarioNullableScalarRelationFilter = {
    is?: UsuarioWhereInput | null;
    isNot?: UsuarioWhereInput | null;
  };

  export type ModuloListRelationFilter = {
    every?: ModuloWhereInput;
    some?: ModuloWhereInput;
    none?: ModuloWhereInput;
  };

  export type ItemCarritoListRelationFilter = {
    every?: ItemCarritoWhereInput;
    some?: ItemCarritoWhereInput;
    none?: ItemCarritoWhereInput;
  };

  export type ModuloOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type ItemCarritoOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type CursoOrderByRelevanceInput = {
    fields: CursoOrderByRelevanceFieldEnum | CursoOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type CursoCountOrderByAggregateInput = {
    id?: SortOrder;
    slug?: SortOrder;
    titulo?: SortOrder;
    resumen?: SortOrder;
    descripcionMD?: SortOrder;
    requisitos?: SortOrder;
    precio?: SortOrder;
    publicado?: SortOrder;
    nivel?: SortOrder;
    portada?: SortOrder;
    destacado?: SortOrder;
    tags?: SortOrder;
    ratingProm?: SortOrder;
    ratingConteo?: SortOrder;
    creadoEn?: SortOrder;
    instructorId?: SortOrder;
  };

  export type CursoAvgOrderByAggregateInput = {
    id?: SortOrder;
    precio?: SortOrder;
    ratingProm?: SortOrder;
    ratingConteo?: SortOrder;
    instructorId?: SortOrder;
  };

  export type CursoMaxOrderByAggregateInput = {
    id?: SortOrder;
    slug?: SortOrder;
    titulo?: SortOrder;
    resumen?: SortOrder;
    descripcionMD?: SortOrder;
    requisitos?: SortOrder;
    precio?: SortOrder;
    publicado?: SortOrder;
    nivel?: SortOrder;
    portada?: SortOrder;
    destacado?: SortOrder;
    ratingProm?: SortOrder;
    ratingConteo?: SortOrder;
    creadoEn?: SortOrder;
    instructorId?: SortOrder;
  };

  export type CursoMinOrderByAggregateInput = {
    id?: SortOrder;
    slug?: SortOrder;
    titulo?: SortOrder;
    resumen?: SortOrder;
    descripcionMD?: SortOrder;
    requisitos?: SortOrder;
    precio?: SortOrder;
    publicado?: SortOrder;
    nivel?: SortOrder;
    portada?: SortOrder;
    destacado?: SortOrder;
    ratingProm?: SortOrder;
    ratingConteo?: SortOrder;
    creadoEn?: SortOrder;
    instructorId?: SortOrder;
  };

  export type CursoSumOrderByAggregateInput = {
    id?: SortOrder;
    precio?: SortOrder;
    ratingProm?: SortOrder;
    ratingConteo?: SortOrder;
    instructorId?: SortOrder;
  };

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedBoolFilter<$PrismaModel>;
    _max?: NestedBoolFilter<$PrismaModel>;
  };

  export type EnumNivelCursoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NivelCurso | EnumNivelCursoFieldRefInput<$PrismaModel>;
    in?: $Enums.NivelCurso[];
    notIn?: $Enums.NivelCurso[];
    not?:
      | NestedEnumNivelCursoWithAggregatesFilter<$PrismaModel>
      | $Enums.NivelCurso;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumNivelCursoFilter<$PrismaModel>;
    _max?: NestedEnumNivelCursoFilter<$PrismaModel>;
  };
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>,
          Exclude<
            keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>,
            'path'
          >
        >,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<
        Omit<
          Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>,
          'path'
        >
      >;

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    path?: string;
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue;
    lte?: InputJsonValue;
    gt?: InputJsonValue;
    gte?: InputJsonValue;
    not?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedJsonNullableFilter<$PrismaModel>;
    _max?: NestedJsonNullableFilter<$PrismaModel>;
  };

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>
      | null;
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null;
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null;
    lt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    lte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    not?:
      | NestedDecimalNullableWithAggregatesFilter<$PrismaModel>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedDecimalNullableFilter<$PrismaModel>;
    _sum?: NestedDecimalNullableFilter<$PrismaModel>;
    _min?: NestedDecimalNullableFilter<$PrismaModel>;
    _max?: NestedDecimalNullableFilter<$PrismaModel>;
  };

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | null;
    notIn?: number[] | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedIntNullableFilter<$PrismaModel>;
    _max?: NestedIntNullableFilter<$PrismaModel>;
  };

  export type EnumEstadoInscripcionFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.EstadoInscripcion
      | EnumEstadoInscripcionFieldRefInput<$PrismaModel>;
    in?: $Enums.EstadoInscripcion[];
    notIn?: $Enums.EstadoInscripcion[];
    not?:
      | NestedEnumEstadoInscripcionFilter<$PrismaModel>
      | $Enums.EstadoInscripcion;
  };
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonFilterBase<$PrismaModel>>,
          Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>
        >,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>;

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    path?: string;
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue;
    lte?: InputJsonValue;
    gt?: InputJsonValue;
    gte?: InputJsonValue;
    not?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
  };

  export type CursoScalarRelationFilter = {
    is?: CursoWhereInput;
    isNot?: CursoWhereInput;
  };

  export type InscripcionUsuarioIdCursoIdCompoundUniqueInput = {
    usuarioId: number;
    cursoId: number;
  };

  export type InscripcionCountOrderByAggregateInput = {
    id?: SortOrder;
    usuarioId?: SortOrder;
    cursoId?: SortOrder;
    estado?: SortOrder;
    progreso?: SortOrder;
    creadoEn?: SortOrder;
    actualizadoEn?: SortOrder;
  };

  export type InscripcionAvgOrderByAggregateInput = {
    id?: SortOrder;
    usuarioId?: SortOrder;
    cursoId?: SortOrder;
  };

  export type InscripcionMaxOrderByAggregateInput = {
    id?: SortOrder;
    usuarioId?: SortOrder;
    cursoId?: SortOrder;
    estado?: SortOrder;
    creadoEn?: SortOrder;
    actualizadoEn?: SortOrder;
  };

  export type InscripcionMinOrderByAggregateInput = {
    id?: SortOrder;
    usuarioId?: SortOrder;
    cursoId?: SortOrder;
    estado?: SortOrder;
    creadoEn?: SortOrder;
    actualizadoEn?: SortOrder;
  };

  export type InscripcionSumOrderByAggregateInput = {
    id?: SortOrder;
    usuarioId?: SortOrder;
    cursoId?: SortOrder;
  };

  export type EnumEstadoInscripcionWithAggregatesFilter<$PrismaModel = never> =
    {
      equals?:
        | $Enums.EstadoInscripcion
        | EnumEstadoInscripcionFieldRefInput<$PrismaModel>;
      in?: $Enums.EstadoInscripcion[];
      notIn?: $Enums.EstadoInscripcion[];
      not?:
        | NestedEnumEstadoInscripcionWithAggregatesFilter<$PrismaModel>
        | $Enums.EstadoInscripcion;
      _count?: NestedIntFilter<$PrismaModel>;
      _min?: NestedEnumEstadoInscripcionFilter<$PrismaModel>;
      _max?: NestedEnumEstadoInscripcionFilter<$PrismaModel>;
    };
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonWithAggregatesFilterBase<$PrismaModel>>,
          Exclude<
            keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>,
            'path'
          >
        >,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<
        Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>
      >;

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    path?: string;
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue;
    lte?: InputJsonValue;
    gt?: InputJsonValue;
    gte?: InputJsonValue;
    not?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedJsonFilter<$PrismaModel>;
    _max?: NestedJsonFilter<$PrismaModel>;
  };

  export type LeccionListRelationFilter = {
    every?: LeccionWhereInput;
    some?: LeccionWhereInput;
    none?: LeccionWhereInput;
  };

  export type LeccionOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type ModuloOrderByRelevanceInput = {
    fields: ModuloOrderByRelevanceFieldEnum | ModuloOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type ModuloCountOrderByAggregateInput = {
    id?: SortOrder;
    cursoId?: SortOrder;
    titulo?: SortOrder;
    orden?: SortOrder;
    parentId?: SortOrder;
  };

  export type ModuloAvgOrderByAggregateInput = {
    id?: SortOrder;
    cursoId?: SortOrder;
    orden?: SortOrder;
    parentId?: SortOrder;
  };

  export type ModuloMaxOrderByAggregateInput = {
    id?: SortOrder;
    cursoId?: SortOrder;
    titulo?: SortOrder;
    orden?: SortOrder;
    parentId?: SortOrder;
  };

  export type ModuloMinOrderByAggregateInput = {
    id?: SortOrder;
    cursoId?: SortOrder;
    titulo?: SortOrder;
    orden?: SortOrder;
    parentId?: SortOrder;
  };

  export type ModuloSumOrderByAggregateInput = {
    id?: SortOrder;
    cursoId?: SortOrder;
    orden?: SortOrder;
    parentId?: SortOrder;
  };

  export type EnumTipoLeccionFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoLeccion | EnumTipoLeccionFieldRefInput<$PrismaModel>;
    in?: $Enums.TipoLeccion[];
    notIn?: $Enums.TipoLeccion[];
    not?: NestedEnumTipoLeccionFilter<$PrismaModel> | $Enums.TipoLeccion;
  };

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[];
    notIn?: number[];
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatFilter<$PrismaModel> | number;
  };

  export type ModuloScalarRelationFilter = {
    is?: ModuloWhereInput;
    isNot?: ModuloWhereInput;
  };

  export type LeccionOrderByRelevanceInput = {
    fields:
      | LeccionOrderByRelevanceFieldEnum
      | LeccionOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type LeccionCountOrderByAggregateInput = {
    id?: SortOrder;
    moduloId?: SortOrder;
    titulo?: SortOrder;
    rutaSrc?: SortOrder;
    orden?: SortOrder;
    tipo?: SortOrder;
    descripcion?: SortOrder;
    contenido?: SortOrder;
    previewUrl?: SortOrder;
    duracion?: SortOrder;
  };

  export type LeccionAvgOrderByAggregateInput = {
    id?: SortOrder;
    moduloId?: SortOrder;
    orden?: SortOrder;
    duracion?: SortOrder;
  };

  export type LeccionMaxOrderByAggregateInput = {
    id?: SortOrder;
    moduloId?: SortOrder;
    titulo?: SortOrder;
    rutaSrc?: SortOrder;
    orden?: SortOrder;
    tipo?: SortOrder;
    descripcion?: SortOrder;
    previewUrl?: SortOrder;
    duracion?: SortOrder;
  };

  export type LeccionMinOrderByAggregateInput = {
    id?: SortOrder;
    moduloId?: SortOrder;
    titulo?: SortOrder;
    rutaSrc?: SortOrder;
    orden?: SortOrder;
    tipo?: SortOrder;
    descripcion?: SortOrder;
    previewUrl?: SortOrder;
    duracion?: SortOrder;
  };

  export type LeccionSumOrderByAggregateInput = {
    id?: SortOrder;
    moduloId?: SortOrder;
    orden?: SortOrder;
    duracion?: SortOrder;
  };

  export type EnumTipoLeccionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoLeccion | EnumTipoLeccionFieldRefInput<$PrismaModel>;
    in?: $Enums.TipoLeccion[];
    notIn?: $Enums.TipoLeccion[];
    not?:
      | NestedEnumTipoLeccionWithAggregatesFilter<$PrismaModel>
      | $Enums.TipoLeccion;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumTipoLeccionFilter<$PrismaModel>;
    _max?: NestedEnumTipoLeccionFilter<$PrismaModel>;
  };

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[];
    notIn?: number[];
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedFloatFilter<$PrismaModel>;
    _min?: NestedFloatFilter<$PrismaModel>;
    _max?: NestedFloatFilter<$PrismaModel>;
  };

  export type LeccionTipoConfigCountOrderByAggregateInput = {
    id?: SortOrder;
    tipo?: SortOrder;
    schema?: SortOrder;
    ui?: SortOrder;
    version?: SortOrder;
    creadoEn?: SortOrder;
    actualizadoEn?: SortOrder;
  };

  export type LeccionTipoConfigAvgOrderByAggregateInput = {
    id?: SortOrder;
    version?: SortOrder;
  };

  export type LeccionTipoConfigMaxOrderByAggregateInput = {
    id?: SortOrder;
    tipo?: SortOrder;
    version?: SortOrder;
    creadoEn?: SortOrder;
    actualizadoEn?: SortOrder;
  };

  export type LeccionTipoConfigMinOrderByAggregateInput = {
    id?: SortOrder;
    tipo?: SortOrder;
    version?: SortOrder;
    creadoEn?: SortOrder;
    actualizadoEn?: SortOrder;
  };

  export type LeccionTipoConfigSumOrderByAggregateInput = {
    id?: SortOrder;
    version?: SortOrder;
  };

  export type MarcaNullableScalarRelationFilter = {
    is?: MarcaWhereInput | null;
    isNot?: MarcaWhereInput | null;
  };

  export type CategoriaNullableScalarRelationFilter = {
    is?: CategoriaWhereInput | null;
    isNot?: CategoriaWhereInput | null;
  };

  export type ProductoImagenListRelationFilter = {
    every?: ProductoImagenWhereInput;
    some?: ProductoImagenWhereInput;
    none?: ProductoImagenWhereInput;
  };

  export type ProductoImagenOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type ProductoOrderByRelevanceInput = {
    fields:
      | ProductoOrderByRelevanceFieldEnum
      | ProductoOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type ProductoCountOrderByAggregateInput = {
    id?: SortOrder;
    slug?: SortOrder;
    titulo?: SortOrder;
    precio?: SortOrder;
    stock?: SortOrder;
    publicado?: SortOrder;
    destacado?: SortOrder;
    imagen?: SortOrder;
    descripcionMD?: SortOrder;
    precioLista?: SortOrder;
    ratingProm?: SortOrder;
    ratingConteo?: SortOrder;
    creadoEn?: SortOrder;
    marcaId?: SortOrder;
    categoriaId?: SortOrder;
  };

  export type ProductoAvgOrderByAggregateInput = {
    id?: SortOrder;
    precio?: SortOrder;
    stock?: SortOrder;
    precioLista?: SortOrder;
    ratingProm?: SortOrder;
    ratingConteo?: SortOrder;
    marcaId?: SortOrder;
    categoriaId?: SortOrder;
  };

  export type ProductoMaxOrderByAggregateInput = {
    id?: SortOrder;
    slug?: SortOrder;
    titulo?: SortOrder;
    precio?: SortOrder;
    stock?: SortOrder;
    publicado?: SortOrder;
    destacado?: SortOrder;
    imagen?: SortOrder;
    descripcionMD?: SortOrder;
    precioLista?: SortOrder;
    ratingProm?: SortOrder;
    ratingConteo?: SortOrder;
    creadoEn?: SortOrder;
    marcaId?: SortOrder;
    categoriaId?: SortOrder;
  };

  export type ProductoMinOrderByAggregateInput = {
    id?: SortOrder;
    slug?: SortOrder;
    titulo?: SortOrder;
    precio?: SortOrder;
    stock?: SortOrder;
    publicado?: SortOrder;
    destacado?: SortOrder;
    imagen?: SortOrder;
    descripcionMD?: SortOrder;
    precioLista?: SortOrder;
    ratingProm?: SortOrder;
    ratingConteo?: SortOrder;
    creadoEn?: SortOrder;
    marcaId?: SortOrder;
    categoriaId?: SortOrder;
  };

  export type ProductoSumOrderByAggregateInput = {
    id?: SortOrder;
    precio?: SortOrder;
    stock?: SortOrder;
    precioLista?: SortOrder;
    ratingProm?: SortOrder;
    ratingConteo?: SortOrder;
    marcaId?: SortOrder;
    categoriaId?: SortOrder;
  };

  export type ProductoImagenOrderByRelevanceInput = {
    fields:
      | ProductoImagenOrderByRelevanceFieldEnum
      | ProductoImagenOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type ProductoImagenCountOrderByAggregateInput = {
    id?: SortOrder;
    productoId?: SortOrder;
    archivo?: SortOrder;
    alt?: SortOrder;
    orden?: SortOrder;
  };

  export type ProductoImagenAvgOrderByAggregateInput = {
    id?: SortOrder;
    productoId?: SortOrder;
    orden?: SortOrder;
  };

  export type ProductoImagenMaxOrderByAggregateInput = {
    id?: SortOrder;
    productoId?: SortOrder;
    archivo?: SortOrder;
    alt?: SortOrder;
    orden?: SortOrder;
  };

  export type ProductoImagenMinOrderByAggregateInput = {
    id?: SortOrder;
    productoId?: SortOrder;
    archivo?: SortOrder;
    alt?: SortOrder;
    orden?: SortOrder;
  };

  export type ProductoImagenSumOrderByAggregateInput = {
    id?: SortOrder;
    productoId?: SortOrder;
    orden?: SortOrder;
  };

  export type ProductoListRelationFilter = {
    every?: ProductoWhereInput;
    some?: ProductoWhereInput;
    none?: ProductoWhereInput;
  };

  export type ProductoOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type MarcaOrderByRelevanceInput = {
    fields: MarcaOrderByRelevanceFieldEnum | MarcaOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type MarcaCountOrderByAggregateInput = {
    id?: SortOrder;
    slug?: SortOrder;
    nombre?: SortOrder;
    imagen?: SortOrder;
    activa?: SortOrder;
    orden?: SortOrder;
    creadoEn?: SortOrder;
  };

  export type MarcaAvgOrderByAggregateInput = {
    id?: SortOrder;
    orden?: SortOrder;
  };

  export type MarcaMaxOrderByAggregateInput = {
    id?: SortOrder;
    slug?: SortOrder;
    nombre?: SortOrder;
    imagen?: SortOrder;
    activa?: SortOrder;
    orden?: SortOrder;
    creadoEn?: SortOrder;
  };

  export type MarcaMinOrderByAggregateInput = {
    id?: SortOrder;
    slug?: SortOrder;
    nombre?: SortOrder;
    imagen?: SortOrder;
    activa?: SortOrder;
    orden?: SortOrder;
    creadoEn?: SortOrder;
  };

  export type MarcaSumOrderByAggregateInput = {
    id?: SortOrder;
    orden?: SortOrder;
  };

  export type CategoriaListRelationFilter = {
    every?: CategoriaWhereInput;
    some?: CategoriaWhereInput;
    none?: CategoriaWhereInput;
  };

  export type CategoriaOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type CategoriaOrderByRelevanceInput = {
    fields:
      | CategoriaOrderByRelevanceFieldEnum
      | CategoriaOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type CategoriaCountOrderByAggregateInput = {
    id?: SortOrder;
    slug?: SortOrder;
    nombre?: SortOrder;
    descripcion?: SortOrder;
    imagen?: SortOrder;
    activa?: SortOrder;
    orden?: SortOrder;
    creadoEn?: SortOrder;
    parentId?: SortOrder;
  };

  export type CategoriaAvgOrderByAggregateInput = {
    id?: SortOrder;
    orden?: SortOrder;
    parentId?: SortOrder;
  };

  export type CategoriaMaxOrderByAggregateInput = {
    id?: SortOrder;
    slug?: SortOrder;
    nombre?: SortOrder;
    descripcion?: SortOrder;
    imagen?: SortOrder;
    activa?: SortOrder;
    orden?: SortOrder;
    creadoEn?: SortOrder;
    parentId?: SortOrder;
  };

  export type CategoriaMinOrderByAggregateInput = {
    id?: SortOrder;
    slug?: SortOrder;
    nombre?: SortOrder;
    descripcion?: SortOrder;
    imagen?: SortOrder;
    activa?: SortOrder;
    orden?: SortOrder;
    creadoEn?: SortOrder;
    parentId?: SortOrder;
  };

  export type CategoriaSumOrderByAggregateInput = {
    id?: SortOrder;
    orden?: SortOrder;
    parentId?: SortOrder;
  };

  export type EnumEstadoOrdenFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoOrden | EnumEstadoOrdenFieldRefInput<$PrismaModel>;
    in?: $Enums.EstadoOrden[];
    notIn?: $Enums.EstadoOrden[];
    not?: NestedEnumEstadoOrdenFilter<$PrismaModel> | $Enums.EstadoOrden;
  };

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null;
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null;
  };

  export type DireccionNullableScalarRelationFilter = {
    is?: DireccionWhereInput | null;
    isNot?: DireccionWhereInput | null;
  };

  export type ItemOrdenListRelationFilter = {
    every?: ItemOrdenWhereInput;
    some?: ItemOrdenWhereInput;
    none?: ItemOrdenWhereInput;
  };

  export type ItemOrdenOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type OrdenOrderByRelevanceInput = {
    fields: OrdenOrderByRelevanceFieldEnum | OrdenOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type OrdenCountOrderByAggregateInput = {
    id?: SortOrder;
    usuarioId?: SortOrder;
    estado?: SortOrder;
    total?: SortOrder;
    moneda?: SortOrder;
    referenciaPago?: SortOrder;
    creadoEn?: SortOrder;
    actualizadoEn?: SortOrder;
    esSuscripcion?: SortOrder;
    suscripcionActiva?: SortOrder;
    suscripcionId?: SortOrder;
    suscripcionFrecuencia?: SortOrder;
    suscripcionTipoFrecuencia?: SortOrder;
    metadatos?: SortOrder;
    direccionEnvioId?: SortOrder;
    direccionFacturacionId?: SortOrder;
  };

  export type OrdenAvgOrderByAggregateInput = {
    id?: SortOrder;
    usuarioId?: SortOrder;
    total?: SortOrder;
    suscripcionFrecuencia?: SortOrder;
    direccionEnvioId?: SortOrder;
    direccionFacturacionId?: SortOrder;
  };

  export type OrdenMaxOrderByAggregateInput = {
    id?: SortOrder;
    usuarioId?: SortOrder;
    estado?: SortOrder;
    total?: SortOrder;
    moneda?: SortOrder;
    referenciaPago?: SortOrder;
    creadoEn?: SortOrder;
    actualizadoEn?: SortOrder;
    esSuscripcion?: SortOrder;
    suscripcionActiva?: SortOrder;
    suscripcionId?: SortOrder;
    suscripcionFrecuencia?: SortOrder;
    suscripcionTipoFrecuencia?: SortOrder;
    direccionEnvioId?: SortOrder;
    direccionFacturacionId?: SortOrder;
  };

  export type OrdenMinOrderByAggregateInput = {
    id?: SortOrder;
    usuarioId?: SortOrder;
    estado?: SortOrder;
    total?: SortOrder;
    moneda?: SortOrder;
    referenciaPago?: SortOrder;
    creadoEn?: SortOrder;
    actualizadoEn?: SortOrder;
    esSuscripcion?: SortOrder;
    suscripcionActiva?: SortOrder;
    suscripcionId?: SortOrder;
    suscripcionFrecuencia?: SortOrder;
    suscripcionTipoFrecuencia?: SortOrder;
    direccionEnvioId?: SortOrder;
    direccionFacturacionId?: SortOrder;
  };

  export type OrdenSumOrderByAggregateInput = {
    id?: SortOrder;
    usuarioId?: SortOrder;
    total?: SortOrder;
    suscripcionFrecuencia?: SortOrder;
    direccionEnvioId?: SortOrder;
    direccionFacturacionId?: SortOrder;
  };

  export type EnumEstadoOrdenWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoOrden | EnumEstadoOrdenFieldRefInput<$PrismaModel>;
    in?: $Enums.EstadoOrden[];
    notIn?: $Enums.EstadoOrden[];
    not?:
      | NestedEnumEstadoOrdenWithAggregatesFilter<$PrismaModel>
      | $Enums.EstadoOrden;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumEstadoOrdenFilter<$PrismaModel>;
    _max?: NestedEnumEstadoOrdenFilter<$PrismaModel>;
  };

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null;
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedBoolNullableFilter<$PrismaModel>;
    _max?: NestedBoolNullableFilter<$PrismaModel>;
  };

  export type EnumTipoItemOrdenFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.TipoItemOrden
      | EnumTipoItemOrdenFieldRefInput<$PrismaModel>;
    in?: $Enums.TipoItemOrden[];
    notIn?: $Enums.TipoItemOrden[];
    not?: NestedEnumTipoItemOrdenFilter<$PrismaModel> | $Enums.TipoItemOrden;
  };

  export type OrdenScalarRelationFilter = {
    is?: OrdenWhereInput;
    isNot?: OrdenWhereInput;
  };

  export type ItemOrdenOrderByRelevanceInput = {
    fields:
      | ItemOrdenOrderByRelevanceFieldEnum
      | ItemOrdenOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type ItemOrdenCountOrderByAggregateInput = {
    id?: SortOrder;
    ordenId?: SortOrder;
    tipo?: SortOrder;
    refId?: SortOrder;
    titulo?: SortOrder;
    cantidad?: SortOrder;
    precioUnitario?: SortOrder;
  };

  export type ItemOrdenAvgOrderByAggregateInput = {
    id?: SortOrder;
    ordenId?: SortOrder;
    refId?: SortOrder;
    cantidad?: SortOrder;
    precioUnitario?: SortOrder;
  };

  export type ItemOrdenMaxOrderByAggregateInput = {
    id?: SortOrder;
    ordenId?: SortOrder;
    tipo?: SortOrder;
    refId?: SortOrder;
    titulo?: SortOrder;
    cantidad?: SortOrder;
    precioUnitario?: SortOrder;
  };

  export type ItemOrdenMinOrderByAggregateInput = {
    id?: SortOrder;
    ordenId?: SortOrder;
    tipo?: SortOrder;
    refId?: SortOrder;
    titulo?: SortOrder;
    cantidad?: SortOrder;
    precioUnitario?: SortOrder;
  };

  export type ItemOrdenSumOrderByAggregateInput = {
    id?: SortOrder;
    ordenId?: SortOrder;
    refId?: SortOrder;
    cantidad?: SortOrder;
    precioUnitario?: SortOrder;
  };

  export type EnumTipoItemOrdenWithAggregatesFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.TipoItemOrden
      | EnumTipoItemOrdenFieldRefInput<$PrismaModel>;
    in?: $Enums.TipoItemOrden[];
    notIn?: $Enums.TipoItemOrden[];
    not?:
      | NestedEnumTipoItemOrdenWithAggregatesFilter<$PrismaModel>
      | $Enums.TipoItemOrden;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumTipoItemOrdenFilter<$PrismaModel>;
    _max?: NestedEnumTipoItemOrdenFilter<$PrismaModel>;
  };

  export type DecimalFilter<$PrismaModel = never> = {
    equals?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    in?: Decimal[] | DecimalJsLike[] | number[] | string[];
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[];
    lt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    lte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    not?:
      | NestedDecimalFilter<$PrismaModel>
      | Decimal
      | DecimalJsLike
      | number
      | string;
  };

  export type PagoSuscripcionOrderByRelevanceInput = {
    fields:
      | PagoSuscripcionOrderByRelevanceFieldEnum
      | PagoSuscripcionOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type PagoSuscripcionCountOrderByAggregateInput = {
    id?: SortOrder;
    ordenId?: SortOrder;
    usuarioId?: SortOrder;
    referenciaPago?: SortOrder;
    monto?: SortOrder;
    estado?: SortOrder;
    metadatos?: SortOrder;
    creadoEn?: SortOrder;
    actualizadoEn?: SortOrder;
  };

  export type PagoSuscripcionAvgOrderByAggregateInput = {
    id?: SortOrder;
    ordenId?: SortOrder;
    usuarioId?: SortOrder;
    monto?: SortOrder;
  };

  export type PagoSuscripcionMaxOrderByAggregateInput = {
    id?: SortOrder;
    ordenId?: SortOrder;
    usuarioId?: SortOrder;
    referenciaPago?: SortOrder;
    monto?: SortOrder;
    estado?: SortOrder;
    creadoEn?: SortOrder;
    actualizadoEn?: SortOrder;
  };

  export type PagoSuscripcionMinOrderByAggregateInput = {
    id?: SortOrder;
    ordenId?: SortOrder;
    usuarioId?: SortOrder;
    referenciaPago?: SortOrder;
    monto?: SortOrder;
    estado?: SortOrder;
    creadoEn?: SortOrder;
    actualizadoEn?: SortOrder;
  };

  export type PagoSuscripcionSumOrderByAggregateInput = {
    id?: SortOrder;
    ordenId?: SortOrder;
    usuarioId?: SortOrder;
    monto?: SortOrder;
  };

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    in?: Decimal[] | DecimalJsLike[] | number[] | string[];
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[];
    lt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    lte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    not?:
      | NestedDecimalWithAggregatesFilter<$PrismaModel>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedDecimalFilter<$PrismaModel>;
    _sum?: NestedDecimalFilter<$PrismaModel>;
    _min?: NestedDecimalFilter<$PrismaModel>;
    _max?: NestedDecimalFilter<$PrismaModel>;
  };

  export type DireccionOrderByRelevanceInput = {
    fields:
      | DireccionOrderByRelevanceFieldEnum
      | DireccionOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type DireccionCountOrderByAggregateInput = {
    id?: SortOrder;
    usuarioId?: SortOrder;
    etiqueta?: SortOrder;
    nombre?: SortOrder;
    telefono?: SortOrder;
    calle?: SortOrder;
    numero?: SortOrder;
    pisoDepto?: SortOrder;
    ciudad?: SortOrder;
    provincia?: SortOrder;
    cp?: SortOrder;
    pais?: SortOrder;
    predeterminada?: SortOrder;
    creadoEn?: SortOrder;
    actualizadoEn?: SortOrder;
  };

  export type DireccionAvgOrderByAggregateInput = {
    id?: SortOrder;
    usuarioId?: SortOrder;
  };

  export type DireccionMaxOrderByAggregateInput = {
    id?: SortOrder;
    usuarioId?: SortOrder;
    etiqueta?: SortOrder;
    nombre?: SortOrder;
    telefono?: SortOrder;
    calle?: SortOrder;
    numero?: SortOrder;
    pisoDepto?: SortOrder;
    ciudad?: SortOrder;
    provincia?: SortOrder;
    cp?: SortOrder;
    pais?: SortOrder;
    predeterminada?: SortOrder;
    creadoEn?: SortOrder;
    actualizadoEn?: SortOrder;
  };

  export type DireccionMinOrderByAggregateInput = {
    id?: SortOrder;
    usuarioId?: SortOrder;
    etiqueta?: SortOrder;
    nombre?: SortOrder;
    telefono?: SortOrder;
    calle?: SortOrder;
    numero?: SortOrder;
    pisoDepto?: SortOrder;
    ciudad?: SortOrder;
    provincia?: SortOrder;
    cp?: SortOrder;
    pais?: SortOrder;
    predeterminada?: SortOrder;
    creadoEn?: SortOrder;
    actualizadoEn?: SortOrder;
  };

  export type DireccionSumOrderByAggregateInput = {
    id?: SortOrder;
    usuarioId?: SortOrder;
  };

  export type SliderOrderByRelevanceInput = {
    fields: SliderOrderByRelevanceFieldEnum | SliderOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type SliderCountOrderByAggregateInput = {
    id?: SortOrder;
    titulo?: SortOrder;
    alt?: SortOrder;
    archivo?: SortOrder;
    activa?: SortOrder;
    orden?: SortOrder;
    creadoEn?: SortOrder;
    actualizadoEn?: SortOrder;
    ctaPrimarioHref?: SortOrder;
    ctaPrimarioTexto?: SortOrder;
    ctaSecundarioHref?: SortOrder;
    ctaSecundarioTexto?: SortOrder;
    descripcion?: SortOrder;
    etiqueta?: SortOrder;
    subtitulo?: SortOrder;
  };

  export type SliderAvgOrderByAggregateInput = {
    id?: SortOrder;
    orden?: SortOrder;
  };

  export type SliderMaxOrderByAggregateInput = {
    id?: SortOrder;
    titulo?: SortOrder;
    alt?: SortOrder;
    archivo?: SortOrder;
    activa?: SortOrder;
    orden?: SortOrder;
    creadoEn?: SortOrder;
    actualizadoEn?: SortOrder;
    ctaPrimarioHref?: SortOrder;
    ctaPrimarioTexto?: SortOrder;
    ctaSecundarioHref?: SortOrder;
    ctaSecundarioTexto?: SortOrder;
    descripcion?: SortOrder;
    etiqueta?: SortOrder;
    subtitulo?: SortOrder;
  };

  export type SliderMinOrderByAggregateInput = {
    id?: SortOrder;
    titulo?: SortOrder;
    alt?: SortOrder;
    archivo?: SortOrder;
    activa?: SortOrder;
    orden?: SortOrder;
    creadoEn?: SortOrder;
    actualizadoEn?: SortOrder;
    ctaPrimarioHref?: SortOrder;
    ctaPrimarioTexto?: SortOrder;
    ctaSecundarioHref?: SortOrder;
    ctaSecundarioTexto?: SortOrder;
    descripcion?: SortOrder;
    etiqueta?: SortOrder;
    subtitulo?: SortOrder;
  };

  export type SliderSumOrderByAggregateInput = {
    id?: SortOrder;
    orden?: SortOrder;
  };

  export type CursoNullableScalarRelationFilter = {
    is?: CursoWhereInput | null;
    isNot?: CursoWhereInput | null;
  };

  export type ProductoNullableScalarRelationFilter = {
    is?: ProductoWhereInput | null;
    isNot?: ProductoWhereInput | null;
  };

  export type ResenaOrderByRelevanceInput = {
    fields: ResenaOrderByRelevanceFieldEnum | ResenaOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type ResenaCursoIdUsuarioIdCompoundUniqueInput = {
    cursoId: number;
    usuarioId: number;
  };

  export type ResenaProductoIdUsuarioIdCompoundUniqueInput = {
    productoId: number;
    usuarioId: number;
  };

  export type ResenaCountOrderByAggregateInput = {
    id?: SortOrder;
    cursoId?: SortOrder;
    productoId?: SortOrder;
    usuarioId?: SortOrder;
    puntaje?: SortOrder;
    comentario?: SortOrder;
    creadoEn?: SortOrder;
  };

  export type ResenaAvgOrderByAggregateInput = {
    id?: SortOrder;
    cursoId?: SortOrder;
    productoId?: SortOrder;
    usuarioId?: SortOrder;
    puntaje?: SortOrder;
  };

  export type ResenaMaxOrderByAggregateInput = {
    id?: SortOrder;
    cursoId?: SortOrder;
    productoId?: SortOrder;
    usuarioId?: SortOrder;
    puntaje?: SortOrder;
    comentario?: SortOrder;
    creadoEn?: SortOrder;
  };

  export type ResenaMinOrderByAggregateInput = {
    id?: SortOrder;
    cursoId?: SortOrder;
    productoId?: SortOrder;
    usuarioId?: SortOrder;
    puntaje?: SortOrder;
    comentario?: SortOrder;
    creadoEn?: SortOrder;
  };

  export type ResenaSumOrderByAggregateInput = {
    id?: SortOrder;
    cursoId?: SortOrder;
    productoId?: SortOrder;
    usuarioId?: SortOrder;
    puntaje?: SortOrder;
  };

  export type EnumTipoLikeFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoLike | EnumTipoLikeFieldRefInput<$PrismaModel>;
    in?: $Enums.TipoLike[];
    notIn?: $Enums.TipoLike[];
    not?: NestedEnumTipoLikeFilter<$PrismaModel> | $Enums.TipoLike;
  };

  export type ResenaScalarRelationFilter = {
    is?: ResenaWhereInput;
    isNot?: ResenaWhereInput;
  };

  export type ResenaLikeResenaIdUsuarioIdCompoundUniqueInput = {
    resenaId: number;
    usuarioId: number;
  };

  export type ResenaLikeCountOrderByAggregateInput = {
    id?: SortOrder;
    resenaId?: SortOrder;
    usuarioId?: SortOrder;
    tipo?: SortOrder;
    creadoEn?: SortOrder;
  };

  export type ResenaLikeAvgOrderByAggregateInput = {
    id?: SortOrder;
    resenaId?: SortOrder;
    usuarioId?: SortOrder;
  };

  export type ResenaLikeMaxOrderByAggregateInput = {
    id?: SortOrder;
    resenaId?: SortOrder;
    usuarioId?: SortOrder;
    tipo?: SortOrder;
    creadoEn?: SortOrder;
  };

  export type ResenaLikeMinOrderByAggregateInput = {
    id?: SortOrder;
    resenaId?: SortOrder;
    usuarioId?: SortOrder;
    tipo?: SortOrder;
    creadoEn?: SortOrder;
  };

  export type ResenaLikeSumOrderByAggregateInput = {
    id?: SortOrder;
    resenaId?: SortOrder;
    usuarioId?: SortOrder;
  };

  export type EnumTipoLikeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoLike | EnumTipoLikeFieldRefInput<$PrismaModel>;
    in?: $Enums.TipoLike[];
    notIn?: $Enums.TipoLike[];
    not?:
      | NestedEnumTipoLikeWithAggregatesFilter<$PrismaModel>
      | $Enums.TipoLike;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumTipoLikeFilter<$PrismaModel>;
    _max?: NestedEnumTipoLikeFilter<$PrismaModel>;
  };

  export type ResenaRespuestaNullableScalarRelationFilter = {
    is?: ResenaRespuestaWhereInput | null;
    isNot?: ResenaRespuestaWhereInput | null;
  };

  export type ResenaRespuestaOrderByRelevanceInput = {
    fields:
      | ResenaRespuestaOrderByRelevanceFieldEnum
      | ResenaRespuestaOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type ResenaRespuestaCountOrderByAggregateInput = {
    id?: SortOrder;
    resenaId?: SortOrder;
    usuarioId?: SortOrder;
    parentId?: SortOrder;
    contenido?: SortOrder;
    eliminado?: SortOrder;
    creadoEn?: SortOrder;
    actualizadoEn?: SortOrder;
  };

  export type ResenaRespuestaAvgOrderByAggregateInput = {
    id?: SortOrder;
    resenaId?: SortOrder;
    usuarioId?: SortOrder;
    parentId?: SortOrder;
  };

  export type ResenaRespuestaMaxOrderByAggregateInput = {
    id?: SortOrder;
    resenaId?: SortOrder;
    usuarioId?: SortOrder;
    parentId?: SortOrder;
    contenido?: SortOrder;
    eliminado?: SortOrder;
    creadoEn?: SortOrder;
    actualizadoEn?: SortOrder;
  };

  export type ResenaRespuestaMinOrderByAggregateInput = {
    id?: SortOrder;
    resenaId?: SortOrder;
    usuarioId?: SortOrder;
    parentId?: SortOrder;
    contenido?: SortOrder;
    eliminado?: SortOrder;
    creadoEn?: SortOrder;
    actualizadoEn?: SortOrder;
  };

  export type ResenaRespuestaSumOrderByAggregateInput = {
    id?: SortOrder;
    resenaId?: SortOrder;
    usuarioId?: SortOrder;
    parentId?: SortOrder;
  };

  export type EnumTipoNotificacionFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.TipoNotificacion
      | EnumTipoNotificacionFieldRefInput<$PrismaModel>;
    in?: $Enums.TipoNotificacion[];
    notIn?: $Enums.TipoNotificacion[];
    not?:
      | NestedEnumTipoNotificacionFilter<$PrismaModel>
      | $Enums.TipoNotificacion;
  };

  export type NotificacionOrderByRelevanceInput = {
    fields:
      | NotificacionOrderByRelevanceFieldEnum
      | NotificacionOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type NotificacionCountOrderByAggregateInput = {
    id?: SortOrder;
    usuarioId?: SortOrder;
    tipo?: SortOrder;
    titulo?: SortOrder;
    mensaje?: SortOrder;
    leida?: SortOrder;
    url?: SortOrder;
    metadata?: SortOrder;
    creadoEn?: SortOrder;
  };

  export type NotificacionAvgOrderByAggregateInput = {
    id?: SortOrder;
    usuarioId?: SortOrder;
  };

  export type NotificacionMaxOrderByAggregateInput = {
    id?: SortOrder;
    usuarioId?: SortOrder;
    tipo?: SortOrder;
    titulo?: SortOrder;
    mensaje?: SortOrder;
    leida?: SortOrder;
    url?: SortOrder;
    creadoEn?: SortOrder;
  };

  export type NotificacionMinOrderByAggregateInput = {
    id?: SortOrder;
    usuarioId?: SortOrder;
    tipo?: SortOrder;
    titulo?: SortOrder;
    mensaje?: SortOrder;
    leida?: SortOrder;
    url?: SortOrder;
    creadoEn?: SortOrder;
  };

  export type NotificacionSumOrderByAggregateInput = {
    id?: SortOrder;
    usuarioId?: SortOrder;
  };

  export type EnumTipoNotificacionWithAggregatesFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.TipoNotificacion
      | EnumTipoNotificacionFieldRefInput<$PrismaModel>;
    in?: $Enums.TipoNotificacion[];
    notIn?: $Enums.TipoNotificacion[];
    not?:
      | NestedEnumTipoNotificacionWithAggregatesFilter<$PrismaModel>
      | $Enums.TipoNotificacion;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumTipoNotificacionFilter<$PrismaModel>;
    _max?: NestedEnumTipoNotificacionFilter<$PrismaModel>;
  };

  export type PreferenciasNotificacionCountOrderByAggregateInput = {
    id?: SortOrder;
    usuarioId?: SortOrder;
    nuevaResena?: SortOrder;
    respuestaResena?: SortOrder;
    actualizacionesSistema?: SortOrder;
    mantenimiento?: SortOrder;
    reporteContenido?: SortOrder;
    contenidoPendiente?: SortOrder;
    resumenDiario?: SortOrder;
    notificacionesInstantaneas?: SortOrder;
    creadoEn?: SortOrder;
    actualizadoEn?: SortOrder;
  };

  export type PreferenciasNotificacionAvgOrderByAggregateInput = {
    id?: SortOrder;
    usuarioId?: SortOrder;
  };

  export type PreferenciasNotificacionMaxOrderByAggregateInput = {
    id?: SortOrder;
    usuarioId?: SortOrder;
    nuevaResena?: SortOrder;
    respuestaResena?: SortOrder;
    actualizacionesSistema?: SortOrder;
    mantenimiento?: SortOrder;
    reporteContenido?: SortOrder;
    contenidoPendiente?: SortOrder;
    resumenDiario?: SortOrder;
    notificacionesInstantaneas?: SortOrder;
    creadoEn?: SortOrder;
    actualizadoEn?: SortOrder;
  };

  export type PreferenciasNotificacionMinOrderByAggregateInput = {
    id?: SortOrder;
    usuarioId?: SortOrder;
    nuevaResena?: SortOrder;
    respuestaResena?: SortOrder;
    actualizacionesSistema?: SortOrder;
    mantenimiento?: SortOrder;
    reporteContenido?: SortOrder;
    contenidoPendiente?: SortOrder;
    resumenDiario?: SortOrder;
    notificacionesInstantaneas?: SortOrder;
    creadoEn?: SortOrder;
    actualizadoEn?: SortOrder;
  };

  export type PreferenciasNotificacionSumOrderByAggregateInput = {
    id?: SortOrder;
    usuarioId?: SortOrder;
  };

  export type ResenaBorradorOrderByRelevanceInput = {
    fields:
      | ResenaBorradorOrderByRelevanceFieldEnum
      | ResenaBorradorOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type ResenaBorradorCursoIdUsuarioIdCompoundUniqueInput = {
    cursoId: number;
    usuarioId: number;
  };

  export type ResenaBorradorProductoIdUsuarioIdCompoundUniqueInput = {
    productoId: number;
    usuarioId: number;
  };

  export type ResenaBorradorCountOrderByAggregateInput = {
    id?: SortOrder;
    usuarioId?: SortOrder;
    cursoId?: SortOrder;
    productoId?: SortOrder;
    puntaje?: SortOrder;
    comentario?: SortOrder;
    creadoEn?: SortOrder;
    actualizadoEn?: SortOrder;
  };

  export type ResenaBorradorAvgOrderByAggregateInput = {
    id?: SortOrder;
    usuarioId?: SortOrder;
    cursoId?: SortOrder;
    productoId?: SortOrder;
    puntaje?: SortOrder;
  };

  export type ResenaBorradorMaxOrderByAggregateInput = {
    id?: SortOrder;
    usuarioId?: SortOrder;
    cursoId?: SortOrder;
    productoId?: SortOrder;
    puntaje?: SortOrder;
    comentario?: SortOrder;
    creadoEn?: SortOrder;
    actualizadoEn?: SortOrder;
  };

  export type ResenaBorradorMinOrderByAggregateInput = {
    id?: SortOrder;
    usuarioId?: SortOrder;
    cursoId?: SortOrder;
    productoId?: SortOrder;
    puntaje?: SortOrder;
    comentario?: SortOrder;
    creadoEn?: SortOrder;
    actualizadoEn?: SortOrder;
  };

  export type ResenaBorradorSumOrderByAggregateInput = {
    id?: SortOrder;
    usuarioId?: SortOrder;
    cursoId?: SortOrder;
    productoId?: SortOrder;
    puntaje?: SortOrder;
  };

  export type AuditLogOrderByRelevanceInput = {
    fields:
      | AuditLogOrderByRelevanceFieldEnum
      | AuditLogOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder;
    tableName?: SortOrder;
    recordId?: SortOrder;
    action?: SortOrder;
    oldData?: SortOrder;
    newData?: SortOrder;
    userId?: SortOrder;
    userAgent?: SortOrder;
    ipAddress?: SortOrder;
    endpoint?: SortOrder;
    timestamp?: SortOrder;
  };

  export type AuditLogAvgOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
  };

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder;
    tableName?: SortOrder;
    recordId?: SortOrder;
    action?: SortOrder;
    userId?: SortOrder;
    userAgent?: SortOrder;
    ipAddress?: SortOrder;
    endpoint?: SortOrder;
    timestamp?: SortOrder;
  };

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder;
    tableName?: SortOrder;
    recordId?: SortOrder;
    action?: SortOrder;
    userId?: SortOrder;
    userAgent?: SortOrder;
    ipAddress?: SortOrder;
    endpoint?: SortOrder;
    timestamp?: SortOrder;
  };

  export type AuditLogSumOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
  };

  export type CarritoCountOrderByAggregateInput = {
    id?: SortOrder;
    usuarioId?: SortOrder;
    creadoEn?: SortOrder;
    actualizadoEn?: SortOrder;
  };

  export type CarritoAvgOrderByAggregateInput = {
    id?: SortOrder;
    usuarioId?: SortOrder;
  };

  export type CarritoMaxOrderByAggregateInput = {
    id?: SortOrder;
    usuarioId?: SortOrder;
    creadoEn?: SortOrder;
    actualizadoEn?: SortOrder;
  };

  export type CarritoMinOrderByAggregateInput = {
    id?: SortOrder;
    usuarioId?: SortOrder;
    creadoEn?: SortOrder;
    actualizadoEn?: SortOrder;
  };

  export type CarritoSumOrderByAggregateInput = {
    id?: SortOrder;
    usuarioId?: SortOrder;
  };

  export type CarritoScalarRelationFilter = {
    is?: CarritoWhereInput;
    isNot?: CarritoWhereInput;
  };

  export type ItemCarritoCarritoIdTipoProductoIdCursoIdCompoundUniqueInput = {
    carritoId: number;
    tipo: $Enums.TipoItemOrden;
    productoId: number;
    cursoId: number;
  };

  export type ItemCarritoCountOrderByAggregateInput = {
    id?: SortOrder;
    carritoId?: SortOrder;
    tipo?: SortOrder;
    productoId?: SortOrder;
    cursoId?: SortOrder;
    cantidad?: SortOrder;
    creadoEn?: SortOrder;
  };

  export type ItemCarritoAvgOrderByAggregateInput = {
    id?: SortOrder;
    carritoId?: SortOrder;
    productoId?: SortOrder;
    cursoId?: SortOrder;
    cantidad?: SortOrder;
  };

  export type ItemCarritoMaxOrderByAggregateInput = {
    id?: SortOrder;
    carritoId?: SortOrder;
    tipo?: SortOrder;
    productoId?: SortOrder;
    cursoId?: SortOrder;
    cantidad?: SortOrder;
    creadoEn?: SortOrder;
  };

  export type ItemCarritoMinOrderByAggregateInput = {
    id?: SortOrder;
    carritoId?: SortOrder;
    tipo?: SortOrder;
    productoId?: SortOrder;
    cursoId?: SortOrder;
    cantidad?: SortOrder;
    creadoEn?: SortOrder;
  };

  export type ItemCarritoSumOrderByAggregateInput = {
    id?: SortOrder;
    carritoId?: SortOrder;
    productoId?: SortOrder;
    cursoId?: SortOrder;
    cantidad?: SortOrder;
  };

  export type UsuarioRolCreateNestedManyWithoutUsuarioInput = {
    create?:
      | XOR<
          UsuarioRolCreateWithoutUsuarioInput,
          UsuarioRolUncheckedCreateWithoutUsuarioInput
        >
      | UsuarioRolCreateWithoutUsuarioInput[]
      | UsuarioRolUncheckedCreateWithoutUsuarioInput[];
    connectOrCreate?:
      | UsuarioRolCreateOrConnectWithoutUsuarioInput
      | UsuarioRolCreateOrConnectWithoutUsuarioInput[];
    createMany?: UsuarioRolCreateManyUsuarioInputEnvelope;
    connect?: UsuarioRolWhereUniqueInput | UsuarioRolWhereUniqueInput[];
  };

  export type CursoCreateNestedManyWithoutInstructorInput = {
    create?:
      | XOR<
          CursoCreateWithoutInstructorInput,
          CursoUncheckedCreateWithoutInstructorInput
        >
      | CursoCreateWithoutInstructorInput[]
      | CursoUncheckedCreateWithoutInstructorInput[];
    connectOrCreate?:
      | CursoCreateOrConnectWithoutInstructorInput
      | CursoCreateOrConnectWithoutInstructorInput[];
    createMany?: CursoCreateManyInstructorInputEnvelope;
    connect?: CursoWhereUniqueInput | CursoWhereUniqueInput[];
  };

  export type InscripcionCreateNestedManyWithoutUsuarioInput = {
    create?:
      | XOR<
          InscripcionCreateWithoutUsuarioInput,
          InscripcionUncheckedCreateWithoutUsuarioInput
        >
      | InscripcionCreateWithoutUsuarioInput[]
      | InscripcionUncheckedCreateWithoutUsuarioInput[];
    connectOrCreate?:
      | InscripcionCreateOrConnectWithoutUsuarioInput
      | InscripcionCreateOrConnectWithoutUsuarioInput[];
    createMany?: InscripcionCreateManyUsuarioInputEnvelope;
    connect?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[];
  };

  export type ResenaCreateNestedManyWithoutUsuarioInput = {
    create?:
      | XOR<
          ResenaCreateWithoutUsuarioInput,
          ResenaUncheckedCreateWithoutUsuarioInput
        >
      | ResenaCreateWithoutUsuarioInput[]
      | ResenaUncheckedCreateWithoutUsuarioInput[];
    connectOrCreate?:
      | ResenaCreateOrConnectWithoutUsuarioInput
      | ResenaCreateOrConnectWithoutUsuarioInput[];
    createMany?: ResenaCreateManyUsuarioInputEnvelope;
    connect?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[];
  };

  export type ResenaRespuestaCreateNestedManyWithoutUsuarioInput = {
    create?:
      | XOR<
          ResenaRespuestaCreateWithoutUsuarioInput,
          ResenaRespuestaUncheckedCreateWithoutUsuarioInput
        >
      | ResenaRespuestaCreateWithoutUsuarioInput[]
      | ResenaRespuestaUncheckedCreateWithoutUsuarioInput[];
    connectOrCreate?:
      | ResenaRespuestaCreateOrConnectWithoutUsuarioInput
      | ResenaRespuestaCreateOrConnectWithoutUsuarioInput[];
    createMany?: ResenaRespuestaCreateManyUsuarioInputEnvelope;
    connect?:
      | ResenaRespuestaWhereUniqueInput
      | ResenaRespuestaWhereUniqueInput[];
  };

  export type FavoritoCreateNestedManyWithoutUsuarioInput = {
    create?:
      | XOR<
          FavoritoCreateWithoutUsuarioInput,
          FavoritoUncheckedCreateWithoutUsuarioInput
        >
      | FavoritoCreateWithoutUsuarioInput[]
      | FavoritoUncheckedCreateWithoutUsuarioInput[];
    connectOrCreate?:
      | FavoritoCreateOrConnectWithoutUsuarioInput
      | FavoritoCreateOrConnectWithoutUsuarioInput[];
    createMany?: FavoritoCreateManyUsuarioInputEnvelope;
    connect?: FavoritoWhereUniqueInput | FavoritoWhereUniqueInput[];
  };

  export type ResenaLikeCreateNestedManyWithoutUsuarioInput = {
    create?:
      | XOR<
          ResenaLikeCreateWithoutUsuarioInput,
          ResenaLikeUncheckedCreateWithoutUsuarioInput
        >
      | ResenaLikeCreateWithoutUsuarioInput[]
      | ResenaLikeUncheckedCreateWithoutUsuarioInput[];
    connectOrCreate?:
      | ResenaLikeCreateOrConnectWithoutUsuarioInput
      | ResenaLikeCreateOrConnectWithoutUsuarioInput[];
    createMany?: ResenaLikeCreateManyUsuarioInputEnvelope;
    connect?: ResenaLikeWhereUniqueInput | ResenaLikeWhereUniqueInput[];
  };

  export type OrdenCreateNestedManyWithoutUsuarioInput = {
    create?:
      | XOR<
          OrdenCreateWithoutUsuarioInput,
          OrdenUncheckedCreateWithoutUsuarioInput
        >
      | OrdenCreateWithoutUsuarioInput[]
      | OrdenUncheckedCreateWithoutUsuarioInput[];
    connectOrCreate?:
      | OrdenCreateOrConnectWithoutUsuarioInput
      | OrdenCreateOrConnectWithoutUsuarioInput[];
    createMany?: OrdenCreateManyUsuarioInputEnvelope;
    connect?: OrdenWhereUniqueInput | OrdenWhereUniqueInput[];
  };

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          AuditLogCreateWithoutUserInput,
          AuditLogUncheckedCreateWithoutUserInput
        >
      | AuditLogCreateWithoutUserInput[]
      | AuditLogUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AuditLogCreateOrConnectWithoutUserInput
      | AuditLogCreateOrConnectWithoutUserInput[];
    createMany?: AuditLogCreateManyUserInputEnvelope;
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
  };

  export type CarritoCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<
      CarritoCreateWithoutUsuarioInput,
      CarritoUncheckedCreateWithoutUsuarioInput
    >;
    connectOrCreate?: CarritoCreateOrConnectWithoutUsuarioInput;
    connect?: CarritoWhereUniqueInput;
  };

  export type NotificacionCreateNestedManyWithoutUsuarioInput = {
    create?:
      | XOR<
          NotificacionCreateWithoutUsuarioInput,
          NotificacionUncheckedCreateWithoutUsuarioInput
        >
      | NotificacionCreateWithoutUsuarioInput[]
      | NotificacionUncheckedCreateWithoutUsuarioInput[];
    connectOrCreate?:
      | NotificacionCreateOrConnectWithoutUsuarioInput
      | NotificacionCreateOrConnectWithoutUsuarioInput[];
    createMany?: NotificacionCreateManyUsuarioInputEnvelope;
    connect?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[];
  };

  export type UsuarioRolUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?:
      | XOR<
          UsuarioRolCreateWithoutUsuarioInput,
          UsuarioRolUncheckedCreateWithoutUsuarioInput
        >
      | UsuarioRolCreateWithoutUsuarioInput[]
      | UsuarioRolUncheckedCreateWithoutUsuarioInput[];
    connectOrCreate?:
      | UsuarioRolCreateOrConnectWithoutUsuarioInput
      | UsuarioRolCreateOrConnectWithoutUsuarioInput[];
    createMany?: UsuarioRolCreateManyUsuarioInputEnvelope;
    connect?: UsuarioRolWhereUniqueInput | UsuarioRolWhereUniqueInput[];
  };

  export type CursoUncheckedCreateNestedManyWithoutInstructorInput = {
    create?:
      | XOR<
          CursoCreateWithoutInstructorInput,
          CursoUncheckedCreateWithoutInstructorInput
        >
      | CursoCreateWithoutInstructorInput[]
      | CursoUncheckedCreateWithoutInstructorInput[];
    connectOrCreate?:
      | CursoCreateOrConnectWithoutInstructorInput
      | CursoCreateOrConnectWithoutInstructorInput[];
    createMany?: CursoCreateManyInstructorInputEnvelope;
    connect?: CursoWhereUniqueInput | CursoWhereUniqueInput[];
  };

  export type InscripcionUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?:
      | XOR<
          InscripcionCreateWithoutUsuarioInput,
          InscripcionUncheckedCreateWithoutUsuarioInput
        >
      | InscripcionCreateWithoutUsuarioInput[]
      | InscripcionUncheckedCreateWithoutUsuarioInput[];
    connectOrCreate?:
      | InscripcionCreateOrConnectWithoutUsuarioInput
      | InscripcionCreateOrConnectWithoutUsuarioInput[];
    createMany?: InscripcionCreateManyUsuarioInputEnvelope;
    connect?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[];
  };

  export type ResenaUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?:
      | XOR<
          ResenaCreateWithoutUsuarioInput,
          ResenaUncheckedCreateWithoutUsuarioInput
        >
      | ResenaCreateWithoutUsuarioInput[]
      | ResenaUncheckedCreateWithoutUsuarioInput[];
    connectOrCreate?:
      | ResenaCreateOrConnectWithoutUsuarioInput
      | ResenaCreateOrConnectWithoutUsuarioInput[];
    createMany?: ResenaCreateManyUsuarioInputEnvelope;
    connect?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[];
  };

  export type ResenaRespuestaUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?:
      | XOR<
          ResenaRespuestaCreateWithoutUsuarioInput,
          ResenaRespuestaUncheckedCreateWithoutUsuarioInput
        >
      | ResenaRespuestaCreateWithoutUsuarioInput[]
      | ResenaRespuestaUncheckedCreateWithoutUsuarioInput[];
    connectOrCreate?:
      | ResenaRespuestaCreateOrConnectWithoutUsuarioInput
      | ResenaRespuestaCreateOrConnectWithoutUsuarioInput[];
    createMany?: ResenaRespuestaCreateManyUsuarioInputEnvelope;
    connect?:
      | ResenaRespuestaWhereUniqueInput
      | ResenaRespuestaWhereUniqueInput[];
  };

  export type FavoritoUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?:
      | XOR<
          FavoritoCreateWithoutUsuarioInput,
          FavoritoUncheckedCreateWithoutUsuarioInput
        >
      | FavoritoCreateWithoutUsuarioInput[]
      | FavoritoUncheckedCreateWithoutUsuarioInput[];
    connectOrCreate?:
      | FavoritoCreateOrConnectWithoutUsuarioInput
      | FavoritoCreateOrConnectWithoutUsuarioInput[];
    createMany?: FavoritoCreateManyUsuarioInputEnvelope;
    connect?: FavoritoWhereUniqueInput | FavoritoWhereUniqueInput[];
  };

  export type ResenaLikeUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?:
      | XOR<
          ResenaLikeCreateWithoutUsuarioInput,
          ResenaLikeUncheckedCreateWithoutUsuarioInput
        >
      | ResenaLikeCreateWithoutUsuarioInput[]
      | ResenaLikeUncheckedCreateWithoutUsuarioInput[];
    connectOrCreate?:
      | ResenaLikeCreateOrConnectWithoutUsuarioInput
      | ResenaLikeCreateOrConnectWithoutUsuarioInput[];
    createMany?: ResenaLikeCreateManyUsuarioInputEnvelope;
    connect?: ResenaLikeWhereUniqueInput | ResenaLikeWhereUniqueInput[];
  };

  export type OrdenUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?:
      | XOR<
          OrdenCreateWithoutUsuarioInput,
          OrdenUncheckedCreateWithoutUsuarioInput
        >
      | OrdenCreateWithoutUsuarioInput[]
      | OrdenUncheckedCreateWithoutUsuarioInput[];
    connectOrCreate?:
      | OrdenCreateOrConnectWithoutUsuarioInput
      | OrdenCreateOrConnectWithoutUsuarioInput[];
    createMany?: OrdenCreateManyUsuarioInputEnvelope;
    connect?: OrdenWhereUniqueInput | OrdenWhereUniqueInput[];
  };

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          AuditLogCreateWithoutUserInput,
          AuditLogUncheckedCreateWithoutUserInput
        >
      | AuditLogCreateWithoutUserInput[]
      | AuditLogUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AuditLogCreateOrConnectWithoutUserInput
      | AuditLogCreateOrConnectWithoutUserInput[];
    createMany?: AuditLogCreateManyUserInputEnvelope;
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
  };

  export type CarritoUncheckedCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<
      CarritoCreateWithoutUsuarioInput,
      CarritoUncheckedCreateWithoutUsuarioInput
    >;
    connectOrCreate?: CarritoCreateOrConnectWithoutUsuarioInput;
    connect?: CarritoWhereUniqueInput;
  };

  export type NotificacionUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?:
      | XOR<
          NotificacionCreateWithoutUsuarioInput,
          NotificacionUncheckedCreateWithoutUsuarioInput
        >
      | NotificacionCreateWithoutUsuarioInput[]
      | NotificacionUncheckedCreateWithoutUsuarioInput[];
    connectOrCreate?:
      | NotificacionCreateOrConnectWithoutUsuarioInput
      | NotificacionCreateOrConnectWithoutUsuarioInput[];
    createMany?: NotificacionCreateManyUsuarioInputEnvelope;
    connect?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[];
  };

  export type StringFieldUpdateOperationsInput = {
    set?: string;
  };

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null;
  };

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string;
  };

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null;
  };

  export type UsuarioRolUpdateManyWithoutUsuarioNestedInput = {
    create?:
      | XOR<
          UsuarioRolCreateWithoutUsuarioInput,
          UsuarioRolUncheckedCreateWithoutUsuarioInput
        >
      | UsuarioRolCreateWithoutUsuarioInput[]
      | UsuarioRolUncheckedCreateWithoutUsuarioInput[];
    connectOrCreate?:
      | UsuarioRolCreateOrConnectWithoutUsuarioInput
      | UsuarioRolCreateOrConnectWithoutUsuarioInput[];
    upsert?:
      | UsuarioRolUpsertWithWhereUniqueWithoutUsuarioInput
      | UsuarioRolUpsertWithWhereUniqueWithoutUsuarioInput[];
    createMany?: UsuarioRolCreateManyUsuarioInputEnvelope;
    set?: UsuarioRolWhereUniqueInput | UsuarioRolWhereUniqueInput[];
    disconnect?: UsuarioRolWhereUniqueInput | UsuarioRolWhereUniqueInput[];
    delete?: UsuarioRolWhereUniqueInput | UsuarioRolWhereUniqueInput[];
    connect?: UsuarioRolWhereUniqueInput | UsuarioRolWhereUniqueInput[];
    update?:
      | UsuarioRolUpdateWithWhereUniqueWithoutUsuarioInput
      | UsuarioRolUpdateWithWhereUniqueWithoutUsuarioInput[];
    updateMany?:
      | UsuarioRolUpdateManyWithWhereWithoutUsuarioInput
      | UsuarioRolUpdateManyWithWhereWithoutUsuarioInput[];
    deleteMany?: UsuarioRolScalarWhereInput | UsuarioRolScalarWhereInput[];
  };

  export type CursoUpdateManyWithoutInstructorNestedInput = {
    create?:
      | XOR<
          CursoCreateWithoutInstructorInput,
          CursoUncheckedCreateWithoutInstructorInput
        >
      | CursoCreateWithoutInstructorInput[]
      | CursoUncheckedCreateWithoutInstructorInput[];
    connectOrCreate?:
      | CursoCreateOrConnectWithoutInstructorInput
      | CursoCreateOrConnectWithoutInstructorInput[];
    upsert?:
      | CursoUpsertWithWhereUniqueWithoutInstructorInput
      | CursoUpsertWithWhereUniqueWithoutInstructorInput[];
    createMany?: CursoCreateManyInstructorInputEnvelope;
    set?: CursoWhereUniqueInput | CursoWhereUniqueInput[];
    disconnect?: CursoWhereUniqueInput | CursoWhereUniqueInput[];
    delete?: CursoWhereUniqueInput | CursoWhereUniqueInput[];
    connect?: CursoWhereUniqueInput | CursoWhereUniqueInput[];
    update?:
      | CursoUpdateWithWhereUniqueWithoutInstructorInput
      | CursoUpdateWithWhereUniqueWithoutInstructorInput[];
    updateMany?:
      | CursoUpdateManyWithWhereWithoutInstructorInput
      | CursoUpdateManyWithWhereWithoutInstructorInput[];
    deleteMany?: CursoScalarWhereInput | CursoScalarWhereInput[];
  };

  export type InscripcionUpdateManyWithoutUsuarioNestedInput = {
    create?:
      | XOR<
          InscripcionCreateWithoutUsuarioInput,
          InscripcionUncheckedCreateWithoutUsuarioInput
        >
      | InscripcionCreateWithoutUsuarioInput[]
      | InscripcionUncheckedCreateWithoutUsuarioInput[];
    connectOrCreate?:
      | InscripcionCreateOrConnectWithoutUsuarioInput
      | InscripcionCreateOrConnectWithoutUsuarioInput[];
    upsert?:
      | InscripcionUpsertWithWhereUniqueWithoutUsuarioInput
      | InscripcionUpsertWithWhereUniqueWithoutUsuarioInput[];
    createMany?: InscripcionCreateManyUsuarioInputEnvelope;
    set?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[];
    disconnect?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[];
    delete?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[];
    connect?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[];
    update?:
      | InscripcionUpdateWithWhereUniqueWithoutUsuarioInput
      | InscripcionUpdateWithWhereUniqueWithoutUsuarioInput[];
    updateMany?:
      | InscripcionUpdateManyWithWhereWithoutUsuarioInput
      | InscripcionUpdateManyWithWhereWithoutUsuarioInput[];
    deleteMany?: InscripcionScalarWhereInput | InscripcionScalarWhereInput[];
  };

  export type ResenaUpdateManyWithoutUsuarioNestedInput = {
    create?:
      | XOR<
          ResenaCreateWithoutUsuarioInput,
          ResenaUncheckedCreateWithoutUsuarioInput
        >
      | ResenaCreateWithoutUsuarioInput[]
      | ResenaUncheckedCreateWithoutUsuarioInput[];
    connectOrCreate?:
      | ResenaCreateOrConnectWithoutUsuarioInput
      | ResenaCreateOrConnectWithoutUsuarioInput[];
    upsert?:
      | ResenaUpsertWithWhereUniqueWithoutUsuarioInput
      | ResenaUpsertWithWhereUniqueWithoutUsuarioInput[];
    createMany?: ResenaCreateManyUsuarioInputEnvelope;
    set?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[];
    disconnect?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[];
    delete?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[];
    connect?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[];
    update?:
      | ResenaUpdateWithWhereUniqueWithoutUsuarioInput
      | ResenaUpdateWithWhereUniqueWithoutUsuarioInput[];
    updateMany?:
      | ResenaUpdateManyWithWhereWithoutUsuarioInput
      | ResenaUpdateManyWithWhereWithoutUsuarioInput[];
    deleteMany?: ResenaScalarWhereInput | ResenaScalarWhereInput[];
  };

  export type ResenaRespuestaUpdateManyWithoutUsuarioNestedInput = {
    create?:
      | XOR<
          ResenaRespuestaCreateWithoutUsuarioInput,
          ResenaRespuestaUncheckedCreateWithoutUsuarioInput
        >
      | ResenaRespuestaCreateWithoutUsuarioInput[]
      | ResenaRespuestaUncheckedCreateWithoutUsuarioInput[];
    connectOrCreate?:
      | ResenaRespuestaCreateOrConnectWithoutUsuarioInput
      | ResenaRespuestaCreateOrConnectWithoutUsuarioInput[];
    upsert?:
      | ResenaRespuestaUpsertWithWhereUniqueWithoutUsuarioInput
      | ResenaRespuestaUpsertWithWhereUniqueWithoutUsuarioInput[];
    createMany?: ResenaRespuestaCreateManyUsuarioInputEnvelope;
    set?: ResenaRespuestaWhereUniqueInput | ResenaRespuestaWhereUniqueInput[];
    disconnect?:
      | ResenaRespuestaWhereUniqueInput
      | ResenaRespuestaWhereUniqueInput[];
    delete?:
      | ResenaRespuestaWhereUniqueInput
      | ResenaRespuestaWhereUniqueInput[];
    connect?:
      | ResenaRespuestaWhereUniqueInput
      | ResenaRespuestaWhereUniqueInput[];
    update?:
      | ResenaRespuestaUpdateWithWhereUniqueWithoutUsuarioInput
      | ResenaRespuestaUpdateWithWhereUniqueWithoutUsuarioInput[];
    updateMany?:
      | ResenaRespuestaUpdateManyWithWhereWithoutUsuarioInput
      | ResenaRespuestaUpdateManyWithWhereWithoutUsuarioInput[];
    deleteMany?:
      | ResenaRespuestaScalarWhereInput
      | ResenaRespuestaScalarWhereInput[];
  };

  export type FavoritoUpdateManyWithoutUsuarioNestedInput = {
    create?:
      | XOR<
          FavoritoCreateWithoutUsuarioInput,
          FavoritoUncheckedCreateWithoutUsuarioInput
        >
      | FavoritoCreateWithoutUsuarioInput[]
      | FavoritoUncheckedCreateWithoutUsuarioInput[];
    connectOrCreate?:
      | FavoritoCreateOrConnectWithoutUsuarioInput
      | FavoritoCreateOrConnectWithoutUsuarioInput[];
    upsert?:
      | FavoritoUpsertWithWhereUniqueWithoutUsuarioInput
      | FavoritoUpsertWithWhereUniqueWithoutUsuarioInput[];
    createMany?: FavoritoCreateManyUsuarioInputEnvelope;
    set?: FavoritoWhereUniqueInput | FavoritoWhereUniqueInput[];
    disconnect?: FavoritoWhereUniqueInput | FavoritoWhereUniqueInput[];
    delete?: FavoritoWhereUniqueInput | FavoritoWhereUniqueInput[];
    connect?: FavoritoWhereUniqueInput | FavoritoWhereUniqueInput[];
    update?:
      | FavoritoUpdateWithWhereUniqueWithoutUsuarioInput
      | FavoritoUpdateWithWhereUniqueWithoutUsuarioInput[];
    updateMany?:
      | FavoritoUpdateManyWithWhereWithoutUsuarioInput
      | FavoritoUpdateManyWithWhereWithoutUsuarioInput[];
    deleteMany?: FavoritoScalarWhereInput | FavoritoScalarWhereInput[];
  };

  export type ResenaLikeUpdateManyWithoutUsuarioNestedInput = {
    create?:
      | XOR<
          ResenaLikeCreateWithoutUsuarioInput,
          ResenaLikeUncheckedCreateWithoutUsuarioInput
        >
      | ResenaLikeCreateWithoutUsuarioInput[]
      | ResenaLikeUncheckedCreateWithoutUsuarioInput[];
    connectOrCreate?:
      | ResenaLikeCreateOrConnectWithoutUsuarioInput
      | ResenaLikeCreateOrConnectWithoutUsuarioInput[];
    upsert?:
      | ResenaLikeUpsertWithWhereUniqueWithoutUsuarioInput
      | ResenaLikeUpsertWithWhereUniqueWithoutUsuarioInput[];
    createMany?: ResenaLikeCreateManyUsuarioInputEnvelope;
    set?: ResenaLikeWhereUniqueInput | ResenaLikeWhereUniqueInput[];
    disconnect?: ResenaLikeWhereUniqueInput | ResenaLikeWhereUniqueInput[];
    delete?: ResenaLikeWhereUniqueInput | ResenaLikeWhereUniqueInput[];
    connect?: ResenaLikeWhereUniqueInput | ResenaLikeWhereUniqueInput[];
    update?:
      | ResenaLikeUpdateWithWhereUniqueWithoutUsuarioInput
      | ResenaLikeUpdateWithWhereUniqueWithoutUsuarioInput[];
    updateMany?:
      | ResenaLikeUpdateManyWithWhereWithoutUsuarioInput
      | ResenaLikeUpdateManyWithWhereWithoutUsuarioInput[];
    deleteMany?: ResenaLikeScalarWhereInput | ResenaLikeScalarWhereInput[];
  };

  export type OrdenUpdateManyWithoutUsuarioNestedInput = {
    create?:
      | XOR<
          OrdenCreateWithoutUsuarioInput,
          OrdenUncheckedCreateWithoutUsuarioInput
        >
      | OrdenCreateWithoutUsuarioInput[]
      | OrdenUncheckedCreateWithoutUsuarioInput[];
    connectOrCreate?:
      | OrdenCreateOrConnectWithoutUsuarioInput
      | OrdenCreateOrConnectWithoutUsuarioInput[];
    upsert?:
      | OrdenUpsertWithWhereUniqueWithoutUsuarioInput
      | OrdenUpsertWithWhereUniqueWithoutUsuarioInput[];
    createMany?: OrdenCreateManyUsuarioInputEnvelope;
    set?: OrdenWhereUniqueInput | OrdenWhereUniqueInput[];
    disconnect?: OrdenWhereUniqueInput | OrdenWhereUniqueInput[];
    delete?: OrdenWhereUniqueInput | OrdenWhereUniqueInput[];
    connect?: OrdenWhereUniqueInput | OrdenWhereUniqueInput[];
    update?:
      | OrdenUpdateWithWhereUniqueWithoutUsuarioInput
      | OrdenUpdateWithWhereUniqueWithoutUsuarioInput[];
    updateMany?:
      | OrdenUpdateManyWithWhereWithoutUsuarioInput
      | OrdenUpdateManyWithWhereWithoutUsuarioInput[];
    deleteMany?: OrdenScalarWhereInput | OrdenScalarWhereInput[];
  };

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          AuditLogCreateWithoutUserInput,
          AuditLogUncheckedCreateWithoutUserInput
        >
      | AuditLogCreateWithoutUserInput[]
      | AuditLogUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AuditLogCreateOrConnectWithoutUserInput
      | AuditLogCreateOrConnectWithoutUserInput[];
    upsert?:
      | AuditLogUpsertWithWhereUniqueWithoutUserInput
      | AuditLogUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: AuditLogCreateManyUserInputEnvelope;
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    update?:
      | AuditLogUpdateWithWhereUniqueWithoutUserInput
      | AuditLogUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | AuditLogUpdateManyWithWhereWithoutUserInput
      | AuditLogUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[];
  };

  export type CarritoUpdateOneWithoutUsuarioNestedInput = {
    create?: XOR<
      CarritoCreateWithoutUsuarioInput,
      CarritoUncheckedCreateWithoutUsuarioInput
    >;
    connectOrCreate?: CarritoCreateOrConnectWithoutUsuarioInput;
    upsert?: CarritoUpsertWithoutUsuarioInput;
    disconnect?: CarritoWhereInput | boolean;
    delete?: CarritoWhereInput | boolean;
    connect?: CarritoWhereUniqueInput;
    update?: XOR<
      XOR<
        CarritoUpdateToOneWithWhereWithoutUsuarioInput,
        CarritoUpdateWithoutUsuarioInput
      >,
      CarritoUncheckedUpdateWithoutUsuarioInput
    >;
  };

  export type NotificacionUpdateManyWithoutUsuarioNestedInput = {
    create?:
      | XOR<
          NotificacionCreateWithoutUsuarioInput,
          NotificacionUncheckedCreateWithoutUsuarioInput
        >
      | NotificacionCreateWithoutUsuarioInput[]
      | NotificacionUncheckedCreateWithoutUsuarioInput[];
    connectOrCreate?:
      | NotificacionCreateOrConnectWithoutUsuarioInput
      | NotificacionCreateOrConnectWithoutUsuarioInput[];
    upsert?:
      | NotificacionUpsertWithWhereUniqueWithoutUsuarioInput
      | NotificacionUpsertWithWhereUniqueWithoutUsuarioInput[];
    createMany?: NotificacionCreateManyUsuarioInputEnvelope;
    set?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[];
    disconnect?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[];
    delete?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[];
    connect?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[];
    update?:
      | NotificacionUpdateWithWhereUniqueWithoutUsuarioInput
      | NotificacionUpdateWithWhereUniqueWithoutUsuarioInput[];
    updateMany?:
      | NotificacionUpdateManyWithWhereWithoutUsuarioInput
      | NotificacionUpdateManyWithWhereWithoutUsuarioInput[];
    deleteMany?: NotificacionScalarWhereInput | NotificacionScalarWhereInput[];
  };

  export type IntFieldUpdateOperationsInput = {
    set?: number;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type UsuarioRolUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?:
      | XOR<
          UsuarioRolCreateWithoutUsuarioInput,
          UsuarioRolUncheckedCreateWithoutUsuarioInput
        >
      | UsuarioRolCreateWithoutUsuarioInput[]
      | UsuarioRolUncheckedCreateWithoutUsuarioInput[];
    connectOrCreate?:
      | UsuarioRolCreateOrConnectWithoutUsuarioInput
      | UsuarioRolCreateOrConnectWithoutUsuarioInput[];
    upsert?:
      | UsuarioRolUpsertWithWhereUniqueWithoutUsuarioInput
      | UsuarioRolUpsertWithWhereUniqueWithoutUsuarioInput[];
    createMany?: UsuarioRolCreateManyUsuarioInputEnvelope;
    set?: UsuarioRolWhereUniqueInput | UsuarioRolWhereUniqueInput[];
    disconnect?: UsuarioRolWhereUniqueInput | UsuarioRolWhereUniqueInput[];
    delete?: UsuarioRolWhereUniqueInput | UsuarioRolWhereUniqueInput[];
    connect?: UsuarioRolWhereUniqueInput | UsuarioRolWhereUniqueInput[];
    update?:
      | UsuarioRolUpdateWithWhereUniqueWithoutUsuarioInput
      | UsuarioRolUpdateWithWhereUniqueWithoutUsuarioInput[];
    updateMany?:
      | UsuarioRolUpdateManyWithWhereWithoutUsuarioInput
      | UsuarioRolUpdateManyWithWhereWithoutUsuarioInput[];
    deleteMany?: UsuarioRolScalarWhereInput | UsuarioRolScalarWhereInput[];
  };

  export type CursoUncheckedUpdateManyWithoutInstructorNestedInput = {
    create?:
      | XOR<
          CursoCreateWithoutInstructorInput,
          CursoUncheckedCreateWithoutInstructorInput
        >
      | CursoCreateWithoutInstructorInput[]
      | CursoUncheckedCreateWithoutInstructorInput[];
    connectOrCreate?:
      | CursoCreateOrConnectWithoutInstructorInput
      | CursoCreateOrConnectWithoutInstructorInput[];
    upsert?:
      | CursoUpsertWithWhereUniqueWithoutInstructorInput
      | CursoUpsertWithWhereUniqueWithoutInstructorInput[];
    createMany?: CursoCreateManyInstructorInputEnvelope;
    set?: CursoWhereUniqueInput | CursoWhereUniqueInput[];
    disconnect?: CursoWhereUniqueInput | CursoWhereUniqueInput[];
    delete?: CursoWhereUniqueInput | CursoWhereUniqueInput[];
    connect?: CursoWhereUniqueInput | CursoWhereUniqueInput[];
    update?:
      | CursoUpdateWithWhereUniqueWithoutInstructorInput
      | CursoUpdateWithWhereUniqueWithoutInstructorInput[];
    updateMany?:
      | CursoUpdateManyWithWhereWithoutInstructorInput
      | CursoUpdateManyWithWhereWithoutInstructorInput[];
    deleteMany?: CursoScalarWhereInput | CursoScalarWhereInput[];
  };

  export type InscripcionUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?:
      | XOR<
          InscripcionCreateWithoutUsuarioInput,
          InscripcionUncheckedCreateWithoutUsuarioInput
        >
      | InscripcionCreateWithoutUsuarioInput[]
      | InscripcionUncheckedCreateWithoutUsuarioInput[];
    connectOrCreate?:
      | InscripcionCreateOrConnectWithoutUsuarioInput
      | InscripcionCreateOrConnectWithoutUsuarioInput[];
    upsert?:
      | InscripcionUpsertWithWhereUniqueWithoutUsuarioInput
      | InscripcionUpsertWithWhereUniqueWithoutUsuarioInput[];
    createMany?: InscripcionCreateManyUsuarioInputEnvelope;
    set?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[];
    disconnect?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[];
    delete?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[];
    connect?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[];
    update?:
      | InscripcionUpdateWithWhereUniqueWithoutUsuarioInput
      | InscripcionUpdateWithWhereUniqueWithoutUsuarioInput[];
    updateMany?:
      | InscripcionUpdateManyWithWhereWithoutUsuarioInput
      | InscripcionUpdateManyWithWhereWithoutUsuarioInput[];
    deleteMany?: InscripcionScalarWhereInput | InscripcionScalarWhereInput[];
  };

  export type ResenaUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?:
      | XOR<
          ResenaCreateWithoutUsuarioInput,
          ResenaUncheckedCreateWithoutUsuarioInput
        >
      | ResenaCreateWithoutUsuarioInput[]
      | ResenaUncheckedCreateWithoutUsuarioInput[];
    connectOrCreate?:
      | ResenaCreateOrConnectWithoutUsuarioInput
      | ResenaCreateOrConnectWithoutUsuarioInput[];
    upsert?:
      | ResenaUpsertWithWhereUniqueWithoutUsuarioInput
      | ResenaUpsertWithWhereUniqueWithoutUsuarioInput[];
    createMany?: ResenaCreateManyUsuarioInputEnvelope;
    set?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[];
    disconnect?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[];
    delete?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[];
    connect?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[];
    update?:
      | ResenaUpdateWithWhereUniqueWithoutUsuarioInput
      | ResenaUpdateWithWhereUniqueWithoutUsuarioInput[];
    updateMany?:
      | ResenaUpdateManyWithWhereWithoutUsuarioInput
      | ResenaUpdateManyWithWhereWithoutUsuarioInput[];
    deleteMany?: ResenaScalarWhereInput | ResenaScalarWhereInput[];
  };

  export type ResenaRespuestaUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?:
      | XOR<
          ResenaRespuestaCreateWithoutUsuarioInput,
          ResenaRespuestaUncheckedCreateWithoutUsuarioInput
        >
      | ResenaRespuestaCreateWithoutUsuarioInput[]
      | ResenaRespuestaUncheckedCreateWithoutUsuarioInput[];
    connectOrCreate?:
      | ResenaRespuestaCreateOrConnectWithoutUsuarioInput
      | ResenaRespuestaCreateOrConnectWithoutUsuarioInput[];
    upsert?:
      | ResenaRespuestaUpsertWithWhereUniqueWithoutUsuarioInput
      | ResenaRespuestaUpsertWithWhereUniqueWithoutUsuarioInput[];
    createMany?: ResenaRespuestaCreateManyUsuarioInputEnvelope;
    set?: ResenaRespuestaWhereUniqueInput | ResenaRespuestaWhereUniqueInput[];
    disconnect?:
      | ResenaRespuestaWhereUniqueInput
      | ResenaRespuestaWhereUniqueInput[];
    delete?:
      | ResenaRespuestaWhereUniqueInput
      | ResenaRespuestaWhereUniqueInput[];
    connect?:
      | ResenaRespuestaWhereUniqueInput
      | ResenaRespuestaWhereUniqueInput[];
    update?:
      | ResenaRespuestaUpdateWithWhereUniqueWithoutUsuarioInput
      | ResenaRespuestaUpdateWithWhereUniqueWithoutUsuarioInput[];
    updateMany?:
      | ResenaRespuestaUpdateManyWithWhereWithoutUsuarioInput
      | ResenaRespuestaUpdateManyWithWhereWithoutUsuarioInput[];
    deleteMany?:
      | ResenaRespuestaScalarWhereInput
      | ResenaRespuestaScalarWhereInput[];
  };

  export type FavoritoUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?:
      | XOR<
          FavoritoCreateWithoutUsuarioInput,
          FavoritoUncheckedCreateWithoutUsuarioInput
        >
      | FavoritoCreateWithoutUsuarioInput[]
      | FavoritoUncheckedCreateWithoutUsuarioInput[];
    connectOrCreate?:
      | FavoritoCreateOrConnectWithoutUsuarioInput
      | FavoritoCreateOrConnectWithoutUsuarioInput[];
    upsert?:
      | FavoritoUpsertWithWhereUniqueWithoutUsuarioInput
      | FavoritoUpsertWithWhereUniqueWithoutUsuarioInput[];
    createMany?: FavoritoCreateManyUsuarioInputEnvelope;
    set?: FavoritoWhereUniqueInput | FavoritoWhereUniqueInput[];
    disconnect?: FavoritoWhereUniqueInput | FavoritoWhereUniqueInput[];
    delete?: FavoritoWhereUniqueInput | FavoritoWhereUniqueInput[];
    connect?: FavoritoWhereUniqueInput | FavoritoWhereUniqueInput[];
    update?:
      | FavoritoUpdateWithWhereUniqueWithoutUsuarioInput
      | FavoritoUpdateWithWhereUniqueWithoutUsuarioInput[];
    updateMany?:
      | FavoritoUpdateManyWithWhereWithoutUsuarioInput
      | FavoritoUpdateManyWithWhereWithoutUsuarioInput[];
    deleteMany?: FavoritoScalarWhereInput | FavoritoScalarWhereInput[];
  };

  export type ResenaLikeUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?:
      | XOR<
          ResenaLikeCreateWithoutUsuarioInput,
          ResenaLikeUncheckedCreateWithoutUsuarioInput
        >
      | ResenaLikeCreateWithoutUsuarioInput[]
      | ResenaLikeUncheckedCreateWithoutUsuarioInput[];
    connectOrCreate?:
      | ResenaLikeCreateOrConnectWithoutUsuarioInput
      | ResenaLikeCreateOrConnectWithoutUsuarioInput[];
    upsert?:
      | ResenaLikeUpsertWithWhereUniqueWithoutUsuarioInput
      | ResenaLikeUpsertWithWhereUniqueWithoutUsuarioInput[];
    createMany?: ResenaLikeCreateManyUsuarioInputEnvelope;
    set?: ResenaLikeWhereUniqueInput | ResenaLikeWhereUniqueInput[];
    disconnect?: ResenaLikeWhereUniqueInput | ResenaLikeWhereUniqueInput[];
    delete?: ResenaLikeWhereUniqueInput | ResenaLikeWhereUniqueInput[];
    connect?: ResenaLikeWhereUniqueInput | ResenaLikeWhereUniqueInput[];
    update?:
      | ResenaLikeUpdateWithWhereUniqueWithoutUsuarioInput
      | ResenaLikeUpdateWithWhereUniqueWithoutUsuarioInput[];
    updateMany?:
      | ResenaLikeUpdateManyWithWhereWithoutUsuarioInput
      | ResenaLikeUpdateManyWithWhereWithoutUsuarioInput[];
    deleteMany?: ResenaLikeScalarWhereInput | ResenaLikeScalarWhereInput[];
  };

  export type OrdenUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?:
      | XOR<
          OrdenCreateWithoutUsuarioInput,
          OrdenUncheckedCreateWithoutUsuarioInput
        >
      | OrdenCreateWithoutUsuarioInput[]
      | OrdenUncheckedCreateWithoutUsuarioInput[];
    connectOrCreate?:
      | OrdenCreateOrConnectWithoutUsuarioInput
      | OrdenCreateOrConnectWithoutUsuarioInput[];
    upsert?:
      | OrdenUpsertWithWhereUniqueWithoutUsuarioInput
      | OrdenUpsertWithWhereUniqueWithoutUsuarioInput[];
    createMany?: OrdenCreateManyUsuarioInputEnvelope;
    set?: OrdenWhereUniqueInput | OrdenWhereUniqueInput[];
    disconnect?: OrdenWhereUniqueInput | OrdenWhereUniqueInput[];
    delete?: OrdenWhereUniqueInput | OrdenWhereUniqueInput[];
    connect?: OrdenWhereUniqueInput | OrdenWhereUniqueInput[];
    update?:
      | OrdenUpdateWithWhereUniqueWithoutUsuarioInput
      | OrdenUpdateWithWhereUniqueWithoutUsuarioInput[];
    updateMany?:
      | OrdenUpdateManyWithWhereWithoutUsuarioInput
      | OrdenUpdateManyWithWhereWithoutUsuarioInput[];
    deleteMany?: OrdenScalarWhereInput | OrdenScalarWhereInput[];
  };

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          AuditLogCreateWithoutUserInput,
          AuditLogUncheckedCreateWithoutUserInput
        >
      | AuditLogCreateWithoutUserInput[]
      | AuditLogUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AuditLogCreateOrConnectWithoutUserInput
      | AuditLogCreateOrConnectWithoutUserInput[];
    upsert?:
      | AuditLogUpsertWithWhereUniqueWithoutUserInput
      | AuditLogUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: AuditLogCreateManyUserInputEnvelope;
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    update?:
      | AuditLogUpdateWithWhereUniqueWithoutUserInput
      | AuditLogUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | AuditLogUpdateManyWithWhereWithoutUserInput
      | AuditLogUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[];
  };

  export type CarritoUncheckedUpdateOneWithoutUsuarioNestedInput = {
    create?: XOR<
      CarritoCreateWithoutUsuarioInput,
      CarritoUncheckedCreateWithoutUsuarioInput
    >;
    connectOrCreate?: CarritoCreateOrConnectWithoutUsuarioInput;
    upsert?: CarritoUpsertWithoutUsuarioInput;
    disconnect?: CarritoWhereInput | boolean;
    delete?: CarritoWhereInput | boolean;
    connect?: CarritoWhereUniqueInput;
    update?: XOR<
      XOR<
        CarritoUpdateToOneWithWhereWithoutUsuarioInput,
        CarritoUpdateWithoutUsuarioInput
      >,
      CarritoUncheckedUpdateWithoutUsuarioInput
    >;
  };

  export type NotificacionUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?:
      | XOR<
          NotificacionCreateWithoutUsuarioInput,
          NotificacionUncheckedCreateWithoutUsuarioInput
        >
      | NotificacionCreateWithoutUsuarioInput[]
      | NotificacionUncheckedCreateWithoutUsuarioInput[];
    connectOrCreate?:
      | NotificacionCreateOrConnectWithoutUsuarioInput
      | NotificacionCreateOrConnectWithoutUsuarioInput[];
    upsert?:
      | NotificacionUpsertWithWhereUniqueWithoutUsuarioInput
      | NotificacionUpsertWithWhereUniqueWithoutUsuarioInput[];
    createMany?: NotificacionCreateManyUsuarioInputEnvelope;
    set?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[];
    disconnect?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[];
    delete?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[];
    connect?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[];
    update?:
      | NotificacionUpdateWithWhereUniqueWithoutUsuarioInput
      | NotificacionUpdateWithWhereUniqueWithoutUsuarioInput[];
    updateMany?:
      | NotificacionUpdateManyWithWhereWithoutUsuarioInput
      | NotificacionUpdateManyWithWhereWithoutUsuarioInput[];
    deleteMany?: NotificacionScalarWhereInput | NotificacionScalarWhereInput[];
  };

  export type UsuarioRolCreateNestedManyWithoutRoleInput = {
    create?:
      | XOR<
          UsuarioRolCreateWithoutRoleInput,
          UsuarioRolUncheckedCreateWithoutRoleInput
        >
      | UsuarioRolCreateWithoutRoleInput[]
      | UsuarioRolUncheckedCreateWithoutRoleInput[];
    connectOrCreate?:
      | UsuarioRolCreateOrConnectWithoutRoleInput
      | UsuarioRolCreateOrConnectWithoutRoleInput[];
    createMany?: UsuarioRolCreateManyRoleInputEnvelope;
    connect?: UsuarioRolWhereUniqueInput | UsuarioRolWhereUniqueInput[];
  };

  export type UsuarioRolUncheckedCreateNestedManyWithoutRoleInput = {
    create?:
      | XOR<
          UsuarioRolCreateWithoutRoleInput,
          UsuarioRolUncheckedCreateWithoutRoleInput
        >
      | UsuarioRolCreateWithoutRoleInput[]
      | UsuarioRolUncheckedCreateWithoutRoleInput[];
    connectOrCreate?:
      | UsuarioRolCreateOrConnectWithoutRoleInput
      | UsuarioRolCreateOrConnectWithoutRoleInput[];
    createMany?: UsuarioRolCreateManyRoleInputEnvelope;
    connect?: UsuarioRolWhereUniqueInput | UsuarioRolWhereUniqueInput[];
  };

  export type UsuarioRolUpdateManyWithoutRoleNestedInput = {
    create?:
      | XOR<
          UsuarioRolCreateWithoutRoleInput,
          UsuarioRolUncheckedCreateWithoutRoleInput
        >
      | UsuarioRolCreateWithoutRoleInput[]
      | UsuarioRolUncheckedCreateWithoutRoleInput[];
    connectOrCreate?:
      | UsuarioRolCreateOrConnectWithoutRoleInput
      | UsuarioRolCreateOrConnectWithoutRoleInput[];
    upsert?:
      | UsuarioRolUpsertWithWhereUniqueWithoutRoleInput
      | UsuarioRolUpsertWithWhereUniqueWithoutRoleInput[];
    createMany?: UsuarioRolCreateManyRoleInputEnvelope;
    set?: UsuarioRolWhereUniqueInput | UsuarioRolWhereUniqueInput[];
    disconnect?: UsuarioRolWhereUniqueInput | UsuarioRolWhereUniqueInput[];
    delete?: UsuarioRolWhereUniqueInput | UsuarioRolWhereUniqueInput[];
    connect?: UsuarioRolWhereUniqueInput | UsuarioRolWhereUniqueInput[];
    update?:
      | UsuarioRolUpdateWithWhereUniqueWithoutRoleInput
      | UsuarioRolUpdateWithWhereUniqueWithoutRoleInput[];
    updateMany?:
      | UsuarioRolUpdateManyWithWhereWithoutRoleInput
      | UsuarioRolUpdateManyWithWhereWithoutRoleInput[];
    deleteMany?: UsuarioRolScalarWhereInput | UsuarioRolScalarWhereInput[];
  };

  export type UsuarioRolUncheckedUpdateManyWithoutRoleNestedInput = {
    create?:
      | XOR<
          UsuarioRolCreateWithoutRoleInput,
          UsuarioRolUncheckedCreateWithoutRoleInput
        >
      | UsuarioRolCreateWithoutRoleInput[]
      | UsuarioRolUncheckedCreateWithoutRoleInput[];
    connectOrCreate?:
      | UsuarioRolCreateOrConnectWithoutRoleInput
      | UsuarioRolCreateOrConnectWithoutRoleInput[];
    upsert?:
      | UsuarioRolUpsertWithWhereUniqueWithoutRoleInput
      | UsuarioRolUpsertWithWhereUniqueWithoutRoleInput[];
    createMany?: UsuarioRolCreateManyRoleInputEnvelope;
    set?: UsuarioRolWhereUniqueInput | UsuarioRolWhereUniqueInput[];
    disconnect?: UsuarioRolWhereUniqueInput | UsuarioRolWhereUniqueInput[];
    delete?: UsuarioRolWhereUniqueInput | UsuarioRolWhereUniqueInput[];
    connect?: UsuarioRolWhereUniqueInput | UsuarioRolWhereUniqueInput[];
    update?:
      | UsuarioRolUpdateWithWhereUniqueWithoutRoleInput
      | UsuarioRolUpdateWithWhereUniqueWithoutRoleInput[];
    updateMany?:
      | UsuarioRolUpdateManyWithWhereWithoutRoleInput
      | UsuarioRolUpdateManyWithWhereWithoutRoleInput[];
    deleteMany?: UsuarioRolScalarWhereInput | UsuarioRolScalarWhereInput[];
  };

  export type UsuarioCreateNestedOneWithoutRolesInput = {
    create?: XOR<
      UsuarioCreateWithoutRolesInput,
      UsuarioUncheckedCreateWithoutRolesInput
    >;
    connectOrCreate?: UsuarioCreateOrConnectWithoutRolesInput;
    connect?: UsuarioWhereUniqueInput;
  };

  export type RoleCreateNestedOneWithoutUsuariosInput = {
    create?: XOR<
      RoleCreateWithoutUsuariosInput,
      RoleUncheckedCreateWithoutUsuariosInput
    >;
    connectOrCreate?: RoleCreateOrConnectWithoutUsuariosInput;
    connect?: RoleWhereUniqueInput;
  };

  export type UsuarioUpdateOneRequiredWithoutRolesNestedInput = {
    create?: XOR<
      UsuarioCreateWithoutRolesInput,
      UsuarioUncheckedCreateWithoutRolesInput
    >;
    connectOrCreate?: UsuarioCreateOrConnectWithoutRolesInput;
    upsert?: UsuarioUpsertWithoutRolesInput;
    connect?: UsuarioWhereUniqueInput;
    update?: XOR<
      XOR<
        UsuarioUpdateToOneWithWhereWithoutRolesInput,
        UsuarioUpdateWithoutRolesInput
      >,
      UsuarioUncheckedUpdateWithoutRolesInput
    >;
  };

  export type RoleUpdateOneRequiredWithoutUsuariosNestedInput = {
    create?: XOR<
      RoleCreateWithoutUsuariosInput,
      RoleUncheckedCreateWithoutUsuariosInput
    >;
    connectOrCreate?: RoleCreateOrConnectWithoutUsuariosInput;
    upsert?: RoleUpsertWithoutUsuariosInput;
    connect?: RoleWhereUniqueInput;
    update?: XOR<
      XOR<
        RoleUpdateToOneWithWhereWithoutUsuariosInput,
        RoleUpdateWithoutUsuariosInput
      >,
      RoleUncheckedUpdateWithoutUsuariosInput
    >;
  };

  export type UsuarioCreateNestedOneWithoutFavoritosInput = {
    create?: XOR<
      UsuarioCreateWithoutFavoritosInput,
      UsuarioUncheckedCreateWithoutFavoritosInput
    >;
    connectOrCreate?: UsuarioCreateOrConnectWithoutFavoritosInput;
    connect?: UsuarioWhereUniqueInput;
  };

  export type ProductoCreateNestedOneWithoutFavoritosInput = {
    create?: XOR<
      ProductoCreateWithoutFavoritosInput,
      ProductoUncheckedCreateWithoutFavoritosInput
    >;
    connectOrCreate?: ProductoCreateOrConnectWithoutFavoritosInput;
    connect?: ProductoWhereUniqueInput;
  };

  export type UsuarioUpdateOneRequiredWithoutFavoritosNestedInput = {
    create?: XOR<
      UsuarioCreateWithoutFavoritosInput,
      UsuarioUncheckedCreateWithoutFavoritosInput
    >;
    connectOrCreate?: UsuarioCreateOrConnectWithoutFavoritosInput;
    upsert?: UsuarioUpsertWithoutFavoritosInput;
    connect?: UsuarioWhereUniqueInput;
    update?: XOR<
      XOR<
        UsuarioUpdateToOneWithWhereWithoutFavoritosInput,
        UsuarioUpdateWithoutFavoritosInput
      >,
      UsuarioUncheckedUpdateWithoutFavoritosInput
    >;
  };

  export type ProductoUpdateOneRequiredWithoutFavoritosNestedInput = {
    create?: XOR<
      ProductoCreateWithoutFavoritosInput,
      ProductoUncheckedCreateWithoutFavoritosInput
    >;
    connectOrCreate?: ProductoCreateOrConnectWithoutFavoritosInput;
    upsert?: ProductoUpsertWithoutFavoritosInput;
    connect?: ProductoWhereUniqueInput;
    update?: XOR<
      XOR<
        ProductoUpdateToOneWithWhereWithoutFavoritosInput,
        ProductoUpdateWithoutFavoritosInput
      >,
      ProductoUncheckedUpdateWithoutFavoritosInput
    >;
  };

  export type UsuarioCreateNestedOneWithoutCursosImpartidosInput = {
    create?: XOR<
      UsuarioCreateWithoutCursosImpartidosInput,
      UsuarioUncheckedCreateWithoutCursosImpartidosInput
    >;
    connectOrCreate?: UsuarioCreateOrConnectWithoutCursosImpartidosInput;
    connect?: UsuarioWhereUniqueInput;
  };

  export type ModuloCreateNestedManyWithoutCursoInput = {
    create?:
      | XOR<
          ModuloCreateWithoutCursoInput,
          ModuloUncheckedCreateWithoutCursoInput
        >
      | ModuloCreateWithoutCursoInput[]
      | ModuloUncheckedCreateWithoutCursoInput[];
    connectOrCreate?:
      | ModuloCreateOrConnectWithoutCursoInput
      | ModuloCreateOrConnectWithoutCursoInput[];
    createMany?: ModuloCreateManyCursoInputEnvelope;
    connect?: ModuloWhereUniqueInput | ModuloWhereUniqueInput[];
  };

  export type ResenaCreateNestedManyWithoutCursoInput = {
    create?:
      | XOR<
          ResenaCreateWithoutCursoInput,
          ResenaUncheckedCreateWithoutCursoInput
        >
      | ResenaCreateWithoutCursoInput[]
      | ResenaUncheckedCreateWithoutCursoInput[];
    connectOrCreate?:
      | ResenaCreateOrConnectWithoutCursoInput
      | ResenaCreateOrConnectWithoutCursoInput[];
    createMany?: ResenaCreateManyCursoInputEnvelope;
    connect?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[];
  };

  export type InscripcionCreateNestedManyWithoutCursoInput = {
    create?:
      | XOR<
          InscripcionCreateWithoutCursoInput,
          InscripcionUncheckedCreateWithoutCursoInput
        >
      | InscripcionCreateWithoutCursoInput[]
      | InscripcionUncheckedCreateWithoutCursoInput[];
    connectOrCreate?:
      | InscripcionCreateOrConnectWithoutCursoInput
      | InscripcionCreateOrConnectWithoutCursoInput[];
    createMany?: InscripcionCreateManyCursoInputEnvelope;
    connect?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[];
  };

  export type ItemCarritoCreateNestedManyWithoutCursoInput = {
    create?:
      | XOR<
          ItemCarritoCreateWithoutCursoInput,
          ItemCarritoUncheckedCreateWithoutCursoInput
        >
      | ItemCarritoCreateWithoutCursoInput[]
      | ItemCarritoUncheckedCreateWithoutCursoInput[];
    connectOrCreate?:
      | ItemCarritoCreateOrConnectWithoutCursoInput
      | ItemCarritoCreateOrConnectWithoutCursoInput[];
    createMany?: ItemCarritoCreateManyCursoInputEnvelope;
    connect?: ItemCarritoWhereUniqueInput | ItemCarritoWhereUniqueInput[];
  };

  export type ModuloUncheckedCreateNestedManyWithoutCursoInput = {
    create?:
      | XOR<
          ModuloCreateWithoutCursoInput,
          ModuloUncheckedCreateWithoutCursoInput
        >
      | ModuloCreateWithoutCursoInput[]
      | ModuloUncheckedCreateWithoutCursoInput[];
    connectOrCreate?:
      | ModuloCreateOrConnectWithoutCursoInput
      | ModuloCreateOrConnectWithoutCursoInput[];
    createMany?: ModuloCreateManyCursoInputEnvelope;
    connect?: ModuloWhereUniqueInput | ModuloWhereUniqueInput[];
  };

  export type ResenaUncheckedCreateNestedManyWithoutCursoInput = {
    create?:
      | XOR<
          ResenaCreateWithoutCursoInput,
          ResenaUncheckedCreateWithoutCursoInput
        >
      | ResenaCreateWithoutCursoInput[]
      | ResenaUncheckedCreateWithoutCursoInput[];
    connectOrCreate?:
      | ResenaCreateOrConnectWithoutCursoInput
      | ResenaCreateOrConnectWithoutCursoInput[];
    createMany?: ResenaCreateManyCursoInputEnvelope;
    connect?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[];
  };

  export type InscripcionUncheckedCreateNestedManyWithoutCursoInput = {
    create?:
      | XOR<
          InscripcionCreateWithoutCursoInput,
          InscripcionUncheckedCreateWithoutCursoInput
        >
      | InscripcionCreateWithoutCursoInput[]
      | InscripcionUncheckedCreateWithoutCursoInput[];
    connectOrCreate?:
      | InscripcionCreateOrConnectWithoutCursoInput
      | InscripcionCreateOrConnectWithoutCursoInput[];
    createMany?: InscripcionCreateManyCursoInputEnvelope;
    connect?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[];
  };

  export type ItemCarritoUncheckedCreateNestedManyWithoutCursoInput = {
    create?:
      | XOR<
          ItemCarritoCreateWithoutCursoInput,
          ItemCarritoUncheckedCreateWithoutCursoInput
        >
      | ItemCarritoCreateWithoutCursoInput[]
      | ItemCarritoUncheckedCreateWithoutCursoInput[];
    connectOrCreate?:
      | ItemCarritoCreateOrConnectWithoutCursoInput
      | ItemCarritoCreateOrConnectWithoutCursoInput[];
    createMany?: ItemCarritoCreateManyCursoInputEnvelope;
    connect?: ItemCarritoWhereUniqueInput | ItemCarritoWhereUniqueInput[];
  };

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean;
  };

  export type EnumNivelCursoFieldUpdateOperationsInput = {
    set?: $Enums.NivelCurso;
  };

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null;
    increment?: Decimal | DecimalJsLike | number | string;
    decrement?: Decimal | DecimalJsLike | number | string;
    multiply?: Decimal | DecimalJsLike | number | string;
    divide?: Decimal | DecimalJsLike | number | string;
  };

  export type UsuarioUpdateOneWithoutCursosImpartidosNestedInput = {
    create?: XOR<
      UsuarioCreateWithoutCursosImpartidosInput,
      UsuarioUncheckedCreateWithoutCursosImpartidosInput
    >;
    connectOrCreate?: UsuarioCreateOrConnectWithoutCursosImpartidosInput;
    upsert?: UsuarioUpsertWithoutCursosImpartidosInput;
    disconnect?: UsuarioWhereInput | boolean;
    delete?: UsuarioWhereInput | boolean;
    connect?: UsuarioWhereUniqueInput;
    update?: XOR<
      XOR<
        UsuarioUpdateToOneWithWhereWithoutCursosImpartidosInput,
        UsuarioUpdateWithoutCursosImpartidosInput
      >,
      UsuarioUncheckedUpdateWithoutCursosImpartidosInput
    >;
  };

  export type ModuloUpdateManyWithoutCursoNestedInput = {
    create?:
      | XOR<
          ModuloCreateWithoutCursoInput,
          ModuloUncheckedCreateWithoutCursoInput
        >
      | ModuloCreateWithoutCursoInput[]
      | ModuloUncheckedCreateWithoutCursoInput[];
    connectOrCreate?:
      | ModuloCreateOrConnectWithoutCursoInput
      | ModuloCreateOrConnectWithoutCursoInput[];
    upsert?:
      | ModuloUpsertWithWhereUniqueWithoutCursoInput
      | ModuloUpsertWithWhereUniqueWithoutCursoInput[];
    createMany?: ModuloCreateManyCursoInputEnvelope;
    set?: ModuloWhereUniqueInput | ModuloWhereUniqueInput[];
    disconnect?: ModuloWhereUniqueInput | ModuloWhereUniqueInput[];
    delete?: ModuloWhereUniqueInput | ModuloWhereUniqueInput[];
    connect?: ModuloWhereUniqueInput | ModuloWhereUniqueInput[];
    update?:
      | ModuloUpdateWithWhereUniqueWithoutCursoInput
      | ModuloUpdateWithWhereUniqueWithoutCursoInput[];
    updateMany?:
      | ModuloUpdateManyWithWhereWithoutCursoInput
      | ModuloUpdateManyWithWhereWithoutCursoInput[];
    deleteMany?: ModuloScalarWhereInput | ModuloScalarWhereInput[];
  };

  export type ResenaUpdateManyWithoutCursoNestedInput = {
    create?:
      | XOR<
          ResenaCreateWithoutCursoInput,
          ResenaUncheckedCreateWithoutCursoInput
        >
      | ResenaCreateWithoutCursoInput[]
      | ResenaUncheckedCreateWithoutCursoInput[];
    connectOrCreate?:
      | ResenaCreateOrConnectWithoutCursoInput
      | ResenaCreateOrConnectWithoutCursoInput[];
    upsert?:
      | ResenaUpsertWithWhereUniqueWithoutCursoInput
      | ResenaUpsertWithWhereUniqueWithoutCursoInput[];
    createMany?: ResenaCreateManyCursoInputEnvelope;
    set?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[];
    disconnect?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[];
    delete?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[];
    connect?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[];
    update?:
      | ResenaUpdateWithWhereUniqueWithoutCursoInput
      | ResenaUpdateWithWhereUniqueWithoutCursoInput[];
    updateMany?:
      | ResenaUpdateManyWithWhereWithoutCursoInput
      | ResenaUpdateManyWithWhereWithoutCursoInput[];
    deleteMany?: ResenaScalarWhereInput | ResenaScalarWhereInput[];
  };

  export type InscripcionUpdateManyWithoutCursoNestedInput = {
    create?:
      | XOR<
          InscripcionCreateWithoutCursoInput,
          InscripcionUncheckedCreateWithoutCursoInput
        >
      | InscripcionCreateWithoutCursoInput[]
      | InscripcionUncheckedCreateWithoutCursoInput[];
    connectOrCreate?:
      | InscripcionCreateOrConnectWithoutCursoInput
      | InscripcionCreateOrConnectWithoutCursoInput[];
    upsert?:
      | InscripcionUpsertWithWhereUniqueWithoutCursoInput
      | InscripcionUpsertWithWhereUniqueWithoutCursoInput[];
    createMany?: InscripcionCreateManyCursoInputEnvelope;
    set?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[];
    disconnect?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[];
    delete?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[];
    connect?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[];
    update?:
      | InscripcionUpdateWithWhereUniqueWithoutCursoInput
      | InscripcionUpdateWithWhereUniqueWithoutCursoInput[];
    updateMany?:
      | InscripcionUpdateManyWithWhereWithoutCursoInput
      | InscripcionUpdateManyWithWhereWithoutCursoInput[];
    deleteMany?: InscripcionScalarWhereInput | InscripcionScalarWhereInput[];
  };

  export type ItemCarritoUpdateManyWithoutCursoNestedInput = {
    create?:
      | XOR<
          ItemCarritoCreateWithoutCursoInput,
          ItemCarritoUncheckedCreateWithoutCursoInput
        >
      | ItemCarritoCreateWithoutCursoInput[]
      | ItemCarritoUncheckedCreateWithoutCursoInput[];
    connectOrCreate?:
      | ItemCarritoCreateOrConnectWithoutCursoInput
      | ItemCarritoCreateOrConnectWithoutCursoInput[];
    upsert?:
      | ItemCarritoUpsertWithWhereUniqueWithoutCursoInput
      | ItemCarritoUpsertWithWhereUniqueWithoutCursoInput[];
    createMany?: ItemCarritoCreateManyCursoInputEnvelope;
    set?: ItemCarritoWhereUniqueInput | ItemCarritoWhereUniqueInput[];
    disconnect?: ItemCarritoWhereUniqueInput | ItemCarritoWhereUniqueInput[];
    delete?: ItemCarritoWhereUniqueInput | ItemCarritoWhereUniqueInput[];
    connect?: ItemCarritoWhereUniqueInput | ItemCarritoWhereUniqueInput[];
    update?:
      | ItemCarritoUpdateWithWhereUniqueWithoutCursoInput
      | ItemCarritoUpdateWithWhereUniqueWithoutCursoInput[];
    updateMany?:
      | ItemCarritoUpdateManyWithWhereWithoutCursoInput
      | ItemCarritoUpdateManyWithWhereWithoutCursoInput[];
    deleteMany?: ItemCarritoScalarWhereInput | ItemCarritoScalarWhereInput[];
  };

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type ModuloUncheckedUpdateManyWithoutCursoNestedInput = {
    create?:
      | XOR<
          ModuloCreateWithoutCursoInput,
          ModuloUncheckedCreateWithoutCursoInput
        >
      | ModuloCreateWithoutCursoInput[]
      | ModuloUncheckedCreateWithoutCursoInput[];
    connectOrCreate?:
      | ModuloCreateOrConnectWithoutCursoInput
      | ModuloCreateOrConnectWithoutCursoInput[];
    upsert?:
      | ModuloUpsertWithWhereUniqueWithoutCursoInput
      | ModuloUpsertWithWhereUniqueWithoutCursoInput[];
    createMany?: ModuloCreateManyCursoInputEnvelope;
    set?: ModuloWhereUniqueInput | ModuloWhereUniqueInput[];
    disconnect?: ModuloWhereUniqueInput | ModuloWhereUniqueInput[];
    delete?: ModuloWhereUniqueInput | ModuloWhereUniqueInput[];
    connect?: ModuloWhereUniqueInput | ModuloWhereUniqueInput[];
    update?:
      | ModuloUpdateWithWhereUniqueWithoutCursoInput
      | ModuloUpdateWithWhereUniqueWithoutCursoInput[];
    updateMany?:
      | ModuloUpdateManyWithWhereWithoutCursoInput
      | ModuloUpdateManyWithWhereWithoutCursoInput[];
    deleteMany?: ModuloScalarWhereInput | ModuloScalarWhereInput[];
  };

  export type ResenaUncheckedUpdateManyWithoutCursoNestedInput = {
    create?:
      | XOR<
          ResenaCreateWithoutCursoInput,
          ResenaUncheckedCreateWithoutCursoInput
        >
      | ResenaCreateWithoutCursoInput[]
      | ResenaUncheckedCreateWithoutCursoInput[];
    connectOrCreate?:
      | ResenaCreateOrConnectWithoutCursoInput
      | ResenaCreateOrConnectWithoutCursoInput[];
    upsert?:
      | ResenaUpsertWithWhereUniqueWithoutCursoInput
      | ResenaUpsertWithWhereUniqueWithoutCursoInput[];
    createMany?: ResenaCreateManyCursoInputEnvelope;
    set?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[];
    disconnect?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[];
    delete?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[];
    connect?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[];
    update?:
      | ResenaUpdateWithWhereUniqueWithoutCursoInput
      | ResenaUpdateWithWhereUniqueWithoutCursoInput[];
    updateMany?:
      | ResenaUpdateManyWithWhereWithoutCursoInput
      | ResenaUpdateManyWithWhereWithoutCursoInput[];
    deleteMany?: ResenaScalarWhereInput | ResenaScalarWhereInput[];
  };

  export type InscripcionUncheckedUpdateManyWithoutCursoNestedInput = {
    create?:
      | XOR<
          InscripcionCreateWithoutCursoInput,
          InscripcionUncheckedCreateWithoutCursoInput
        >
      | InscripcionCreateWithoutCursoInput[]
      | InscripcionUncheckedCreateWithoutCursoInput[];
    connectOrCreate?:
      | InscripcionCreateOrConnectWithoutCursoInput
      | InscripcionCreateOrConnectWithoutCursoInput[];
    upsert?:
      | InscripcionUpsertWithWhereUniqueWithoutCursoInput
      | InscripcionUpsertWithWhereUniqueWithoutCursoInput[];
    createMany?: InscripcionCreateManyCursoInputEnvelope;
    set?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[];
    disconnect?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[];
    delete?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[];
    connect?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[];
    update?:
      | InscripcionUpdateWithWhereUniqueWithoutCursoInput
      | InscripcionUpdateWithWhereUniqueWithoutCursoInput[];
    updateMany?:
      | InscripcionUpdateManyWithWhereWithoutCursoInput
      | InscripcionUpdateManyWithWhereWithoutCursoInput[];
    deleteMany?: InscripcionScalarWhereInput | InscripcionScalarWhereInput[];
  };

  export type ItemCarritoUncheckedUpdateManyWithoutCursoNestedInput = {
    create?:
      | XOR<
          ItemCarritoCreateWithoutCursoInput,
          ItemCarritoUncheckedCreateWithoutCursoInput
        >
      | ItemCarritoCreateWithoutCursoInput[]
      | ItemCarritoUncheckedCreateWithoutCursoInput[];
    connectOrCreate?:
      | ItemCarritoCreateOrConnectWithoutCursoInput
      | ItemCarritoCreateOrConnectWithoutCursoInput[];
    upsert?:
      | ItemCarritoUpsertWithWhereUniqueWithoutCursoInput
      | ItemCarritoUpsertWithWhereUniqueWithoutCursoInput[];
    createMany?: ItemCarritoCreateManyCursoInputEnvelope;
    set?: ItemCarritoWhereUniqueInput | ItemCarritoWhereUniqueInput[];
    disconnect?: ItemCarritoWhereUniqueInput | ItemCarritoWhereUniqueInput[];
    delete?: ItemCarritoWhereUniqueInput | ItemCarritoWhereUniqueInput[];
    connect?: ItemCarritoWhereUniqueInput | ItemCarritoWhereUniqueInput[];
    update?:
      | ItemCarritoUpdateWithWhereUniqueWithoutCursoInput
      | ItemCarritoUpdateWithWhereUniqueWithoutCursoInput[];
    updateMany?:
      | ItemCarritoUpdateManyWithWhereWithoutCursoInput
      | ItemCarritoUpdateManyWithWhereWithoutCursoInput[];
    deleteMany?: ItemCarritoScalarWhereInput | ItemCarritoScalarWhereInput[];
  };

  export type UsuarioCreateNestedOneWithoutInscripcionesInput = {
    create?: XOR<
      UsuarioCreateWithoutInscripcionesInput,
      UsuarioUncheckedCreateWithoutInscripcionesInput
    >;
    connectOrCreate?: UsuarioCreateOrConnectWithoutInscripcionesInput;
    connect?: UsuarioWhereUniqueInput;
  };

  export type CursoCreateNestedOneWithoutInscripcionesInput = {
    create?: XOR<
      CursoCreateWithoutInscripcionesInput,
      CursoUncheckedCreateWithoutInscripcionesInput
    >;
    connectOrCreate?: CursoCreateOrConnectWithoutInscripcionesInput;
    connect?: CursoWhereUniqueInput;
  };

  export type EnumEstadoInscripcionFieldUpdateOperationsInput = {
    set?: $Enums.EstadoInscripcion;
  };

  export type UsuarioUpdateOneRequiredWithoutInscripcionesNestedInput = {
    create?: XOR<
      UsuarioCreateWithoutInscripcionesInput,
      UsuarioUncheckedCreateWithoutInscripcionesInput
    >;
    connectOrCreate?: UsuarioCreateOrConnectWithoutInscripcionesInput;
    upsert?: UsuarioUpsertWithoutInscripcionesInput;
    connect?: UsuarioWhereUniqueInput;
    update?: XOR<
      XOR<
        UsuarioUpdateToOneWithWhereWithoutInscripcionesInput,
        UsuarioUpdateWithoutInscripcionesInput
      >,
      UsuarioUncheckedUpdateWithoutInscripcionesInput
    >;
  };

  export type CursoUpdateOneRequiredWithoutInscripcionesNestedInput = {
    create?: XOR<
      CursoCreateWithoutInscripcionesInput,
      CursoUncheckedCreateWithoutInscripcionesInput
    >;
    connectOrCreate?: CursoCreateOrConnectWithoutInscripcionesInput;
    upsert?: CursoUpsertWithoutInscripcionesInput;
    connect?: CursoWhereUniqueInput;
    update?: XOR<
      XOR<
        CursoUpdateToOneWithWhereWithoutInscripcionesInput,
        CursoUpdateWithoutInscripcionesInput
      >,
      CursoUncheckedUpdateWithoutInscripcionesInput
    >;
  };

  export type CursoCreateNestedOneWithoutModulosInput = {
    create?: XOR<
      CursoCreateWithoutModulosInput,
      CursoUncheckedCreateWithoutModulosInput
    >;
    connectOrCreate?: CursoCreateOrConnectWithoutModulosInput;
    connect?: CursoWhereUniqueInput;
  };

  export type LeccionCreateNestedManyWithoutModuloInput = {
    create?:
      | XOR<
          LeccionCreateWithoutModuloInput,
          LeccionUncheckedCreateWithoutModuloInput
        >
      | LeccionCreateWithoutModuloInput[]
      | LeccionUncheckedCreateWithoutModuloInput[];
    connectOrCreate?:
      | LeccionCreateOrConnectWithoutModuloInput
      | LeccionCreateOrConnectWithoutModuloInput[];
    createMany?: LeccionCreateManyModuloInputEnvelope;
    connect?: LeccionWhereUniqueInput | LeccionWhereUniqueInput[];
  };

  export type LeccionUncheckedCreateNestedManyWithoutModuloInput = {
    create?:
      | XOR<
          LeccionCreateWithoutModuloInput,
          LeccionUncheckedCreateWithoutModuloInput
        >
      | LeccionCreateWithoutModuloInput[]
      | LeccionUncheckedCreateWithoutModuloInput[];
    connectOrCreate?:
      | LeccionCreateOrConnectWithoutModuloInput
      | LeccionCreateOrConnectWithoutModuloInput[];
    createMany?: LeccionCreateManyModuloInputEnvelope;
    connect?: LeccionWhereUniqueInput | LeccionWhereUniqueInput[];
  };

  export type CursoUpdateOneRequiredWithoutModulosNestedInput = {
    create?: XOR<
      CursoCreateWithoutModulosInput,
      CursoUncheckedCreateWithoutModulosInput
    >;
    connectOrCreate?: CursoCreateOrConnectWithoutModulosInput;
    upsert?: CursoUpsertWithoutModulosInput;
    connect?: CursoWhereUniqueInput;
    update?: XOR<
      XOR<
        CursoUpdateToOneWithWhereWithoutModulosInput,
        CursoUpdateWithoutModulosInput
      >,
      CursoUncheckedUpdateWithoutModulosInput
    >;
  };

  export type LeccionUpdateManyWithoutModuloNestedInput = {
    create?:
      | XOR<
          LeccionCreateWithoutModuloInput,
          LeccionUncheckedCreateWithoutModuloInput
        >
      | LeccionCreateWithoutModuloInput[]
      | LeccionUncheckedCreateWithoutModuloInput[];
    connectOrCreate?:
      | LeccionCreateOrConnectWithoutModuloInput
      | LeccionCreateOrConnectWithoutModuloInput[];
    upsert?:
      | LeccionUpsertWithWhereUniqueWithoutModuloInput
      | LeccionUpsertWithWhereUniqueWithoutModuloInput[];
    createMany?: LeccionCreateManyModuloInputEnvelope;
    set?: LeccionWhereUniqueInput | LeccionWhereUniqueInput[];
    disconnect?: LeccionWhereUniqueInput | LeccionWhereUniqueInput[];
    delete?: LeccionWhereUniqueInput | LeccionWhereUniqueInput[];
    connect?: LeccionWhereUniqueInput | LeccionWhereUniqueInput[];
    update?:
      | LeccionUpdateWithWhereUniqueWithoutModuloInput
      | LeccionUpdateWithWhereUniqueWithoutModuloInput[];
    updateMany?:
      | LeccionUpdateManyWithWhereWithoutModuloInput
      | LeccionUpdateManyWithWhereWithoutModuloInput[];
    deleteMany?: LeccionScalarWhereInput | LeccionScalarWhereInput[];
  };

  export type LeccionUncheckedUpdateManyWithoutModuloNestedInput = {
    create?:
      | XOR<
          LeccionCreateWithoutModuloInput,
          LeccionUncheckedCreateWithoutModuloInput
        >
      | LeccionCreateWithoutModuloInput[]
      | LeccionUncheckedCreateWithoutModuloInput[];
    connectOrCreate?:
      | LeccionCreateOrConnectWithoutModuloInput
      | LeccionCreateOrConnectWithoutModuloInput[];
    upsert?:
      | LeccionUpsertWithWhereUniqueWithoutModuloInput
      | LeccionUpsertWithWhereUniqueWithoutModuloInput[];
    createMany?: LeccionCreateManyModuloInputEnvelope;
    set?: LeccionWhereUniqueInput | LeccionWhereUniqueInput[];
    disconnect?: LeccionWhereUniqueInput | LeccionWhereUniqueInput[];
    delete?: LeccionWhereUniqueInput | LeccionWhereUniqueInput[];
    connect?: LeccionWhereUniqueInput | LeccionWhereUniqueInput[];
    update?:
      | LeccionUpdateWithWhereUniqueWithoutModuloInput
      | LeccionUpdateWithWhereUniqueWithoutModuloInput[];
    updateMany?:
      | LeccionUpdateManyWithWhereWithoutModuloInput
      | LeccionUpdateManyWithWhereWithoutModuloInput[];
    deleteMany?: LeccionScalarWhereInput | LeccionScalarWhereInput[];
  };

  export type ModuloCreateNestedOneWithoutLeccionesInput = {
    create?: XOR<
      ModuloCreateWithoutLeccionesInput,
      ModuloUncheckedCreateWithoutLeccionesInput
    >;
    connectOrCreate?: ModuloCreateOrConnectWithoutLeccionesInput;
    connect?: ModuloWhereUniqueInput;
  };

  export type EnumTipoLeccionFieldUpdateOperationsInput = {
    set?: $Enums.TipoLeccion;
  };

  export type FloatFieldUpdateOperationsInput = {
    set?: number;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type ModuloUpdateOneRequiredWithoutLeccionesNestedInput = {
    create?: XOR<
      ModuloCreateWithoutLeccionesInput,
      ModuloUncheckedCreateWithoutLeccionesInput
    >;
    connectOrCreate?: ModuloCreateOrConnectWithoutLeccionesInput;
    upsert?: ModuloUpsertWithoutLeccionesInput;
    connect?: ModuloWhereUniqueInput;
    update?: XOR<
      XOR<
        ModuloUpdateToOneWithWhereWithoutLeccionesInput,
        ModuloUpdateWithoutLeccionesInput
      >,
      ModuloUncheckedUpdateWithoutLeccionesInput
    >;
  };

  export type MarcaCreateNestedOneWithoutProductosInput = {
    create?: XOR<
      MarcaCreateWithoutProductosInput,
      MarcaUncheckedCreateWithoutProductosInput
    >;
    connectOrCreate?: MarcaCreateOrConnectWithoutProductosInput;
    connect?: MarcaWhereUniqueInput;
  };

  export type CategoriaCreateNestedOneWithoutProductosInput = {
    create?: XOR<
      CategoriaCreateWithoutProductosInput,
      CategoriaUncheckedCreateWithoutProductosInput
    >;
    connectOrCreate?: CategoriaCreateOrConnectWithoutProductosInput;
    connect?: CategoriaWhereUniqueInput;
  };

  export type ProductoImagenCreateNestedManyWithoutProductoInput = {
    create?:
      | XOR<
          ProductoImagenCreateWithoutProductoInput,
          ProductoImagenUncheckedCreateWithoutProductoInput
        >
      | ProductoImagenCreateWithoutProductoInput[]
      | ProductoImagenUncheckedCreateWithoutProductoInput[];
    connectOrCreate?:
      | ProductoImagenCreateOrConnectWithoutProductoInput
      | ProductoImagenCreateOrConnectWithoutProductoInput[];
    createMany?: ProductoImagenCreateManyProductoInputEnvelope;
    connect?: ProductoImagenWhereUniqueInput | ProductoImagenWhereUniqueInput[];
  };

  export type ResenaCreateNestedManyWithoutProductoInput = {
    create?:
      | XOR<
          ResenaCreateWithoutProductoInput,
          ResenaUncheckedCreateWithoutProductoInput
        >
      | ResenaCreateWithoutProductoInput[]
      | ResenaUncheckedCreateWithoutProductoInput[];
    connectOrCreate?:
      | ResenaCreateOrConnectWithoutProductoInput
      | ResenaCreateOrConnectWithoutProductoInput[];
    createMany?: ResenaCreateManyProductoInputEnvelope;
    connect?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[];
  };

  export type FavoritoCreateNestedManyWithoutProductoInput = {
    create?:
      | XOR<
          FavoritoCreateWithoutProductoInput,
          FavoritoUncheckedCreateWithoutProductoInput
        >
      | FavoritoCreateWithoutProductoInput[]
      | FavoritoUncheckedCreateWithoutProductoInput[];
    connectOrCreate?:
      | FavoritoCreateOrConnectWithoutProductoInput
      | FavoritoCreateOrConnectWithoutProductoInput[];
    createMany?: FavoritoCreateManyProductoInputEnvelope;
    connect?: FavoritoWhereUniqueInput | FavoritoWhereUniqueInput[];
  };

  export type ItemCarritoCreateNestedManyWithoutProductoInput = {
    create?:
      | XOR<
          ItemCarritoCreateWithoutProductoInput,
          ItemCarritoUncheckedCreateWithoutProductoInput
        >
      | ItemCarritoCreateWithoutProductoInput[]
      | ItemCarritoUncheckedCreateWithoutProductoInput[];
    connectOrCreate?:
      | ItemCarritoCreateOrConnectWithoutProductoInput
      | ItemCarritoCreateOrConnectWithoutProductoInput[];
    createMany?: ItemCarritoCreateManyProductoInputEnvelope;
    connect?: ItemCarritoWhereUniqueInput | ItemCarritoWhereUniqueInput[];
  };

  export type ProductoImagenUncheckedCreateNestedManyWithoutProductoInput = {
    create?:
      | XOR<
          ProductoImagenCreateWithoutProductoInput,
          ProductoImagenUncheckedCreateWithoutProductoInput
        >
      | ProductoImagenCreateWithoutProductoInput[]
      | ProductoImagenUncheckedCreateWithoutProductoInput[];
    connectOrCreate?:
      | ProductoImagenCreateOrConnectWithoutProductoInput
      | ProductoImagenCreateOrConnectWithoutProductoInput[];
    createMany?: ProductoImagenCreateManyProductoInputEnvelope;
    connect?: ProductoImagenWhereUniqueInput | ProductoImagenWhereUniqueInput[];
  };

  export type ResenaUncheckedCreateNestedManyWithoutProductoInput = {
    create?:
      | XOR<
          ResenaCreateWithoutProductoInput,
          ResenaUncheckedCreateWithoutProductoInput
        >
      | ResenaCreateWithoutProductoInput[]
      | ResenaUncheckedCreateWithoutProductoInput[];
    connectOrCreate?:
      | ResenaCreateOrConnectWithoutProductoInput
      | ResenaCreateOrConnectWithoutProductoInput[];
    createMany?: ResenaCreateManyProductoInputEnvelope;
    connect?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[];
  };

  export type FavoritoUncheckedCreateNestedManyWithoutProductoInput = {
    create?:
      | XOR<
          FavoritoCreateWithoutProductoInput,
          FavoritoUncheckedCreateWithoutProductoInput
        >
      | FavoritoCreateWithoutProductoInput[]
      | FavoritoUncheckedCreateWithoutProductoInput[];
    connectOrCreate?:
      | FavoritoCreateOrConnectWithoutProductoInput
      | FavoritoCreateOrConnectWithoutProductoInput[];
    createMany?: FavoritoCreateManyProductoInputEnvelope;
    connect?: FavoritoWhereUniqueInput | FavoritoWhereUniqueInput[];
  };

  export type ItemCarritoUncheckedCreateNestedManyWithoutProductoInput = {
    create?:
      | XOR<
          ItemCarritoCreateWithoutProductoInput,
          ItemCarritoUncheckedCreateWithoutProductoInput
        >
      | ItemCarritoCreateWithoutProductoInput[]
      | ItemCarritoUncheckedCreateWithoutProductoInput[];
    connectOrCreate?:
      | ItemCarritoCreateOrConnectWithoutProductoInput
      | ItemCarritoCreateOrConnectWithoutProductoInput[];
    createMany?: ItemCarritoCreateManyProductoInputEnvelope;
    connect?: ItemCarritoWhereUniqueInput | ItemCarritoWhereUniqueInput[];
  };

  export type MarcaUpdateOneWithoutProductosNestedInput = {
    create?: XOR<
      MarcaCreateWithoutProductosInput,
      MarcaUncheckedCreateWithoutProductosInput
    >;
    connectOrCreate?: MarcaCreateOrConnectWithoutProductosInput;
    upsert?: MarcaUpsertWithoutProductosInput;
    disconnect?: MarcaWhereInput | boolean;
    delete?: MarcaWhereInput | boolean;
    connect?: MarcaWhereUniqueInput;
    update?: XOR<
      XOR<
        MarcaUpdateToOneWithWhereWithoutProductosInput,
        MarcaUpdateWithoutProductosInput
      >,
      MarcaUncheckedUpdateWithoutProductosInput
    >;
  };

  export type CategoriaUpdateOneWithoutProductosNestedInput = {
    create?: XOR<
      CategoriaCreateWithoutProductosInput,
      CategoriaUncheckedCreateWithoutProductosInput
    >;
    connectOrCreate?: CategoriaCreateOrConnectWithoutProductosInput;
    upsert?: CategoriaUpsertWithoutProductosInput;
    disconnect?: CategoriaWhereInput | boolean;
    delete?: CategoriaWhereInput | boolean;
    connect?: CategoriaWhereUniqueInput;
    update?: XOR<
      XOR<
        CategoriaUpdateToOneWithWhereWithoutProductosInput,
        CategoriaUpdateWithoutProductosInput
      >,
      CategoriaUncheckedUpdateWithoutProductosInput
    >;
  };

  export type ProductoImagenUpdateManyWithoutProductoNestedInput = {
    create?:
      | XOR<
          ProductoImagenCreateWithoutProductoInput,
          ProductoImagenUncheckedCreateWithoutProductoInput
        >
      | ProductoImagenCreateWithoutProductoInput[]
      | ProductoImagenUncheckedCreateWithoutProductoInput[];
    connectOrCreate?:
      | ProductoImagenCreateOrConnectWithoutProductoInput
      | ProductoImagenCreateOrConnectWithoutProductoInput[];
    upsert?:
      | ProductoImagenUpsertWithWhereUniqueWithoutProductoInput
      | ProductoImagenUpsertWithWhereUniqueWithoutProductoInput[];
    createMany?: ProductoImagenCreateManyProductoInputEnvelope;
    set?: ProductoImagenWhereUniqueInput | ProductoImagenWhereUniqueInput[];
    disconnect?:
      | ProductoImagenWhereUniqueInput
      | ProductoImagenWhereUniqueInput[];
    delete?: ProductoImagenWhereUniqueInput | ProductoImagenWhereUniqueInput[];
    connect?: ProductoImagenWhereUniqueInput | ProductoImagenWhereUniqueInput[];
    update?:
      | ProductoImagenUpdateWithWhereUniqueWithoutProductoInput
      | ProductoImagenUpdateWithWhereUniqueWithoutProductoInput[];
    updateMany?:
      | ProductoImagenUpdateManyWithWhereWithoutProductoInput
      | ProductoImagenUpdateManyWithWhereWithoutProductoInput[];
    deleteMany?:
      | ProductoImagenScalarWhereInput
      | ProductoImagenScalarWhereInput[];
  };

  export type ResenaUpdateManyWithoutProductoNestedInput = {
    create?:
      | XOR<
          ResenaCreateWithoutProductoInput,
          ResenaUncheckedCreateWithoutProductoInput
        >
      | ResenaCreateWithoutProductoInput[]
      | ResenaUncheckedCreateWithoutProductoInput[];
    connectOrCreate?:
      | ResenaCreateOrConnectWithoutProductoInput
      | ResenaCreateOrConnectWithoutProductoInput[];
    upsert?:
      | ResenaUpsertWithWhereUniqueWithoutProductoInput
      | ResenaUpsertWithWhereUniqueWithoutProductoInput[];
    createMany?: ResenaCreateManyProductoInputEnvelope;
    set?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[];
    disconnect?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[];
    delete?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[];
    connect?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[];
    update?:
      | ResenaUpdateWithWhereUniqueWithoutProductoInput
      | ResenaUpdateWithWhereUniqueWithoutProductoInput[];
    updateMany?:
      | ResenaUpdateManyWithWhereWithoutProductoInput
      | ResenaUpdateManyWithWhereWithoutProductoInput[];
    deleteMany?: ResenaScalarWhereInput | ResenaScalarWhereInput[];
  };

  export type FavoritoUpdateManyWithoutProductoNestedInput = {
    create?:
      | XOR<
          FavoritoCreateWithoutProductoInput,
          FavoritoUncheckedCreateWithoutProductoInput
        >
      | FavoritoCreateWithoutProductoInput[]
      | FavoritoUncheckedCreateWithoutProductoInput[];
    connectOrCreate?:
      | FavoritoCreateOrConnectWithoutProductoInput
      | FavoritoCreateOrConnectWithoutProductoInput[];
    upsert?:
      | FavoritoUpsertWithWhereUniqueWithoutProductoInput
      | FavoritoUpsertWithWhereUniqueWithoutProductoInput[];
    createMany?: FavoritoCreateManyProductoInputEnvelope;
    set?: FavoritoWhereUniqueInput | FavoritoWhereUniqueInput[];
    disconnect?: FavoritoWhereUniqueInput | FavoritoWhereUniqueInput[];
    delete?: FavoritoWhereUniqueInput | FavoritoWhereUniqueInput[];
    connect?: FavoritoWhereUniqueInput | FavoritoWhereUniqueInput[];
    update?:
      | FavoritoUpdateWithWhereUniqueWithoutProductoInput
      | FavoritoUpdateWithWhereUniqueWithoutProductoInput[];
    updateMany?:
      | FavoritoUpdateManyWithWhereWithoutProductoInput
      | FavoritoUpdateManyWithWhereWithoutProductoInput[];
    deleteMany?: FavoritoScalarWhereInput | FavoritoScalarWhereInput[];
  };

  export type ItemCarritoUpdateManyWithoutProductoNestedInput = {
    create?:
      | XOR<
          ItemCarritoCreateWithoutProductoInput,
          ItemCarritoUncheckedCreateWithoutProductoInput
        >
      | ItemCarritoCreateWithoutProductoInput[]
      | ItemCarritoUncheckedCreateWithoutProductoInput[];
    connectOrCreate?:
      | ItemCarritoCreateOrConnectWithoutProductoInput
      | ItemCarritoCreateOrConnectWithoutProductoInput[];
    upsert?:
      | ItemCarritoUpsertWithWhereUniqueWithoutProductoInput
      | ItemCarritoUpsertWithWhereUniqueWithoutProductoInput[];
    createMany?: ItemCarritoCreateManyProductoInputEnvelope;
    set?: ItemCarritoWhereUniqueInput | ItemCarritoWhereUniqueInput[];
    disconnect?: ItemCarritoWhereUniqueInput | ItemCarritoWhereUniqueInput[];
    delete?: ItemCarritoWhereUniqueInput | ItemCarritoWhereUniqueInput[];
    connect?: ItemCarritoWhereUniqueInput | ItemCarritoWhereUniqueInput[];
    update?:
      | ItemCarritoUpdateWithWhereUniqueWithoutProductoInput
      | ItemCarritoUpdateWithWhereUniqueWithoutProductoInput[];
    updateMany?:
      | ItemCarritoUpdateManyWithWhereWithoutProductoInput
      | ItemCarritoUpdateManyWithWhereWithoutProductoInput[];
    deleteMany?: ItemCarritoScalarWhereInput | ItemCarritoScalarWhereInput[];
  };

  export type ProductoImagenUncheckedUpdateManyWithoutProductoNestedInput = {
    create?:
      | XOR<
          ProductoImagenCreateWithoutProductoInput,
          ProductoImagenUncheckedCreateWithoutProductoInput
        >
      | ProductoImagenCreateWithoutProductoInput[]
      | ProductoImagenUncheckedCreateWithoutProductoInput[];
    connectOrCreate?:
      | ProductoImagenCreateOrConnectWithoutProductoInput
      | ProductoImagenCreateOrConnectWithoutProductoInput[];
    upsert?:
      | ProductoImagenUpsertWithWhereUniqueWithoutProductoInput
      | ProductoImagenUpsertWithWhereUniqueWithoutProductoInput[];
    createMany?: ProductoImagenCreateManyProductoInputEnvelope;
    set?: ProductoImagenWhereUniqueInput | ProductoImagenWhereUniqueInput[];
    disconnect?:
      | ProductoImagenWhereUniqueInput
      | ProductoImagenWhereUniqueInput[];
    delete?: ProductoImagenWhereUniqueInput | ProductoImagenWhereUniqueInput[];
    connect?: ProductoImagenWhereUniqueInput | ProductoImagenWhereUniqueInput[];
    update?:
      | ProductoImagenUpdateWithWhereUniqueWithoutProductoInput
      | ProductoImagenUpdateWithWhereUniqueWithoutProductoInput[];
    updateMany?:
      | ProductoImagenUpdateManyWithWhereWithoutProductoInput
      | ProductoImagenUpdateManyWithWhereWithoutProductoInput[];
    deleteMany?:
      | ProductoImagenScalarWhereInput
      | ProductoImagenScalarWhereInput[];
  };

  export type ResenaUncheckedUpdateManyWithoutProductoNestedInput = {
    create?:
      | XOR<
          ResenaCreateWithoutProductoInput,
          ResenaUncheckedCreateWithoutProductoInput
        >
      | ResenaCreateWithoutProductoInput[]
      | ResenaUncheckedCreateWithoutProductoInput[];
    connectOrCreate?:
      | ResenaCreateOrConnectWithoutProductoInput
      | ResenaCreateOrConnectWithoutProductoInput[];
    upsert?:
      | ResenaUpsertWithWhereUniqueWithoutProductoInput
      | ResenaUpsertWithWhereUniqueWithoutProductoInput[];
    createMany?: ResenaCreateManyProductoInputEnvelope;
    set?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[];
    disconnect?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[];
    delete?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[];
    connect?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[];
    update?:
      | ResenaUpdateWithWhereUniqueWithoutProductoInput
      | ResenaUpdateWithWhereUniqueWithoutProductoInput[];
    updateMany?:
      | ResenaUpdateManyWithWhereWithoutProductoInput
      | ResenaUpdateManyWithWhereWithoutProductoInput[];
    deleteMany?: ResenaScalarWhereInput | ResenaScalarWhereInput[];
  };

  export type FavoritoUncheckedUpdateManyWithoutProductoNestedInput = {
    create?:
      | XOR<
          FavoritoCreateWithoutProductoInput,
          FavoritoUncheckedCreateWithoutProductoInput
        >
      | FavoritoCreateWithoutProductoInput[]
      | FavoritoUncheckedCreateWithoutProductoInput[];
    connectOrCreate?:
      | FavoritoCreateOrConnectWithoutProductoInput
      | FavoritoCreateOrConnectWithoutProductoInput[];
    upsert?:
      | FavoritoUpsertWithWhereUniqueWithoutProductoInput
      | FavoritoUpsertWithWhereUniqueWithoutProductoInput[];
    createMany?: FavoritoCreateManyProductoInputEnvelope;
    set?: FavoritoWhereUniqueInput | FavoritoWhereUniqueInput[];
    disconnect?: FavoritoWhereUniqueInput | FavoritoWhereUniqueInput[];
    delete?: FavoritoWhereUniqueInput | FavoritoWhereUniqueInput[];
    connect?: FavoritoWhereUniqueInput | FavoritoWhereUniqueInput[];
    update?:
      | FavoritoUpdateWithWhereUniqueWithoutProductoInput
      | FavoritoUpdateWithWhereUniqueWithoutProductoInput[];
    updateMany?:
      | FavoritoUpdateManyWithWhereWithoutProductoInput
      | FavoritoUpdateManyWithWhereWithoutProductoInput[];
    deleteMany?: FavoritoScalarWhereInput | FavoritoScalarWhereInput[];
  };

  export type ItemCarritoUncheckedUpdateManyWithoutProductoNestedInput = {
    create?:
      | XOR<
          ItemCarritoCreateWithoutProductoInput,
          ItemCarritoUncheckedCreateWithoutProductoInput
        >
      | ItemCarritoCreateWithoutProductoInput[]
      | ItemCarritoUncheckedCreateWithoutProductoInput[];
    connectOrCreate?:
      | ItemCarritoCreateOrConnectWithoutProductoInput
      | ItemCarritoCreateOrConnectWithoutProductoInput[];
    upsert?:
      | ItemCarritoUpsertWithWhereUniqueWithoutProductoInput
      | ItemCarritoUpsertWithWhereUniqueWithoutProductoInput[];
    createMany?: ItemCarritoCreateManyProductoInputEnvelope;
    set?: ItemCarritoWhereUniqueInput | ItemCarritoWhereUniqueInput[];
    disconnect?: ItemCarritoWhereUniqueInput | ItemCarritoWhereUniqueInput[];
    delete?: ItemCarritoWhereUniqueInput | ItemCarritoWhereUniqueInput[];
    connect?: ItemCarritoWhereUniqueInput | ItemCarritoWhereUniqueInput[];
    update?:
      | ItemCarritoUpdateWithWhereUniqueWithoutProductoInput
      | ItemCarritoUpdateWithWhereUniqueWithoutProductoInput[];
    updateMany?:
      | ItemCarritoUpdateManyWithWhereWithoutProductoInput
      | ItemCarritoUpdateManyWithWhereWithoutProductoInput[];
    deleteMany?: ItemCarritoScalarWhereInput | ItemCarritoScalarWhereInput[];
  };

  export type ProductoCreateNestedOneWithoutImagenesInput = {
    create?: XOR<
      ProductoCreateWithoutImagenesInput,
      ProductoUncheckedCreateWithoutImagenesInput
    >;
    connectOrCreate?: ProductoCreateOrConnectWithoutImagenesInput;
    connect?: ProductoWhereUniqueInput;
  };

  export type ProductoUpdateOneRequiredWithoutImagenesNestedInput = {
    create?: XOR<
      ProductoCreateWithoutImagenesInput,
      ProductoUncheckedCreateWithoutImagenesInput
    >;
    connectOrCreate?: ProductoCreateOrConnectWithoutImagenesInput;
    upsert?: ProductoUpsertWithoutImagenesInput;
    connect?: ProductoWhereUniqueInput;
    update?: XOR<
      XOR<
        ProductoUpdateToOneWithWhereWithoutImagenesInput,
        ProductoUpdateWithoutImagenesInput
      >,
      ProductoUncheckedUpdateWithoutImagenesInput
    >;
  };

  export type ProductoCreateNestedManyWithoutMarcaInput = {
    create?:
      | XOR<
          ProductoCreateWithoutMarcaInput,
          ProductoUncheckedCreateWithoutMarcaInput
        >
      | ProductoCreateWithoutMarcaInput[]
      | ProductoUncheckedCreateWithoutMarcaInput[];
    connectOrCreate?:
      | ProductoCreateOrConnectWithoutMarcaInput
      | ProductoCreateOrConnectWithoutMarcaInput[];
    createMany?: ProductoCreateManyMarcaInputEnvelope;
    connect?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[];
  };

  export type ProductoUncheckedCreateNestedManyWithoutMarcaInput = {
    create?:
      | XOR<
          ProductoCreateWithoutMarcaInput,
          ProductoUncheckedCreateWithoutMarcaInput
        >
      | ProductoCreateWithoutMarcaInput[]
      | ProductoUncheckedCreateWithoutMarcaInput[];
    connectOrCreate?:
      | ProductoCreateOrConnectWithoutMarcaInput
      | ProductoCreateOrConnectWithoutMarcaInput[];
    createMany?: ProductoCreateManyMarcaInputEnvelope;
    connect?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[];
  };

  export type ProductoUpdateManyWithoutMarcaNestedInput = {
    create?:
      | XOR<
          ProductoCreateWithoutMarcaInput,
          ProductoUncheckedCreateWithoutMarcaInput
        >
      | ProductoCreateWithoutMarcaInput[]
      | ProductoUncheckedCreateWithoutMarcaInput[];
    connectOrCreate?:
      | ProductoCreateOrConnectWithoutMarcaInput
      | ProductoCreateOrConnectWithoutMarcaInput[];
    upsert?:
      | ProductoUpsertWithWhereUniqueWithoutMarcaInput
      | ProductoUpsertWithWhereUniqueWithoutMarcaInput[];
    createMany?: ProductoCreateManyMarcaInputEnvelope;
    set?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[];
    disconnect?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[];
    delete?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[];
    connect?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[];
    update?:
      | ProductoUpdateWithWhereUniqueWithoutMarcaInput
      | ProductoUpdateWithWhereUniqueWithoutMarcaInput[];
    updateMany?:
      | ProductoUpdateManyWithWhereWithoutMarcaInput
      | ProductoUpdateManyWithWhereWithoutMarcaInput[];
    deleteMany?: ProductoScalarWhereInput | ProductoScalarWhereInput[];
  };

  export type ProductoUncheckedUpdateManyWithoutMarcaNestedInput = {
    create?:
      | XOR<
          ProductoCreateWithoutMarcaInput,
          ProductoUncheckedCreateWithoutMarcaInput
        >
      | ProductoCreateWithoutMarcaInput[]
      | ProductoUncheckedCreateWithoutMarcaInput[];
    connectOrCreate?:
      | ProductoCreateOrConnectWithoutMarcaInput
      | ProductoCreateOrConnectWithoutMarcaInput[];
    upsert?:
      | ProductoUpsertWithWhereUniqueWithoutMarcaInput
      | ProductoUpsertWithWhereUniqueWithoutMarcaInput[];
    createMany?: ProductoCreateManyMarcaInputEnvelope;
    set?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[];
    disconnect?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[];
    delete?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[];
    connect?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[];
    update?:
      | ProductoUpdateWithWhereUniqueWithoutMarcaInput
      | ProductoUpdateWithWhereUniqueWithoutMarcaInput[];
    updateMany?:
      | ProductoUpdateManyWithWhereWithoutMarcaInput
      | ProductoUpdateManyWithWhereWithoutMarcaInput[];
    deleteMany?: ProductoScalarWhereInput | ProductoScalarWhereInput[];
  };

  export type CategoriaCreateNestedOneWithoutHijosInput = {
    create?: XOR<
      CategoriaCreateWithoutHijosInput,
      CategoriaUncheckedCreateWithoutHijosInput
    >;
    connectOrCreate?: CategoriaCreateOrConnectWithoutHijosInput;
    connect?: CategoriaWhereUniqueInput;
  };

  export type CategoriaCreateNestedManyWithoutParentInput = {
    create?:
      | XOR<
          CategoriaCreateWithoutParentInput,
          CategoriaUncheckedCreateWithoutParentInput
        >
      | CategoriaCreateWithoutParentInput[]
      | CategoriaUncheckedCreateWithoutParentInput[];
    connectOrCreate?:
      | CategoriaCreateOrConnectWithoutParentInput
      | CategoriaCreateOrConnectWithoutParentInput[];
    createMany?: CategoriaCreateManyParentInputEnvelope;
    connect?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[];
  };

  export type ProductoCreateNestedManyWithoutCategoriaInput = {
    create?:
      | XOR<
          ProductoCreateWithoutCategoriaInput,
          ProductoUncheckedCreateWithoutCategoriaInput
        >
      | ProductoCreateWithoutCategoriaInput[]
      | ProductoUncheckedCreateWithoutCategoriaInput[];
    connectOrCreate?:
      | ProductoCreateOrConnectWithoutCategoriaInput
      | ProductoCreateOrConnectWithoutCategoriaInput[];
    createMany?: ProductoCreateManyCategoriaInputEnvelope;
    connect?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[];
  };

  export type CategoriaUncheckedCreateNestedManyWithoutParentInput = {
    create?:
      | XOR<
          CategoriaCreateWithoutParentInput,
          CategoriaUncheckedCreateWithoutParentInput
        >
      | CategoriaCreateWithoutParentInput[]
      | CategoriaUncheckedCreateWithoutParentInput[];
    connectOrCreate?:
      | CategoriaCreateOrConnectWithoutParentInput
      | CategoriaCreateOrConnectWithoutParentInput[];
    createMany?: CategoriaCreateManyParentInputEnvelope;
    connect?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[];
  };

  export type ProductoUncheckedCreateNestedManyWithoutCategoriaInput = {
    create?:
      | XOR<
          ProductoCreateWithoutCategoriaInput,
          ProductoUncheckedCreateWithoutCategoriaInput
        >
      | ProductoCreateWithoutCategoriaInput[]
      | ProductoUncheckedCreateWithoutCategoriaInput[];
    connectOrCreate?:
      | ProductoCreateOrConnectWithoutCategoriaInput
      | ProductoCreateOrConnectWithoutCategoriaInput[];
    createMany?: ProductoCreateManyCategoriaInputEnvelope;
    connect?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[];
  };

  export type CategoriaUpdateOneWithoutHijosNestedInput = {
    create?: XOR<
      CategoriaCreateWithoutHijosInput,
      CategoriaUncheckedCreateWithoutHijosInput
    >;
    connectOrCreate?: CategoriaCreateOrConnectWithoutHijosInput;
    upsert?: CategoriaUpsertWithoutHijosInput;
    disconnect?: CategoriaWhereInput | boolean;
    delete?: CategoriaWhereInput | boolean;
    connect?: CategoriaWhereUniqueInput;
    update?: XOR<
      XOR<
        CategoriaUpdateToOneWithWhereWithoutHijosInput,
        CategoriaUpdateWithoutHijosInput
      >,
      CategoriaUncheckedUpdateWithoutHijosInput
    >;
  };

  export type CategoriaUpdateManyWithoutParentNestedInput = {
    create?:
      | XOR<
          CategoriaCreateWithoutParentInput,
          CategoriaUncheckedCreateWithoutParentInput
        >
      | CategoriaCreateWithoutParentInput[]
      | CategoriaUncheckedCreateWithoutParentInput[];
    connectOrCreate?:
      | CategoriaCreateOrConnectWithoutParentInput
      | CategoriaCreateOrConnectWithoutParentInput[];
    upsert?:
      | CategoriaUpsertWithWhereUniqueWithoutParentInput
      | CategoriaUpsertWithWhereUniqueWithoutParentInput[];
    createMany?: CategoriaCreateManyParentInputEnvelope;
    set?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[];
    disconnect?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[];
    delete?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[];
    connect?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[];
    update?:
      | CategoriaUpdateWithWhereUniqueWithoutParentInput
      | CategoriaUpdateWithWhereUniqueWithoutParentInput[];
    updateMany?:
      | CategoriaUpdateManyWithWhereWithoutParentInput
      | CategoriaUpdateManyWithWhereWithoutParentInput[];
    deleteMany?: CategoriaScalarWhereInput | CategoriaScalarWhereInput[];
  };

  export type ProductoUpdateManyWithoutCategoriaNestedInput = {
    create?:
      | XOR<
          ProductoCreateWithoutCategoriaInput,
          ProductoUncheckedCreateWithoutCategoriaInput
        >
      | ProductoCreateWithoutCategoriaInput[]
      | ProductoUncheckedCreateWithoutCategoriaInput[];
    connectOrCreate?:
      | ProductoCreateOrConnectWithoutCategoriaInput
      | ProductoCreateOrConnectWithoutCategoriaInput[];
    upsert?:
      | ProductoUpsertWithWhereUniqueWithoutCategoriaInput
      | ProductoUpsertWithWhereUniqueWithoutCategoriaInput[];
    createMany?: ProductoCreateManyCategoriaInputEnvelope;
    set?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[];
    disconnect?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[];
    delete?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[];
    connect?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[];
    update?:
      | ProductoUpdateWithWhereUniqueWithoutCategoriaInput
      | ProductoUpdateWithWhereUniqueWithoutCategoriaInput[];
    updateMany?:
      | ProductoUpdateManyWithWhereWithoutCategoriaInput
      | ProductoUpdateManyWithWhereWithoutCategoriaInput[];
    deleteMany?: ProductoScalarWhereInput | ProductoScalarWhereInput[];
  };

  export type CategoriaUncheckedUpdateManyWithoutParentNestedInput = {
    create?:
      | XOR<
          CategoriaCreateWithoutParentInput,
          CategoriaUncheckedCreateWithoutParentInput
        >
      | CategoriaCreateWithoutParentInput[]
      | CategoriaUncheckedCreateWithoutParentInput[];
    connectOrCreate?:
      | CategoriaCreateOrConnectWithoutParentInput
      | CategoriaCreateOrConnectWithoutParentInput[];
    upsert?:
      | CategoriaUpsertWithWhereUniqueWithoutParentInput
      | CategoriaUpsertWithWhereUniqueWithoutParentInput[];
    createMany?: CategoriaCreateManyParentInputEnvelope;
    set?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[];
    disconnect?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[];
    delete?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[];
    connect?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[];
    update?:
      | CategoriaUpdateWithWhereUniqueWithoutParentInput
      | CategoriaUpdateWithWhereUniqueWithoutParentInput[];
    updateMany?:
      | CategoriaUpdateManyWithWhereWithoutParentInput
      | CategoriaUpdateManyWithWhereWithoutParentInput[];
    deleteMany?: CategoriaScalarWhereInput | CategoriaScalarWhereInput[];
  };

  export type ProductoUncheckedUpdateManyWithoutCategoriaNestedInput = {
    create?:
      | XOR<
          ProductoCreateWithoutCategoriaInput,
          ProductoUncheckedCreateWithoutCategoriaInput
        >
      | ProductoCreateWithoutCategoriaInput[]
      | ProductoUncheckedCreateWithoutCategoriaInput[];
    connectOrCreate?:
      | ProductoCreateOrConnectWithoutCategoriaInput
      | ProductoCreateOrConnectWithoutCategoriaInput[];
    upsert?:
      | ProductoUpsertWithWhereUniqueWithoutCategoriaInput
      | ProductoUpsertWithWhereUniqueWithoutCategoriaInput[];
    createMany?: ProductoCreateManyCategoriaInputEnvelope;
    set?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[];
    disconnect?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[];
    delete?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[];
    connect?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[];
    update?:
      | ProductoUpdateWithWhereUniqueWithoutCategoriaInput
      | ProductoUpdateWithWhereUniqueWithoutCategoriaInput[];
    updateMany?:
      | ProductoUpdateManyWithWhereWithoutCategoriaInput
      | ProductoUpdateManyWithWhereWithoutCategoriaInput[];
    deleteMany?: ProductoScalarWhereInput | ProductoScalarWhereInput[];
  };

  export type UsuarioCreateNestedOneWithoutOrdenesInput = {
    create?: XOR<
      UsuarioCreateWithoutOrdenesInput,
      UsuarioUncheckedCreateWithoutOrdenesInput
    >;
    connectOrCreate?: UsuarioCreateOrConnectWithoutOrdenesInput;
    connect?: UsuarioWhereUniqueInput;
  };

  export type DireccionCreateNestedOneWithoutOrdenesEnvioInput = {
    create?: XOR<
      DireccionCreateWithoutOrdenesEnvioInput,
      DireccionUncheckedCreateWithoutOrdenesEnvioInput
    >;
    connectOrCreate?: DireccionCreateOrConnectWithoutOrdenesEnvioInput;
    connect?: DireccionWhereUniqueInput;
  };

  export type DireccionCreateNestedOneWithoutOrdenesFacturacionInput = {
    create?: XOR<
      DireccionCreateWithoutOrdenesFacturacionInput,
      DireccionUncheckedCreateWithoutOrdenesFacturacionInput
    >;
    connectOrCreate?: DireccionCreateOrConnectWithoutOrdenesFacturacionInput;
    connect?: DireccionWhereUniqueInput;
  };

  export type ItemOrdenCreateNestedManyWithoutOrdenInput = {
    create?:
      | XOR<
          ItemOrdenCreateWithoutOrdenInput,
          ItemOrdenUncheckedCreateWithoutOrdenInput
        >
      | ItemOrdenCreateWithoutOrdenInput[]
      | ItemOrdenUncheckedCreateWithoutOrdenInput[];
    connectOrCreate?:
      | ItemOrdenCreateOrConnectWithoutOrdenInput
      | ItemOrdenCreateOrConnectWithoutOrdenInput[];
    createMany?: ItemOrdenCreateManyOrdenInputEnvelope;
    connect?: ItemOrdenWhereUniqueInput | ItemOrdenWhereUniqueInput[];
  };

  export type ItemOrdenUncheckedCreateNestedManyWithoutOrdenInput = {
    create?:
      | XOR<
          ItemOrdenCreateWithoutOrdenInput,
          ItemOrdenUncheckedCreateWithoutOrdenInput
        >
      | ItemOrdenCreateWithoutOrdenInput[]
      | ItemOrdenUncheckedCreateWithoutOrdenInput[];
    connectOrCreate?:
      | ItemOrdenCreateOrConnectWithoutOrdenInput
      | ItemOrdenCreateOrConnectWithoutOrdenInput[];
    createMany?: ItemOrdenCreateManyOrdenInputEnvelope;
    connect?: ItemOrdenWhereUniqueInput | ItemOrdenWhereUniqueInput[];
  };

  export type EnumEstadoOrdenFieldUpdateOperationsInput = {
    set?: $Enums.EstadoOrden;
  };

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null;
  };

  export type UsuarioUpdateOneRequiredWithoutOrdenesNestedInput = {
    create?: XOR<
      UsuarioCreateWithoutOrdenesInput,
      UsuarioUncheckedCreateWithoutOrdenesInput
    >;
    connectOrCreate?: UsuarioCreateOrConnectWithoutOrdenesInput;
    upsert?: UsuarioUpsertWithoutOrdenesInput;
    connect?: UsuarioWhereUniqueInput;
    update?: XOR<
      XOR<
        UsuarioUpdateToOneWithWhereWithoutOrdenesInput,
        UsuarioUpdateWithoutOrdenesInput
      >,
      UsuarioUncheckedUpdateWithoutOrdenesInput
    >;
  };

  export type DireccionUpdateOneWithoutOrdenesEnvioNestedInput = {
    create?: XOR<
      DireccionCreateWithoutOrdenesEnvioInput,
      DireccionUncheckedCreateWithoutOrdenesEnvioInput
    >;
    connectOrCreate?: DireccionCreateOrConnectWithoutOrdenesEnvioInput;
    upsert?: DireccionUpsertWithoutOrdenesEnvioInput;
    disconnect?: DireccionWhereInput | boolean;
    delete?: DireccionWhereInput | boolean;
    connect?: DireccionWhereUniqueInput;
    update?: XOR<
      XOR<
        DireccionUpdateToOneWithWhereWithoutOrdenesEnvioInput,
        DireccionUpdateWithoutOrdenesEnvioInput
      >,
      DireccionUncheckedUpdateWithoutOrdenesEnvioInput
    >;
  };

  export type DireccionUpdateOneWithoutOrdenesFacturacionNestedInput = {
    create?: XOR<
      DireccionCreateWithoutOrdenesFacturacionInput,
      DireccionUncheckedCreateWithoutOrdenesFacturacionInput
    >;
    connectOrCreate?: DireccionCreateOrConnectWithoutOrdenesFacturacionInput;
    upsert?: DireccionUpsertWithoutOrdenesFacturacionInput;
    disconnect?: DireccionWhereInput | boolean;
    delete?: DireccionWhereInput | boolean;
    connect?: DireccionWhereUniqueInput;
    update?: XOR<
      XOR<
        DireccionUpdateToOneWithWhereWithoutOrdenesFacturacionInput,
        DireccionUpdateWithoutOrdenesFacturacionInput
      >,
      DireccionUncheckedUpdateWithoutOrdenesFacturacionInput
    >;
  };

  export type ItemOrdenUpdateManyWithoutOrdenNestedInput = {
    create?:
      | XOR<
          ItemOrdenCreateWithoutOrdenInput,
          ItemOrdenUncheckedCreateWithoutOrdenInput
        >
      | ItemOrdenCreateWithoutOrdenInput[]
      | ItemOrdenUncheckedCreateWithoutOrdenInput[];
    connectOrCreate?:
      | ItemOrdenCreateOrConnectWithoutOrdenInput
      | ItemOrdenCreateOrConnectWithoutOrdenInput[];
    upsert?:
      | ItemOrdenUpsertWithWhereUniqueWithoutOrdenInput
      | ItemOrdenUpsertWithWhereUniqueWithoutOrdenInput[];
    createMany?: ItemOrdenCreateManyOrdenInputEnvelope;
    set?: ItemOrdenWhereUniqueInput | ItemOrdenWhereUniqueInput[];
    disconnect?: ItemOrdenWhereUniqueInput | ItemOrdenWhereUniqueInput[];
    delete?: ItemOrdenWhereUniqueInput | ItemOrdenWhereUniqueInput[];
    connect?: ItemOrdenWhereUniqueInput | ItemOrdenWhereUniqueInput[];
    update?:
      | ItemOrdenUpdateWithWhereUniqueWithoutOrdenInput
      | ItemOrdenUpdateWithWhereUniqueWithoutOrdenInput[];
    updateMany?:
      | ItemOrdenUpdateManyWithWhereWithoutOrdenInput
      | ItemOrdenUpdateManyWithWhereWithoutOrdenInput[];
    deleteMany?: ItemOrdenScalarWhereInput | ItemOrdenScalarWhereInput[];
  };

  export type ItemOrdenUncheckedUpdateManyWithoutOrdenNestedInput = {
    create?:
      | XOR<
          ItemOrdenCreateWithoutOrdenInput,
          ItemOrdenUncheckedCreateWithoutOrdenInput
        >
      | ItemOrdenCreateWithoutOrdenInput[]
      | ItemOrdenUncheckedCreateWithoutOrdenInput[];
    connectOrCreate?:
      | ItemOrdenCreateOrConnectWithoutOrdenInput
      | ItemOrdenCreateOrConnectWithoutOrdenInput[];
    upsert?:
      | ItemOrdenUpsertWithWhereUniqueWithoutOrdenInput
      | ItemOrdenUpsertWithWhereUniqueWithoutOrdenInput[];
    createMany?: ItemOrdenCreateManyOrdenInputEnvelope;
    set?: ItemOrdenWhereUniqueInput | ItemOrdenWhereUniqueInput[];
    disconnect?: ItemOrdenWhereUniqueInput | ItemOrdenWhereUniqueInput[];
    delete?: ItemOrdenWhereUniqueInput | ItemOrdenWhereUniqueInput[];
    connect?: ItemOrdenWhereUniqueInput | ItemOrdenWhereUniqueInput[];
    update?:
      | ItemOrdenUpdateWithWhereUniqueWithoutOrdenInput
      | ItemOrdenUpdateWithWhereUniqueWithoutOrdenInput[];
    updateMany?:
      | ItemOrdenUpdateManyWithWhereWithoutOrdenInput
      | ItemOrdenUpdateManyWithWhereWithoutOrdenInput[];
    deleteMany?: ItemOrdenScalarWhereInput | ItemOrdenScalarWhereInput[];
  };

  export type OrdenCreateNestedOneWithoutItemsInput = {
    create?: XOR<
      OrdenCreateWithoutItemsInput,
      OrdenUncheckedCreateWithoutItemsInput
    >;
    connectOrCreate?: OrdenCreateOrConnectWithoutItemsInput;
    connect?: OrdenWhereUniqueInput;
  };

  export type EnumTipoItemOrdenFieldUpdateOperationsInput = {
    set?: $Enums.TipoItemOrden;
  };

  export type OrdenUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<
      OrdenCreateWithoutItemsInput,
      OrdenUncheckedCreateWithoutItemsInput
    >;
    connectOrCreate?: OrdenCreateOrConnectWithoutItemsInput;
    upsert?: OrdenUpsertWithoutItemsInput;
    connect?: OrdenWhereUniqueInput;
    update?: XOR<
      XOR<
        OrdenUpdateToOneWithWhereWithoutItemsInput,
        OrdenUpdateWithoutItemsInput
      >,
      OrdenUncheckedUpdateWithoutItemsInput
    >;
  };

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string;
    increment?: Decimal | DecimalJsLike | number | string;
    decrement?: Decimal | DecimalJsLike | number | string;
    multiply?: Decimal | DecimalJsLike | number | string;
    divide?: Decimal | DecimalJsLike | number | string;
  };

  export type OrdenCreateNestedManyWithoutDireccionEnvioInput = {
    create?:
      | XOR<
          OrdenCreateWithoutDireccionEnvioInput,
          OrdenUncheckedCreateWithoutDireccionEnvioInput
        >
      | OrdenCreateWithoutDireccionEnvioInput[]
      | OrdenUncheckedCreateWithoutDireccionEnvioInput[];
    connectOrCreate?:
      | OrdenCreateOrConnectWithoutDireccionEnvioInput
      | OrdenCreateOrConnectWithoutDireccionEnvioInput[];
    createMany?: OrdenCreateManyDireccionEnvioInputEnvelope;
    connect?: OrdenWhereUniqueInput | OrdenWhereUniqueInput[];
  };

  export type OrdenCreateNestedManyWithoutDireccionFacturacionInput = {
    create?:
      | XOR<
          OrdenCreateWithoutDireccionFacturacionInput,
          OrdenUncheckedCreateWithoutDireccionFacturacionInput
        >
      | OrdenCreateWithoutDireccionFacturacionInput[]
      | OrdenUncheckedCreateWithoutDireccionFacturacionInput[];
    connectOrCreate?:
      | OrdenCreateOrConnectWithoutDireccionFacturacionInput
      | OrdenCreateOrConnectWithoutDireccionFacturacionInput[];
    createMany?: OrdenCreateManyDireccionFacturacionInputEnvelope;
    connect?: OrdenWhereUniqueInput | OrdenWhereUniqueInput[];
  };

  export type OrdenUncheckedCreateNestedManyWithoutDireccionEnvioInput = {
    create?:
      | XOR<
          OrdenCreateWithoutDireccionEnvioInput,
          OrdenUncheckedCreateWithoutDireccionEnvioInput
        >
      | OrdenCreateWithoutDireccionEnvioInput[]
      | OrdenUncheckedCreateWithoutDireccionEnvioInput[];
    connectOrCreate?:
      | OrdenCreateOrConnectWithoutDireccionEnvioInput
      | OrdenCreateOrConnectWithoutDireccionEnvioInput[];
    createMany?: OrdenCreateManyDireccionEnvioInputEnvelope;
    connect?: OrdenWhereUniqueInput | OrdenWhereUniqueInput[];
  };

  export type OrdenUncheckedCreateNestedManyWithoutDireccionFacturacionInput = {
    create?:
      | XOR<
          OrdenCreateWithoutDireccionFacturacionInput,
          OrdenUncheckedCreateWithoutDireccionFacturacionInput
        >
      | OrdenCreateWithoutDireccionFacturacionInput[]
      | OrdenUncheckedCreateWithoutDireccionFacturacionInput[];
    connectOrCreate?:
      | OrdenCreateOrConnectWithoutDireccionFacturacionInput
      | OrdenCreateOrConnectWithoutDireccionFacturacionInput[];
    createMany?: OrdenCreateManyDireccionFacturacionInputEnvelope;
    connect?: OrdenWhereUniqueInput | OrdenWhereUniqueInput[];
  };

  export type OrdenUpdateManyWithoutDireccionEnvioNestedInput = {
    create?:
      | XOR<
          OrdenCreateWithoutDireccionEnvioInput,
          OrdenUncheckedCreateWithoutDireccionEnvioInput
        >
      | OrdenCreateWithoutDireccionEnvioInput[]
      | OrdenUncheckedCreateWithoutDireccionEnvioInput[];
    connectOrCreate?:
      | OrdenCreateOrConnectWithoutDireccionEnvioInput
      | OrdenCreateOrConnectWithoutDireccionEnvioInput[];
    upsert?:
      | OrdenUpsertWithWhereUniqueWithoutDireccionEnvioInput
      | OrdenUpsertWithWhereUniqueWithoutDireccionEnvioInput[];
    createMany?: OrdenCreateManyDireccionEnvioInputEnvelope;
    set?: OrdenWhereUniqueInput | OrdenWhereUniqueInput[];
    disconnect?: OrdenWhereUniqueInput | OrdenWhereUniqueInput[];
    delete?: OrdenWhereUniqueInput | OrdenWhereUniqueInput[];
    connect?: OrdenWhereUniqueInput | OrdenWhereUniqueInput[];
    update?:
      | OrdenUpdateWithWhereUniqueWithoutDireccionEnvioInput
      | OrdenUpdateWithWhereUniqueWithoutDireccionEnvioInput[];
    updateMany?:
      | OrdenUpdateManyWithWhereWithoutDireccionEnvioInput
      | OrdenUpdateManyWithWhereWithoutDireccionEnvioInput[];
    deleteMany?: OrdenScalarWhereInput | OrdenScalarWhereInput[];
  };

  export type OrdenUpdateManyWithoutDireccionFacturacionNestedInput = {
    create?:
      | XOR<
          OrdenCreateWithoutDireccionFacturacionInput,
          OrdenUncheckedCreateWithoutDireccionFacturacionInput
        >
      | OrdenCreateWithoutDireccionFacturacionInput[]
      | OrdenUncheckedCreateWithoutDireccionFacturacionInput[];
    connectOrCreate?:
      | OrdenCreateOrConnectWithoutDireccionFacturacionInput
      | OrdenCreateOrConnectWithoutDireccionFacturacionInput[];
    upsert?:
      | OrdenUpsertWithWhereUniqueWithoutDireccionFacturacionInput
      | OrdenUpsertWithWhereUniqueWithoutDireccionFacturacionInput[];
    createMany?: OrdenCreateManyDireccionFacturacionInputEnvelope;
    set?: OrdenWhereUniqueInput | OrdenWhereUniqueInput[];
    disconnect?: OrdenWhereUniqueInput | OrdenWhereUniqueInput[];
    delete?: OrdenWhereUniqueInput | OrdenWhereUniqueInput[];
    connect?: OrdenWhereUniqueInput | OrdenWhereUniqueInput[];
    update?:
      | OrdenUpdateWithWhereUniqueWithoutDireccionFacturacionInput
      | OrdenUpdateWithWhereUniqueWithoutDireccionFacturacionInput[];
    updateMany?:
      | OrdenUpdateManyWithWhereWithoutDireccionFacturacionInput
      | OrdenUpdateManyWithWhereWithoutDireccionFacturacionInput[];
    deleteMany?: OrdenScalarWhereInput | OrdenScalarWhereInput[];
  };

  export type OrdenUncheckedUpdateManyWithoutDireccionEnvioNestedInput = {
    create?:
      | XOR<
          OrdenCreateWithoutDireccionEnvioInput,
          OrdenUncheckedCreateWithoutDireccionEnvioInput
        >
      | OrdenCreateWithoutDireccionEnvioInput[]
      | OrdenUncheckedCreateWithoutDireccionEnvioInput[];
    connectOrCreate?:
      | OrdenCreateOrConnectWithoutDireccionEnvioInput
      | OrdenCreateOrConnectWithoutDireccionEnvioInput[];
    upsert?:
      | OrdenUpsertWithWhereUniqueWithoutDireccionEnvioInput
      | OrdenUpsertWithWhereUniqueWithoutDireccionEnvioInput[];
    createMany?: OrdenCreateManyDireccionEnvioInputEnvelope;
    set?: OrdenWhereUniqueInput | OrdenWhereUniqueInput[];
    disconnect?: OrdenWhereUniqueInput | OrdenWhereUniqueInput[];
    delete?: OrdenWhereUniqueInput | OrdenWhereUniqueInput[];
    connect?: OrdenWhereUniqueInput | OrdenWhereUniqueInput[];
    update?:
      | OrdenUpdateWithWhereUniqueWithoutDireccionEnvioInput
      | OrdenUpdateWithWhereUniqueWithoutDireccionEnvioInput[];
    updateMany?:
      | OrdenUpdateManyWithWhereWithoutDireccionEnvioInput
      | OrdenUpdateManyWithWhereWithoutDireccionEnvioInput[];
    deleteMany?: OrdenScalarWhereInput | OrdenScalarWhereInput[];
  };

  export type OrdenUncheckedUpdateManyWithoutDireccionFacturacionNestedInput = {
    create?:
      | XOR<
          OrdenCreateWithoutDireccionFacturacionInput,
          OrdenUncheckedCreateWithoutDireccionFacturacionInput
        >
      | OrdenCreateWithoutDireccionFacturacionInput[]
      | OrdenUncheckedCreateWithoutDireccionFacturacionInput[];
    connectOrCreate?:
      | OrdenCreateOrConnectWithoutDireccionFacturacionInput
      | OrdenCreateOrConnectWithoutDireccionFacturacionInput[];
    upsert?:
      | OrdenUpsertWithWhereUniqueWithoutDireccionFacturacionInput
      | OrdenUpsertWithWhereUniqueWithoutDireccionFacturacionInput[];
    createMany?: OrdenCreateManyDireccionFacturacionInputEnvelope;
    set?: OrdenWhereUniqueInput | OrdenWhereUniqueInput[];
    disconnect?: OrdenWhereUniqueInput | OrdenWhereUniqueInput[];
    delete?: OrdenWhereUniqueInput | OrdenWhereUniqueInput[];
    connect?: OrdenWhereUniqueInput | OrdenWhereUniqueInput[];
    update?:
      | OrdenUpdateWithWhereUniqueWithoutDireccionFacturacionInput
      | OrdenUpdateWithWhereUniqueWithoutDireccionFacturacionInput[];
    updateMany?:
      | OrdenUpdateManyWithWhereWithoutDireccionFacturacionInput
      | OrdenUpdateManyWithWhereWithoutDireccionFacturacionInput[];
    deleteMany?: OrdenScalarWhereInput | OrdenScalarWhereInput[];
  };

  export type CursoCreateNestedOneWithoutResenasInput = {
    create?: XOR<
      CursoCreateWithoutResenasInput,
      CursoUncheckedCreateWithoutResenasInput
    >;
    connectOrCreate?: CursoCreateOrConnectWithoutResenasInput;
    connect?: CursoWhereUniqueInput;
  };

  export type ProductoCreateNestedOneWithoutResenasInput = {
    create?: XOR<
      ProductoCreateWithoutResenasInput,
      ProductoUncheckedCreateWithoutResenasInput
    >;
    connectOrCreate?: ProductoCreateOrConnectWithoutResenasInput;
    connect?: ProductoWhereUniqueInput;
  };

  export type UsuarioCreateNestedOneWithoutResenasInput = {
    create?: XOR<
      UsuarioCreateWithoutResenasInput,
      UsuarioUncheckedCreateWithoutResenasInput
    >;
    connectOrCreate?: UsuarioCreateOrConnectWithoutResenasInput;
    connect?: UsuarioWhereUniqueInput;
  };

  export type ResenaRespuestaCreateNestedManyWithoutResenaInput = {
    create?:
      | XOR<
          ResenaRespuestaCreateWithoutResenaInput,
          ResenaRespuestaUncheckedCreateWithoutResenaInput
        >
      | ResenaRespuestaCreateWithoutResenaInput[]
      | ResenaRespuestaUncheckedCreateWithoutResenaInput[];
    connectOrCreate?:
      | ResenaRespuestaCreateOrConnectWithoutResenaInput
      | ResenaRespuestaCreateOrConnectWithoutResenaInput[];
    createMany?: ResenaRespuestaCreateManyResenaInputEnvelope;
    connect?:
      | ResenaRespuestaWhereUniqueInput
      | ResenaRespuestaWhereUniqueInput[];
  };

  export type ResenaLikeCreateNestedManyWithoutResenaInput = {
    create?:
      | XOR<
          ResenaLikeCreateWithoutResenaInput,
          ResenaLikeUncheckedCreateWithoutResenaInput
        >
      | ResenaLikeCreateWithoutResenaInput[]
      | ResenaLikeUncheckedCreateWithoutResenaInput[];
    connectOrCreate?:
      | ResenaLikeCreateOrConnectWithoutResenaInput
      | ResenaLikeCreateOrConnectWithoutResenaInput[];
    createMany?: ResenaLikeCreateManyResenaInputEnvelope;
    connect?: ResenaLikeWhereUniqueInput | ResenaLikeWhereUniqueInput[];
  };

  export type ResenaRespuestaUncheckedCreateNestedManyWithoutResenaInput = {
    create?:
      | XOR<
          ResenaRespuestaCreateWithoutResenaInput,
          ResenaRespuestaUncheckedCreateWithoutResenaInput
        >
      | ResenaRespuestaCreateWithoutResenaInput[]
      | ResenaRespuestaUncheckedCreateWithoutResenaInput[];
    connectOrCreate?:
      | ResenaRespuestaCreateOrConnectWithoutResenaInput
      | ResenaRespuestaCreateOrConnectWithoutResenaInput[];
    createMany?: ResenaRespuestaCreateManyResenaInputEnvelope;
    connect?:
      | ResenaRespuestaWhereUniqueInput
      | ResenaRespuestaWhereUniqueInput[];
  };

  export type ResenaLikeUncheckedCreateNestedManyWithoutResenaInput = {
    create?:
      | XOR<
          ResenaLikeCreateWithoutResenaInput,
          ResenaLikeUncheckedCreateWithoutResenaInput
        >
      | ResenaLikeCreateWithoutResenaInput[]
      | ResenaLikeUncheckedCreateWithoutResenaInput[];
    connectOrCreate?:
      | ResenaLikeCreateOrConnectWithoutResenaInput
      | ResenaLikeCreateOrConnectWithoutResenaInput[];
    createMany?: ResenaLikeCreateManyResenaInputEnvelope;
    connect?: ResenaLikeWhereUniqueInput | ResenaLikeWhereUniqueInput[];
  };

  export type CursoUpdateOneWithoutResenasNestedInput = {
    create?: XOR<
      CursoCreateWithoutResenasInput,
      CursoUncheckedCreateWithoutResenasInput
    >;
    connectOrCreate?: CursoCreateOrConnectWithoutResenasInput;
    upsert?: CursoUpsertWithoutResenasInput;
    disconnect?: CursoWhereInput | boolean;
    delete?: CursoWhereInput | boolean;
    connect?: CursoWhereUniqueInput;
    update?: XOR<
      XOR<
        CursoUpdateToOneWithWhereWithoutResenasInput,
        CursoUpdateWithoutResenasInput
      >,
      CursoUncheckedUpdateWithoutResenasInput
    >;
  };

  export type ProductoUpdateOneWithoutResenasNestedInput = {
    create?: XOR<
      ProductoCreateWithoutResenasInput,
      ProductoUncheckedCreateWithoutResenasInput
    >;
    connectOrCreate?: ProductoCreateOrConnectWithoutResenasInput;
    upsert?: ProductoUpsertWithoutResenasInput;
    disconnect?: ProductoWhereInput | boolean;
    delete?: ProductoWhereInput | boolean;
    connect?: ProductoWhereUniqueInput;
    update?: XOR<
      XOR<
        ProductoUpdateToOneWithWhereWithoutResenasInput,
        ProductoUpdateWithoutResenasInput
      >,
      ProductoUncheckedUpdateWithoutResenasInput
    >;
  };

  export type UsuarioUpdateOneRequiredWithoutResenasNestedInput = {
    create?: XOR<
      UsuarioCreateWithoutResenasInput,
      UsuarioUncheckedCreateWithoutResenasInput
    >;
    connectOrCreate?: UsuarioCreateOrConnectWithoutResenasInput;
    upsert?: UsuarioUpsertWithoutResenasInput;
    connect?: UsuarioWhereUniqueInput;
    update?: XOR<
      XOR<
        UsuarioUpdateToOneWithWhereWithoutResenasInput,
        UsuarioUpdateWithoutResenasInput
      >,
      UsuarioUncheckedUpdateWithoutResenasInput
    >;
  };

  export type ResenaRespuestaUpdateManyWithoutResenaNestedInput = {
    create?:
      | XOR<
          ResenaRespuestaCreateWithoutResenaInput,
          ResenaRespuestaUncheckedCreateWithoutResenaInput
        >
      | ResenaRespuestaCreateWithoutResenaInput[]
      | ResenaRespuestaUncheckedCreateWithoutResenaInput[];
    connectOrCreate?:
      | ResenaRespuestaCreateOrConnectWithoutResenaInput
      | ResenaRespuestaCreateOrConnectWithoutResenaInput[];
    upsert?:
      | ResenaRespuestaUpsertWithWhereUniqueWithoutResenaInput
      | ResenaRespuestaUpsertWithWhereUniqueWithoutResenaInput[];
    createMany?: ResenaRespuestaCreateManyResenaInputEnvelope;
    set?: ResenaRespuestaWhereUniqueInput | ResenaRespuestaWhereUniqueInput[];
    disconnect?:
      | ResenaRespuestaWhereUniqueInput
      | ResenaRespuestaWhereUniqueInput[];
    delete?:
      | ResenaRespuestaWhereUniqueInput
      | ResenaRespuestaWhereUniqueInput[];
    connect?:
      | ResenaRespuestaWhereUniqueInput
      | ResenaRespuestaWhereUniqueInput[];
    update?:
      | ResenaRespuestaUpdateWithWhereUniqueWithoutResenaInput
      | ResenaRespuestaUpdateWithWhereUniqueWithoutResenaInput[];
    updateMany?:
      | ResenaRespuestaUpdateManyWithWhereWithoutResenaInput
      | ResenaRespuestaUpdateManyWithWhereWithoutResenaInput[];
    deleteMany?:
      | ResenaRespuestaScalarWhereInput
      | ResenaRespuestaScalarWhereInput[];
  };

  export type ResenaLikeUpdateManyWithoutResenaNestedInput = {
    create?:
      | XOR<
          ResenaLikeCreateWithoutResenaInput,
          ResenaLikeUncheckedCreateWithoutResenaInput
        >
      | ResenaLikeCreateWithoutResenaInput[]
      | ResenaLikeUncheckedCreateWithoutResenaInput[];
    connectOrCreate?:
      | ResenaLikeCreateOrConnectWithoutResenaInput
      | ResenaLikeCreateOrConnectWithoutResenaInput[];
    upsert?:
      | ResenaLikeUpsertWithWhereUniqueWithoutResenaInput
      | ResenaLikeUpsertWithWhereUniqueWithoutResenaInput[];
    createMany?: ResenaLikeCreateManyResenaInputEnvelope;
    set?: ResenaLikeWhereUniqueInput | ResenaLikeWhereUniqueInput[];
    disconnect?: ResenaLikeWhereUniqueInput | ResenaLikeWhereUniqueInput[];
    delete?: ResenaLikeWhereUniqueInput | ResenaLikeWhereUniqueInput[];
    connect?: ResenaLikeWhereUniqueInput | ResenaLikeWhereUniqueInput[];
    update?:
      | ResenaLikeUpdateWithWhereUniqueWithoutResenaInput
      | ResenaLikeUpdateWithWhereUniqueWithoutResenaInput[];
    updateMany?:
      | ResenaLikeUpdateManyWithWhereWithoutResenaInput
      | ResenaLikeUpdateManyWithWhereWithoutResenaInput[];
    deleteMany?: ResenaLikeScalarWhereInput | ResenaLikeScalarWhereInput[];
  };

  export type ResenaRespuestaUncheckedUpdateManyWithoutResenaNestedInput = {
    create?:
      | XOR<
          ResenaRespuestaCreateWithoutResenaInput,
          ResenaRespuestaUncheckedCreateWithoutResenaInput
        >
      | ResenaRespuestaCreateWithoutResenaInput[]
      | ResenaRespuestaUncheckedCreateWithoutResenaInput[];
    connectOrCreate?:
      | ResenaRespuestaCreateOrConnectWithoutResenaInput
      | ResenaRespuestaCreateOrConnectWithoutResenaInput[];
    upsert?:
      | ResenaRespuestaUpsertWithWhereUniqueWithoutResenaInput
      | ResenaRespuestaUpsertWithWhereUniqueWithoutResenaInput[];
    createMany?: ResenaRespuestaCreateManyResenaInputEnvelope;
    set?: ResenaRespuestaWhereUniqueInput | ResenaRespuestaWhereUniqueInput[];
    disconnect?:
      | ResenaRespuestaWhereUniqueInput
      | ResenaRespuestaWhereUniqueInput[];
    delete?:
      | ResenaRespuestaWhereUniqueInput
      | ResenaRespuestaWhereUniqueInput[];
    connect?:
      | ResenaRespuestaWhereUniqueInput
      | ResenaRespuestaWhereUniqueInput[];
    update?:
      | ResenaRespuestaUpdateWithWhereUniqueWithoutResenaInput
      | ResenaRespuestaUpdateWithWhereUniqueWithoutResenaInput[];
    updateMany?:
      | ResenaRespuestaUpdateManyWithWhereWithoutResenaInput
      | ResenaRespuestaUpdateManyWithWhereWithoutResenaInput[];
    deleteMany?:
      | ResenaRespuestaScalarWhereInput
      | ResenaRespuestaScalarWhereInput[];
  };

  export type ResenaLikeUncheckedUpdateManyWithoutResenaNestedInput = {
    create?:
      | XOR<
          ResenaLikeCreateWithoutResenaInput,
          ResenaLikeUncheckedCreateWithoutResenaInput
        >
      | ResenaLikeCreateWithoutResenaInput[]
      | ResenaLikeUncheckedCreateWithoutResenaInput[];
    connectOrCreate?:
      | ResenaLikeCreateOrConnectWithoutResenaInput
      | ResenaLikeCreateOrConnectWithoutResenaInput[];
    upsert?:
      | ResenaLikeUpsertWithWhereUniqueWithoutResenaInput
      | ResenaLikeUpsertWithWhereUniqueWithoutResenaInput[];
    createMany?: ResenaLikeCreateManyResenaInputEnvelope;
    set?: ResenaLikeWhereUniqueInput | ResenaLikeWhereUniqueInput[];
    disconnect?: ResenaLikeWhereUniqueInput | ResenaLikeWhereUniqueInput[];
    delete?: ResenaLikeWhereUniqueInput | ResenaLikeWhereUniqueInput[];
    connect?: ResenaLikeWhereUniqueInput | ResenaLikeWhereUniqueInput[];
    update?:
      | ResenaLikeUpdateWithWhereUniqueWithoutResenaInput
      | ResenaLikeUpdateWithWhereUniqueWithoutResenaInput[];
    updateMany?:
      | ResenaLikeUpdateManyWithWhereWithoutResenaInput
      | ResenaLikeUpdateManyWithWhereWithoutResenaInput[];
    deleteMany?: ResenaLikeScalarWhereInput | ResenaLikeScalarWhereInput[];
  };

  export type ResenaCreateNestedOneWithoutLikesInput = {
    create?: XOR<
      ResenaCreateWithoutLikesInput,
      ResenaUncheckedCreateWithoutLikesInput
    >;
    connectOrCreate?: ResenaCreateOrConnectWithoutLikesInput;
    connect?: ResenaWhereUniqueInput;
  };

  export type UsuarioCreateNestedOneWithoutResenaLikesInput = {
    create?: XOR<
      UsuarioCreateWithoutResenaLikesInput,
      UsuarioUncheckedCreateWithoutResenaLikesInput
    >;
    connectOrCreate?: UsuarioCreateOrConnectWithoutResenaLikesInput;
    connect?: UsuarioWhereUniqueInput;
  };

  export type EnumTipoLikeFieldUpdateOperationsInput = {
    set?: $Enums.TipoLike;
  };

  export type ResenaUpdateOneRequiredWithoutLikesNestedInput = {
    create?: XOR<
      ResenaCreateWithoutLikesInput,
      ResenaUncheckedCreateWithoutLikesInput
    >;
    connectOrCreate?: ResenaCreateOrConnectWithoutLikesInput;
    upsert?: ResenaUpsertWithoutLikesInput;
    connect?: ResenaWhereUniqueInput;
    update?: XOR<
      XOR<
        ResenaUpdateToOneWithWhereWithoutLikesInput,
        ResenaUpdateWithoutLikesInput
      >,
      ResenaUncheckedUpdateWithoutLikesInput
    >;
  };

  export type UsuarioUpdateOneRequiredWithoutResenaLikesNestedInput = {
    create?: XOR<
      UsuarioCreateWithoutResenaLikesInput,
      UsuarioUncheckedCreateWithoutResenaLikesInput
    >;
    connectOrCreate?: UsuarioCreateOrConnectWithoutResenaLikesInput;
    upsert?: UsuarioUpsertWithoutResenaLikesInput;
    connect?: UsuarioWhereUniqueInput;
    update?: XOR<
      XOR<
        UsuarioUpdateToOneWithWhereWithoutResenaLikesInput,
        UsuarioUpdateWithoutResenaLikesInput
      >,
      UsuarioUncheckedUpdateWithoutResenaLikesInput
    >;
  };

  export type ResenaCreateNestedOneWithoutRespuestasInput = {
    create?: XOR<
      ResenaCreateWithoutRespuestasInput,
      ResenaUncheckedCreateWithoutRespuestasInput
    >;
    connectOrCreate?: ResenaCreateOrConnectWithoutRespuestasInput;
    connect?: ResenaWhereUniqueInput;
  };

  export type UsuarioCreateNestedOneWithoutResenaRespuestasInput = {
    create?: XOR<
      UsuarioCreateWithoutResenaRespuestasInput,
      UsuarioUncheckedCreateWithoutResenaRespuestasInput
    >;
    connectOrCreate?: UsuarioCreateOrConnectWithoutResenaRespuestasInput;
    connect?: UsuarioWhereUniqueInput;
  };

  export type ResenaRespuestaCreateNestedOneWithoutHijosInput = {
    create?: XOR<
      ResenaRespuestaCreateWithoutHijosInput,
      ResenaRespuestaUncheckedCreateWithoutHijosInput
    >;
    connectOrCreate?: ResenaRespuestaCreateOrConnectWithoutHijosInput;
    connect?: ResenaRespuestaWhereUniqueInput;
  };

  export type ResenaRespuestaCreateNestedManyWithoutParentInput = {
    create?:
      | XOR<
          ResenaRespuestaCreateWithoutParentInput,
          ResenaRespuestaUncheckedCreateWithoutParentInput
        >
      | ResenaRespuestaCreateWithoutParentInput[]
      | ResenaRespuestaUncheckedCreateWithoutParentInput[];
    connectOrCreate?:
      | ResenaRespuestaCreateOrConnectWithoutParentInput
      | ResenaRespuestaCreateOrConnectWithoutParentInput[];
    createMany?: ResenaRespuestaCreateManyParentInputEnvelope;
    connect?:
      | ResenaRespuestaWhereUniqueInput
      | ResenaRespuestaWhereUniqueInput[];
  };

  export type ResenaRespuestaUncheckedCreateNestedManyWithoutParentInput = {
    create?:
      | XOR<
          ResenaRespuestaCreateWithoutParentInput,
          ResenaRespuestaUncheckedCreateWithoutParentInput
        >
      | ResenaRespuestaCreateWithoutParentInput[]
      | ResenaRespuestaUncheckedCreateWithoutParentInput[];
    connectOrCreate?:
      | ResenaRespuestaCreateOrConnectWithoutParentInput
      | ResenaRespuestaCreateOrConnectWithoutParentInput[];
    createMany?: ResenaRespuestaCreateManyParentInputEnvelope;
    connect?:
      | ResenaRespuestaWhereUniqueInput
      | ResenaRespuestaWhereUniqueInput[];
  };

  export type ResenaUpdateOneRequiredWithoutRespuestasNestedInput = {
    create?: XOR<
      ResenaCreateWithoutRespuestasInput,
      ResenaUncheckedCreateWithoutRespuestasInput
    >;
    connectOrCreate?: ResenaCreateOrConnectWithoutRespuestasInput;
    upsert?: ResenaUpsertWithoutRespuestasInput;
    connect?: ResenaWhereUniqueInput;
    update?: XOR<
      XOR<
        ResenaUpdateToOneWithWhereWithoutRespuestasInput,
        ResenaUpdateWithoutRespuestasInput
      >,
      ResenaUncheckedUpdateWithoutRespuestasInput
    >;
  };

  export type UsuarioUpdateOneRequiredWithoutResenaRespuestasNestedInput = {
    create?: XOR<
      UsuarioCreateWithoutResenaRespuestasInput,
      UsuarioUncheckedCreateWithoutResenaRespuestasInput
    >;
    connectOrCreate?: UsuarioCreateOrConnectWithoutResenaRespuestasInput;
    upsert?: UsuarioUpsertWithoutResenaRespuestasInput;
    connect?: UsuarioWhereUniqueInput;
    update?: XOR<
      XOR<
        UsuarioUpdateToOneWithWhereWithoutResenaRespuestasInput,
        UsuarioUpdateWithoutResenaRespuestasInput
      >,
      UsuarioUncheckedUpdateWithoutResenaRespuestasInput
    >;
  };

  export type ResenaRespuestaUpdateOneWithoutHijosNestedInput = {
    create?: XOR<
      ResenaRespuestaCreateWithoutHijosInput,
      ResenaRespuestaUncheckedCreateWithoutHijosInput
    >;
    connectOrCreate?: ResenaRespuestaCreateOrConnectWithoutHijosInput;
    upsert?: ResenaRespuestaUpsertWithoutHijosInput;
    disconnect?: ResenaRespuestaWhereInput | boolean;
    delete?: ResenaRespuestaWhereInput | boolean;
    connect?: ResenaRespuestaWhereUniqueInput;
    update?: XOR<
      XOR<
        ResenaRespuestaUpdateToOneWithWhereWithoutHijosInput,
        ResenaRespuestaUpdateWithoutHijosInput
      >,
      ResenaRespuestaUncheckedUpdateWithoutHijosInput
    >;
  };

  export type ResenaRespuestaUpdateManyWithoutParentNestedInput = {
    create?:
      | XOR<
          ResenaRespuestaCreateWithoutParentInput,
          ResenaRespuestaUncheckedCreateWithoutParentInput
        >
      | ResenaRespuestaCreateWithoutParentInput[]
      | ResenaRespuestaUncheckedCreateWithoutParentInput[];
    connectOrCreate?:
      | ResenaRespuestaCreateOrConnectWithoutParentInput
      | ResenaRespuestaCreateOrConnectWithoutParentInput[];
    upsert?:
      | ResenaRespuestaUpsertWithWhereUniqueWithoutParentInput
      | ResenaRespuestaUpsertWithWhereUniqueWithoutParentInput[];
    createMany?: ResenaRespuestaCreateManyParentInputEnvelope;
    set?: ResenaRespuestaWhereUniqueInput | ResenaRespuestaWhereUniqueInput[];
    disconnect?:
      | ResenaRespuestaWhereUniqueInput
      | ResenaRespuestaWhereUniqueInput[];
    delete?:
      | ResenaRespuestaWhereUniqueInput
      | ResenaRespuestaWhereUniqueInput[];
    connect?:
      | ResenaRespuestaWhereUniqueInput
      | ResenaRespuestaWhereUniqueInput[];
    update?:
      | ResenaRespuestaUpdateWithWhereUniqueWithoutParentInput
      | ResenaRespuestaUpdateWithWhereUniqueWithoutParentInput[];
    updateMany?:
      | ResenaRespuestaUpdateManyWithWhereWithoutParentInput
      | ResenaRespuestaUpdateManyWithWhereWithoutParentInput[];
    deleteMany?:
      | ResenaRespuestaScalarWhereInput
      | ResenaRespuestaScalarWhereInput[];
  };

  export type ResenaRespuestaUncheckedUpdateManyWithoutParentNestedInput = {
    create?:
      | XOR<
          ResenaRespuestaCreateWithoutParentInput,
          ResenaRespuestaUncheckedCreateWithoutParentInput
        >
      | ResenaRespuestaCreateWithoutParentInput[]
      | ResenaRespuestaUncheckedCreateWithoutParentInput[];
    connectOrCreate?:
      | ResenaRespuestaCreateOrConnectWithoutParentInput
      | ResenaRespuestaCreateOrConnectWithoutParentInput[];
    upsert?:
      | ResenaRespuestaUpsertWithWhereUniqueWithoutParentInput
      | ResenaRespuestaUpsertWithWhereUniqueWithoutParentInput[];
    createMany?: ResenaRespuestaCreateManyParentInputEnvelope;
    set?: ResenaRespuestaWhereUniqueInput | ResenaRespuestaWhereUniqueInput[];
    disconnect?:
      | ResenaRespuestaWhereUniqueInput
      | ResenaRespuestaWhereUniqueInput[];
    delete?:
      | ResenaRespuestaWhereUniqueInput
      | ResenaRespuestaWhereUniqueInput[];
    connect?:
      | ResenaRespuestaWhereUniqueInput
      | ResenaRespuestaWhereUniqueInput[];
    update?:
      | ResenaRespuestaUpdateWithWhereUniqueWithoutParentInput
      | ResenaRespuestaUpdateWithWhereUniqueWithoutParentInput[];
    updateMany?:
      | ResenaRespuestaUpdateManyWithWhereWithoutParentInput
      | ResenaRespuestaUpdateManyWithWhereWithoutParentInput[];
    deleteMany?:
      | ResenaRespuestaScalarWhereInput
      | ResenaRespuestaScalarWhereInput[];
  };

  export type UsuarioCreateNestedOneWithoutNotificacionesInput = {
    create?: XOR<
      UsuarioCreateWithoutNotificacionesInput,
      UsuarioUncheckedCreateWithoutNotificacionesInput
    >;
    connectOrCreate?: UsuarioCreateOrConnectWithoutNotificacionesInput;
    connect?: UsuarioWhereUniqueInput;
  };

  export type EnumTipoNotificacionFieldUpdateOperationsInput = {
    set?: $Enums.TipoNotificacion;
  };

  export type UsuarioUpdateOneRequiredWithoutNotificacionesNestedInput = {
    create?: XOR<
      UsuarioCreateWithoutNotificacionesInput,
      UsuarioUncheckedCreateWithoutNotificacionesInput
    >;
    connectOrCreate?: UsuarioCreateOrConnectWithoutNotificacionesInput;
    upsert?: UsuarioUpsertWithoutNotificacionesInput;
    connect?: UsuarioWhereUniqueInput;
    update?: XOR<
      XOR<
        UsuarioUpdateToOneWithWhereWithoutNotificacionesInput,
        UsuarioUpdateWithoutNotificacionesInput
      >,
      UsuarioUncheckedUpdateWithoutNotificacionesInput
    >;
  };

  export type UsuarioCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<
      UsuarioCreateWithoutAuditLogsInput,
      UsuarioUncheckedCreateWithoutAuditLogsInput
    >;
    connectOrCreate?: UsuarioCreateOrConnectWithoutAuditLogsInput;
    connect?: UsuarioWhereUniqueInput;
  };

  export type UsuarioUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<
      UsuarioCreateWithoutAuditLogsInput,
      UsuarioUncheckedCreateWithoutAuditLogsInput
    >;
    connectOrCreate?: UsuarioCreateOrConnectWithoutAuditLogsInput;
    upsert?: UsuarioUpsertWithoutAuditLogsInput;
    connect?: UsuarioWhereUniqueInput;
    update?: XOR<
      XOR<
        UsuarioUpdateToOneWithWhereWithoutAuditLogsInput,
        UsuarioUpdateWithoutAuditLogsInput
      >,
      UsuarioUncheckedUpdateWithoutAuditLogsInput
    >;
  };

  export type UsuarioCreateNestedOneWithoutCarritoInput = {
    create?: XOR<
      UsuarioCreateWithoutCarritoInput,
      UsuarioUncheckedCreateWithoutCarritoInput
    >;
    connectOrCreate?: UsuarioCreateOrConnectWithoutCarritoInput;
    connect?: UsuarioWhereUniqueInput;
  };

  export type ItemCarritoCreateNestedManyWithoutCarritoInput = {
    create?:
      | XOR<
          ItemCarritoCreateWithoutCarritoInput,
          ItemCarritoUncheckedCreateWithoutCarritoInput
        >
      | ItemCarritoCreateWithoutCarritoInput[]
      | ItemCarritoUncheckedCreateWithoutCarritoInput[];
    connectOrCreate?:
      | ItemCarritoCreateOrConnectWithoutCarritoInput
      | ItemCarritoCreateOrConnectWithoutCarritoInput[];
    createMany?: ItemCarritoCreateManyCarritoInputEnvelope;
    connect?: ItemCarritoWhereUniqueInput | ItemCarritoWhereUniqueInput[];
  };

  export type ItemCarritoUncheckedCreateNestedManyWithoutCarritoInput = {
    create?:
      | XOR<
          ItemCarritoCreateWithoutCarritoInput,
          ItemCarritoUncheckedCreateWithoutCarritoInput
        >
      | ItemCarritoCreateWithoutCarritoInput[]
      | ItemCarritoUncheckedCreateWithoutCarritoInput[];
    connectOrCreate?:
      | ItemCarritoCreateOrConnectWithoutCarritoInput
      | ItemCarritoCreateOrConnectWithoutCarritoInput[];
    createMany?: ItemCarritoCreateManyCarritoInputEnvelope;
    connect?: ItemCarritoWhereUniqueInput | ItemCarritoWhereUniqueInput[];
  };

  export type UsuarioUpdateOneRequiredWithoutCarritoNestedInput = {
    create?: XOR<
      UsuarioCreateWithoutCarritoInput,
      UsuarioUncheckedCreateWithoutCarritoInput
    >;
    connectOrCreate?: UsuarioCreateOrConnectWithoutCarritoInput;
    upsert?: UsuarioUpsertWithoutCarritoInput;
    connect?: UsuarioWhereUniqueInput;
    update?: XOR<
      XOR<
        UsuarioUpdateToOneWithWhereWithoutCarritoInput,
        UsuarioUpdateWithoutCarritoInput
      >,
      UsuarioUncheckedUpdateWithoutCarritoInput
    >;
  };

  export type ItemCarritoUpdateManyWithoutCarritoNestedInput = {
    create?:
      | XOR<
          ItemCarritoCreateWithoutCarritoInput,
          ItemCarritoUncheckedCreateWithoutCarritoInput
        >
      | ItemCarritoCreateWithoutCarritoInput[]
      | ItemCarritoUncheckedCreateWithoutCarritoInput[];
    connectOrCreate?:
      | ItemCarritoCreateOrConnectWithoutCarritoInput
      | ItemCarritoCreateOrConnectWithoutCarritoInput[];
    upsert?:
      | ItemCarritoUpsertWithWhereUniqueWithoutCarritoInput
      | ItemCarritoUpsertWithWhereUniqueWithoutCarritoInput[];
    createMany?: ItemCarritoCreateManyCarritoInputEnvelope;
    set?: ItemCarritoWhereUniqueInput | ItemCarritoWhereUniqueInput[];
    disconnect?: ItemCarritoWhereUniqueInput | ItemCarritoWhereUniqueInput[];
    delete?: ItemCarritoWhereUniqueInput | ItemCarritoWhereUniqueInput[];
    connect?: ItemCarritoWhereUniqueInput | ItemCarritoWhereUniqueInput[];
    update?:
      | ItemCarritoUpdateWithWhereUniqueWithoutCarritoInput
      | ItemCarritoUpdateWithWhereUniqueWithoutCarritoInput[];
    updateMany?:
      | ItemCarritoUpdateManyWithWhereWithoutCarritoInput
      | ItemCarritoUpdateManyWithWhereWithoutCarritoInput[];
    deleteMany?: ItemCarritoScalarWhereInput | ItemCarritoScalarWhereInput[];
  };

  export type ItemCarritoUncheckedUpdateManyWithoutCarritoNestedInput = {
    create?:
      | XOR<
          ItemCarritoCreateWithoutCarritoInput,
          ItemCarritoUncheckedCreateWithoutCarritoInput
        >
      | ItemCarritoCreateWithoutCarritoInput[]
      | ItemCarritoUncheckedCreateWithoutCarritoInput[];
    connectOrCreate?:
      | ItemCarritoCreateOrConnectWithoutCarritoInput
      | ItemCarritoCreateOrConnectWithoutCarritoInput[];
    upsert?:
      | ItemCarritoUpsertWithWhereUniqueWithoutCarritoInput
      | ItemCarritoUpsertWithWhereUniqueWithoutCarritoInput[];
    createMany?: ItemCarritoCreateManyCarritoInputEnvelope;
    set?: ItemCarritoWhereUniqueInput | ItemCarritoWhereUniqueInput[];
    disconnect?: ItemCarritoWhereUniqueInput | ItemCarritoWhereUniqueInput[];
    delete?: ItemCarritoWhereUniqueInput | ItemCarritoWhereUniqueInput[];
    connect?: ItemCarritoWhereUniqueInput | ItemCarritoWhereUniqueInput[];
    update?:
      | ItemCarritoUpdateWithWhereUniqueWithoutCarritoInput
      | ItemCarritoUpdateWithWhereUniqueWithoutCarritoInput[];
    updateMany?:
      | ItemCarritoUpdateManyWithWhereWithoutCarritoInput
      | ItemCarritoUpdateManyWithWhereWithoutCarritoInput[];
    deleteMany?: ItemCarritoScalarWhereInput | ItemCarritoScalarWhereInput[];
  };

  export type CarritoCreateNestedOneWithoutItemsInput = {
    create?: XOR<
      CarritoCreateWithoutItemsInput,
      CarritoUncheckedCreateWithoutItemsInput
    >;
    connectOrCreate?: CarritoCreateOrConnectWithoutItemsInput;
    connect?: CarritoWhereUniqueInput;
  };

  export type ProductoCreateNestedOneWithoutItemsCarritoInput = {
    create?: XOR<
      ProductoCreateWithoutItemsCarritoInput,
      ProductoUncheckedCreateWithoutItemsCarritoInput
    >;
    connectOrCreate?: ProductoCreateOrConnectWithoutItemsCarritoInput;
    connect?: ProductoWhereUniqueInput;
  };

  export type CursoCreateNestedOneWithoutItemsCarritoInput = {
    create?: XOR<
      CursoCreateWithoutItemsCarritoInput,
      CursoUncheckedCreateWithoutItemsCarritoInput
    >;
    connectOrCreate?: CursoCreateOrConnectWithoutItemsCarritoInput;
    connect?: CursoWhereUniqueInput;
  };

  export type CarritoUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<
      CarritoCreateWithoutItemsInput,
      CarritoUncheckedCreateWithoutItemsInput
    >;
    connectOrCreate?: CarritoCreateOrConnectWithoutItemsInput;
    upsert?: CarritoUpsertWithoutItemsInput;
    connect?: CarritoWhereUniqueInput;
    update?: XOR<
      XOR<
        CarritoUpdateToOneWithWhereWithoutItemsInput,
        CarritoUpdateWithoutItemsInput
      >,
      CarritoUncheckedUpdateWithoutItemsInput
    >;
  };

  export type ProductoUpdateOneWithoutItemsCarritoNestedInput = {
    create?: XOR<
      ProductoCreateWithoutItemsCarritoInput,
      ProductoUncheckedCreateWithoutItemsCarritoInput
    >;
    connectOrCreate?: ProductoCreateOrConnectWithoutItemsCarritoInput;
    upsert?: ProductoUpsertWithoutItemsCarritoInput;
    disconnect?: ProductoWhereInput | boolean;
    delete?: ProductoWhereInput | boolean;
    connect?: ProductoWhereUniqueInput;
    update?: XOR<
      XOR<
        ProductoUpdateToOneWithWhereWithoutItemsCarritoInput,
        ProductoUpdateWithoutItemsCarritoInput
      >,
      ProductoUncheckedUpdateWithoutItemsCarritoInput
    >;
  };

  export type CursoUpdateOneWithoutItemsCarritoNestedInput = {
    create?: XOR<
      CursoCreateWithoutItemsCarritoInput,
      CursoUncheckedCreateWithoutItemsCarritoInput
    >;
    connectOrCreate?: CursoCreateOrConnectWithoutItemsCarritoInput;
    upsert?: CursoUpsertWithoutItemsCarritoInput;
    disconnect?: CursoWhereInput | boolean;
    delete?: CursoWhereInput | boolean;
    connect?: CursoWhereUniqueInput;
    update?: XOR<
      XOR<
        CursoUpdateToOneWithWhereWithoutItemsCarritoInput,
        CursoUpdateWithoutItemsCarritoInput
      >,
      CursoUncheckedUpdateWithoutItemsCarritoInput
    >;
  };

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[];
    notIn?: number[];
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
  };

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[];
    notIn?: string[];
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    search?: string;
    not?: NestedStringFilter<$PrismaModel> | string;
  };

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | null;
    notIn?: string[] | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    search?: string;
    not?: NestedStringNullableFilter<$PrismaModel> | string | null;
  };

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[];
    notIn?: Date[] | string[];
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
  };

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | null;
    notIn?: Date[] | string[] | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
  };

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[];
    notIn?: number[];
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
  };

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[];
    notIn?: number[];
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatFilter<$PrismaModel> | number;
  };

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[];
    notIn?: string[];
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    search?: string;
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | null;
    notIn?: string[] | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    search?: string;
    not?:
      | NestedStringNullableWithAggregatesFilter<$PrismaModel>
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
  };

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | null;
    notIn?: number[] | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableFilter<$PrismaModel> | number | null;
  };

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[];
    notIn?: Date[] | string[];
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedDateTimeFilter<$PrismaModel>;
    _max?: NestedDateTimeFilter<$PrismaModel>;
  };

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> =
    {
      equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
      in?: Date[] | string[] | null;
      notIn?: Date[] | string[] | null;
      lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      not?:
        | NestedDateTimeNullableWithAggregatesFilter<$PrismaModel>
        | Date
        | string
        | null;
      _count?: NestedIntNullableFilter<$PrismaModel>;
      _min?: NestedDateTimeNullableFilter<$PrismaModel>;
      _max?: NestedDateTimeNullableFilter<$PrismaModel>;
    };

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolFilter<$PrismaModel> | boolean;
  };

  export type NestedEnumNivelCursoFilter<$PrismaModel = never> = {
    equals?: $Enums.NivelCurso | EnumNivelCursoFieldRefInput<$PrismaModel>;
    in?: $Enums.NivelCurso[];
    notIn?: $Enums.NivelCurso[];
    not?: NestedEnumNivelCursoFilter<$PrismaModel> | $Enums.NivelCurso;
  };

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>
      | null;
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null;
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null;
    lt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    lte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    not?:
      | NestedDecimalNullableFilter<$PrismaModel>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
  };

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedBoolFilter<$PrismaModel>;
    _max?: NestedBoolFilter<$PrismaModel>;
  };

  export type NestedEnumNivelCursoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NivelCurso | EnumNivelCursoFieldRefInput<$PrismaModel>;
    in?: $Enums.NivelCurso[];
    notIn?: $Enums.NivelCurso[];
    not?:
      | NestedEnumNivelCursoWithAggregatesFilter<$PrismaModel>
      | $Enums.NivelCurso;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumNivelCursoFilter<$PrismaModel>;
    _max?: NestedEnumNivelCursoFilter<$PrismaModel>;
  };
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<NestedJsonNullableFilterBase<$PrismaModel>>,
          Exclude<
            keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>,
            'path'
          >
        >,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<
        Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>
      >;

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    path?: string;
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue;
    lte?: InputJsonValue;
    gt?: InputJsonValue;
    gte?: InputJsonValue;
    not?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
  };

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> =
    {
      equals?:
        | Decimal
        | DecimalJsLike
        | number
        | string
        | DecimalFieldRefInput<$PrismaModel>
        | null;
      in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null;
      notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null;
      lt?:
        | Decimal
        | DecimalJsLike
        | number
        | string
        | DecimalFieldRefInput<$PrismaModel>;
      lte?:
        | Decimal
        | DecimalJsLike
        | number
        | string
        | DecimalFieldRefInput<$PrismaModel>;
      gt?:
        | Decimal
        | DecimalJsLike
        | number
        | string
        | DecimalFieldRefInput<$PrismaModel>;
      gte?:
        | Decimal
        | DecimalJsLike
        | number
        | string
        | DecimalFieldRefInput<$PrismaModel>;
      not?:
        | NestedDecimalNullableWithAggregatesFilter<$PrismaModel>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      _count?: NestedIntNullableFilter<$PrismaModel>;
      _avg?: NestedDecimalNullableFilter<$PrismaModel>;
      _sum?: NestedDecimalNullableFilter<$PrismaModel>;
      _min?: NestedDecimalNullableFilter<$PrismaModel>;
      _max?: NestedDecimalNullableFilter<$PrismaModel>;
    };

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | null;
    notIn?: number[] | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedIntNullableFilter<$PrismaModel>;
    _max?: NestedIntNullableFilter<$PrismaModel>;
  };

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | null;
    notIn?: number[] | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null;
  };

  export type NestedEnumEstadoInscripcionFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.EstadoInscripcion
      | EnumEstadoInscripcionFieldRefInput<$PrismaModel>;
    in?: $Enums.EstadoInscripcion[];
    notIn?: $Enums.EstadoInscripcion[];
    not?:
      | NestedEnumEstadoInscripcionFilter<$PrismaModel>
      | $Enums.EstadoInscripcion;
  };

  export type NestedEnumEstadoInscripcionWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.EstadoInscripcion
      | EnumEstadoInscripcionFieldRefInput<$PrismaModel>;
    in?: $Enums.EstadoInscripcion[];
    notIn?: $Enums.EstadoInscripcion[];
    not?:
      | NestedEnumEstadoInscripcionWithAggregatesFilter<$PrismaModel>
      | $Enums.EstadoInscripcion;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumEstadoInscripcionFilter<$PrismaModel>;
    _max?: NestedEnumEstadoInscripcionFilter<$PrismaModel>;
  };
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<NestedJsonFilterBase<$PrismaModel>>,
          Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>
        >,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>;

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    path?: string;
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue;
    lte?: InputJsonValue;
    gt?: InputJsonValue;
    gte?: InputJsonValue;
    not?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
  };

  export type NestedEnumTipoLeccionFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoLeccion | EnumTipoLeccionFieldRefInput<$PrismaModel>;
    in?: $Enums.TipoLeccion[];
    notIn?: $Enums.TipoLeccion[];
    not?: NestedEnumTipoLeccionFilter<$PrismaModel> | $Enums.TipoLeccion;
  };

  export type NestedEnumTipoLeccionWithAggregatesFilter<$PrismaModel = never> =
    {
      equals?: $Enums.TipoLeccion | EnumTipoLeccionFieldRefInput<$PrismaModel>;
      in?: $Enums.TipoLeccion[];
      notIn?: $Enums.TipoLeccion[];
      not?:
        | NestedEnumTipoLeccionWithAggregatesFilter<$PrismaModel>
        | $Enums.TipoLeccion;
      _count?: NestedIntFilter<$PrismaModel>;
      _min?: NestedEnumTipoLeccionFilter<$PrismaModel>;
      _max?: NestedEnumTipoLeccionFilter<$PrismaModel>;
    };

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[];
    notIn?: number[];
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedFloatFilter<$PrismaModel>;
    _min?: NestedFloatFilter<$PrismaModel>;
    _max?: NestedFloatFilter<$PrismaModel>;
  };

  export type NestedEnumEstadoOrdenFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoOrden | EnumEstadoOrdenFieldRefInput<$PrismaModel>;
    in?: $Enums.EstadoOrden[];
    notIn?: $Enums.EstadoOrden[];
    not?: NestedEnumEstadoOrdenFilter<$PrismaModel> | $Enums.EstadoOrden;
  };

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null;
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null;
  };

  export type NestedEnumEstadoOrdenWithAggregatesFilter<$PrismaModel = never> =
    {
      equals?: $Enums.EstadoOrden | EnumEstadoOrdenFieldRefInput<$PrismaModel>;
      in?: $Enums.EstadoOrden[];
      notIn?: $Enums.EstadoOrden[];
      not?:
        | NestedEnumEstadoOrdenWithAggregatesFilter<$PrismaModel>
        | $Enums.EstadoOrden;
      _count?: NestedIntFilter<$PrismaModel>;
      _min?: NestedEnumEstadoOrdenFilter<$PrismaModel>;
      _max?: NestedEnumEstadoOrdenFilter<$PrismaModel>;
    };

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null;
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedBoolNullableFilter<$PrismaModel>;
    _max?: NestedBoolNullableFilter<$PrismaModel>;
  };

  export type NestedEnumTipoItemOrdenFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.TipoItemOrden
      | EnumTipoItemOrdenFieldRefInput<$PrismaModel>;
    in?: $Enums.TipoItemOrden[];
    notIn?: $Enums.TipoItemOrden[];
    not?: NestedEnumTipoItemOrdenFilter<$PrismaModel> | $Enums.TipoItemOrden;
  };

  export type NestedEnumTipoItemOrdenWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.TipoItemOrden
      | EnumTipoItemOrdenFieldRefInput<$PrismaModel>;
    in?: $Enums.TipoItemOrden[];
    notIn?: $Enums.TipoItemOrden[];
    not?:
      | NestedEnumTipoItemOrdenWithAggregatesFilter<$PrismaModel>
      | $Enums.TipoItemOrden;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumTipoItemOrdenFilter<$PrismaModel>;
    _max?: NestedEnumTipoItemOrdenFilter<$PrismaModel>;
  };

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    in?: Decimal[] | DecimalJsLike[] | number[] | string[];
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[];
    lt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    lte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    not?:
      | NestedDecimalFilter<$PrismaModel>
      | Decimal
      | DecimalJsLike
      | number
      | string;
  };

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    in?: Decimal[] | DecimalJsLike[] | number[] | string[];
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[];
    lt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    lte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    not?:
      | NestedDecimalWithAggregatesFilter<$PrismaModel>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedDecimalFilter<$PrismaModel>;
    _sum?: NestedDecimalFilter<$PrismaModel>;
    _min?: NestedDecimalFilter<$PrismaModel>;
    _max?: NestedDecimalFilter<$PrismaModel>;
  };

  export type NestedEnumTipoLikeFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoLike | EnumTipoLikeFieldRefInput<$PrismaModel>;
    in?: $Enums.TipoLike[];
    notIn?: $Enums.TipoLike[];
    not?: NestedEnumTipoLikeFilter<$PrismaModel> | $Enums.TipoLike;
  };

  export type NestedEnumTipoLikeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoLike | EnumTipoLikeFieldRefInput<$PrismaModel>;
    in?: $Enums.TipoLike[];
    notIn?: $Enums.TipoLike[];
    not?:
      | NestedEnumTipoLikeWithAggregatesFilter<$PrismaModel>
      | $Enums.TipoLike;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumTipoLikeFilter<$PrismaModel>;
    _max?: NestedEnumTipoLikeFilter<$PrismaModel>;
  };

  export type NestedEnumTipoNotificacionFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.TipoNotificacion
      | EnumTipoNotificacionFieldRefInput<$PrismaModel>;
    in?: $Enums.TipoNotificacion[];
    notIn?: $Enums.TipoNotificacion[];
    not?:
      | NestedEnumTipoNotificacionFilter<$PrismaModel>
      | $Enums.TipoNotificacion;
  };

  export type NestedEnumTipoNotificacionWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.TipoNotificacion
      | EnumTipoNotificacionFieldRefInput<$PrismaModel>;
    in?: $Enums.TipoNotificacion[];
    notIn?: $Enums.TipoNotificacion[];
    not?:
      | NestedEnumTipoNotificacionWithAggregatesFilter<$PrismaModel>
      | $Enums.TipoNotificacion;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumTipoNotificacionFilter<$PrismaModel>;
    _max?: NestedEnumTipoNotificacionFilter<$PrismaModel>;
  };

  export type UsuarioRolCreateWithoutUsuarioInput = {
    role: RoleCreateNestedOneWithoutUsuariosInput;
  };

  export type UsuarioRolUncheckedCreateWithoutUsuarioInput = {
    roleId: number;
  };

  export type UsuarioRolCreateOrConnectWithoutUsuarioInput = {
    where: UsuarioRolWhereUniqueInput;
    create: XOR<
      UsuarioRolCreateWithoutUsuarioInput,
      UsuarioRolUncheckedCreateWithoutUsuarioInput
    >;
  };

  export type UsuarioRolCreateManyUsuarioInputEnvelope = {
    data: UsuarioRolCreateManyUsuarioInput | UsuarioRolCreateManyUsuarioInput[];
    skipDuplicates?: boolean;
  };

  export type CursoCreateWithoutInstructorInput = {
    slug: string;
    titulo: string;
    resumen?: string | null;
    descripcionMD?: string | null;
    requisitos?: string | null;
    precio: number;
    publicado?: boolean;
    nivel?: $Enums.NivelCurso;
    portada?: string | null;
    destacado?: boolean;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    ratingProm?: Decimal | DecimalJsLike | number | string | null;
    ratingConteo?: number;
    creadoEn?: Date | string;
    modulos?: ModuloCreateNestedManyWithoutCursoInput;
    resenas?: ResenaCreateNestedManyWithoutCursoInput;
    inscripciones?: InscripcionCreateNestedManyWithoutCursoInput;
    itemsCarrito?: ItemCarritoCreateNestedManyWithoutCursoInput;
  };

  export type CursoUncheckedCreateWithoutInstructorInput = {
    id?: number;
    slug: string;
    titulo: string;
    resumen?: string | null;
    descripcionMD?: string | null;
    requisitos?: string | null;
    precio: number;
    publicado?: boolean;
    nivel?: $Enums.NivelCurso;
    portada?: string | null;
    destacado?: boolean;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    ratingProm?: Decimal | DecimalJsLike | number | string | null;
    ratingConteo?: number;
    creadoEn?: Date | string;
    modulos?: ModuloUncheckedCreateNestedManyWithoutCursoInput;
    resenas?: ResenaUncheckedCreateNestedManyWithoutCursoInput;
    inscripciones?: InscripcionUncheckedCreateNestedManyWithoutCursoInput;
    itemsCarrito?: ItemCarritoUncheckedCreateNestedManyWithoutCursoInput;
  };

  export type CursoCreateOrConnectWithoutInstructorInput = {
    where: CursoWhereUniqueInput;
    create: XOR<
      CursoCreateWithoutInstructorInput,
      CursoUncheckedCreateWithoutInstructorInput
    >;
  };

  export type CursoCreateManyInstructorInputEnvelope = {
    data: CursoCreateManyInstructorInput | CursoCreateManyInstructorInput[];
    skipDuplicates?: boolean;
  };

  export type InscripcionCreateWithoutUsuarioInput = {
    estado?: $Enums.EstadoInscripcion;
    progreso: JsonNullValueInput | InputJsonValue;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
    curso: CursoCreateNestedOneWithoutInscripcionesInput;
  };

  export type InscripcionUncheckedCreateWithoutUsuarioInput = {
    id?: number;
    cursoId: number;
    estado?: $Enums.EstadoInscripcion;
    progreso: JsonNullValueInput | InputJsonValue;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
  };

  export type InscripcionCreateOrConnectWithoutUsuarioInput = {
    where: InscripcionWhereUniqueInput;
    create: XOR<
      InscripcionCreateWithoutUsuarioInput,
      InscripcionUncheckedCreateWithoutUsuarioInput
    >;
  };

  export type InscripcionCreateManyUsuarioInputEnvelope = {
    data:
      | InscripcionCreateManyUsuarioInput
      | InscripcionCreateManyUsuarioInput[];
    skipDuplicates?: boolean;
  };

  export type ResenaCreateWithoutUsuarioInput = {
    puntaje: number;
    comentario?: string | null;
    creadoEn?: Date | string;
    curso?: CursoCreateNestedOneWithoutResenasInput;
    producto?: ProductoCreateNestedOneWithoutResenasInput;
    respuestas?: ResenaRespuestaCreateNestedManyWithoutResenaInput;
    likes?: ResenaLikeCreateNestedManyWithoutResenaInput;
  };

  export type ResenaUncheckedCreateWithoutUsuarioInput = {
    id?: number;
    cursoId?: number | null;
    productoId?: number | null;
    puntaje: number;
    comentario?: string | null;
    creadoEn?: Date | string;
    respuestas?: ResenaRespuestaUncheckedCreateNestedManyWithoutResenaInput;
    likes?: ResenaLikeUncheckedCreateNestedManyWithoutResenaInput;
  };

  export type ResenaCreateOrConnectWithoutUsuarioInput = {
    where: ResenaWhereUniqueInput;
    create: XOR<
      ResenaCreateWithoutUsuarioInput,
      ResenaUncheckedCreateWithoutUsuarioInput
    >;
  };

  export type ResenaCreateManyUsuarioInputEnvelope = {
    data: ResenaCreateManyUsuarioInput | ResenaCreateManyUsuarioInput[];
    skipDuplicates?: boolean;
  };

  export type ResenaRespuestaCreateWithoutUsuarioInput = {
    contenido: string;
    eliminado?: boolean;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
    resena: ResenaCreateNestedOneWithoutRespuestasInput;
    parent?: ResenaRespuestaCreateNestedOneWithoutHijosInput;
    hijos?: ResenaRespuestaCreateNestedManyWithoutParentInput;
  };

  export type ResenaRespuestaUncheckedCreateWithoutUsuarioInput = {
    id?: number;
    resenaId: number;
    parentId?: number | null;
    contenido: string;
    eliminado?: boolean;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
    hijos?: ResenaRespuestaUncheckedCreateNestedManyWithoutParentInput;
  };

  export type ResenaRespuestaCreateOrConnectWithoutUsuarioInput = {
    where: ResenaRespuestaWhereUniqueInput;
    create: XOR<
      ResenaRespuestaCreateWithoutUsuarioInput,
      ResenaRespuestaUncheckedCreateWithoutUsuarioInput
    >;
  };

  export type ResenaRespuestaCreateManyUsuarioInputEnvelope = {
    data:
      | ResenaRespuestaCreateManyUsuarioInput
      | ResenaRespuestaCreateManyUsuarioInput[];
    skipDuplicates?: boolean;
  };

  export type FavoritoCreateWithoutUsuarioInput = {
    creadoEn?: Date | string;
    producto: ProductoCreateNestedOneWithoutFavoritosInput;
  };

  export type FavoritoUncheckedCreateWithoutUsuarioInput = {
    id?: number;
    productoId: number;
    creadoEn?: Date | string;
  };

  export type FavoritoCreateOrConnectWithoutUsuarioInput = {
    where: FavoritoWhereUniqueInput;
    create: XOR<
      FavoritoCreateWithoutUsuarioInput,
      FavoritoUncheckedCreateWithoutUsuarioInput
    >;
  };

  export type FavoritoCreateManyUsuarioInputEnvelope = {
    data: FavoritoCreateManyUsuarioInput | FavoritoCreateManyUsuarioInput[];
    skipDuplicates?: boolean;
  };

  export type ResenaLikeCreateWithoutUsuarioInput = {
    tipo: $Enums.TipoLike;
    creadoEn?: Date | string;
    resena: ResenaCreateNestedOneWithoutLikesInput;
  };

  export type ResenaLikeUncheckedCreateWithoutUsuarioInput = {
    id?: number;
    resenaId: number;
    tipo: $Enums.TipoLike;
    creadoEn?: Date | string;
  };

  export type ResenaLikeCreateOrConnectWithoutUsuarioInput = {
    where: ResenaLikeWhereUniqueInput;
    create: XOR<
      ResenaLikeCreateWithoutUsuarioInput,
      ResenaLikeUncheckedCreateWithoutUsuarioInput
    >;
  };

  export type ResenaLikeCreateManyUsuarioInputEnvelope = {
    data: ResenaLikeCreateManyUsuarioInput | ResenaLikeCreateManyUsuarioInput[];
    skipDuplicates?: boolean;
  };

  export type OrdenCreateWithoutUsuarioInput = {
    estado?: $Enums.EstadoOrden;
    total: number;
    moneda?: string;
    referenciaPago?: string | null;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
    esSuscripcion?: boolean;
    suscripcionActiva?: boolean | null;
    suscripcionId?: string | null;
    suscripcionFrecuencia?: number | null;
    suscripcionTipoFrecuencia?: string | null;
    metadatos?: NullableJsonNullValueInput | InputJsonValue;
    direccionEnvio?: DireccionCreateNestedOneWithoutOrdenesEnvioInput;
    direccionFacturacion?: DireccionCreateNestedOneWithoutOrdenesFacturacionInput;
    items?: ItemOrdenCreateNestedManyWithoutOrdenInput;
  };

  export type OrdenUncheckedCreateWithoutUsuarioInput = {
    id?: number;
    estado?: $Enums.EstadoOrden;
    total: number;
    moneda?: string;
    referenciaPago?: string | null;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
    esSuscripcion?: boolean;
    suscripcionActiva?: boolean | null;
    suscripcionId?: string | null;
    suscripcionFrecuencia?: number | null;
    suscripcionTipoFrecuencia?: string | null;
    metadatos?: NullableJsonNullValueInput | InputJsonValue;
    direccionEnvioId?: number | null;
    direccionFacturacionId?: number | null;
    items?: ItemOrdenUncheckedCreateNestedManyWithoutOrdenInput;
  };

  export type OrdenCreateOrConnectWithoutUsuarioInput = {
    where: OrdenWhereUniqueInput;
    create: XOR<
      OrdenCreateWithoutUsuarioInput,
      OrdenUncheckedCreateWithoutUsuarioInput
    >;
  };

  export type OrdenCreateManyUsuarioInputEnvelope = {
    data: OrdenCreateManyUsuarioInput | OrdenCreateManyUsuarioInput[];
    skipDuplicates?: boolean;
  };

  export type AuditLogCreateWithoutUserInput = {
    tableName: string;
    recordId: string;
    action: string;
    oldData?: NullableJsonNullValueInput | InputJsonValue;
    newData?: NullableJsonNullValueInput | InputJsonValue;
    userAgent?: string | null;
    ipAddress?: string | null;
    endpoint?: string | null;
    timestamp?: Date | string;
  };

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: number;
    tableName: string;
    recordId: string;
    action: string;
    oldData?: NullableJsonNullValueInput | InputJsonValue;
    newData?: NullableJsonNullValueInput | InputJsonValue;
    userAgent?: string | null;
    ipAddress?: string | null;
    endpoint?: string | null;
    timestamp?: Date | string;
  };

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput;
    create: XOR<
      AuditLogCreateWithoutUserInput,
      AuditLogUncheckedCreateWithoutUserInput
    >;
  };

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type CarritoCreateWithoutUsuarioInput = {
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
    items?: ItemCarritoCreateNestedManyWithoutCarritoInput;
  };

  export type CarritoUncheckedCreateWithoutUsuarioInput = {
    id?: number;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
    items?: ItemCarritoUncheckedCreateNestedManyWithoutCarritoInput;
  };

  export type CarritoCreateOrConnectWithoutUsuarioInput = {
    where: CarritoWhereUniqueInput;
    create: XOR<
      CarritoCreateWithoutUsuarioInput,
      CarritoUncheckedCreateWithoutUsuarioInput
    >;
  };

  export type NotificacionCreateWithoutUsuarioInput = {
    tipo: $Enums.TipoNotificacion;
    titulo: string;
    mensaje: string;
    leida?: boolean;
    url?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    creadoEn?: Date | string;
  };

  export type NotificacionUncheckedCreateWithoutUsuarioInput = {
    id?: number;
    tipo: $Enums.TipoNotificacion;
    titulo: string;
    mensaje: string;
    leida?: boolean;
    url?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    creadoEn?: Date | string;
  };

  export type NotificacionCreateOrConnectWithoutUsuarioInput = {
    where: NotificacionWhereUniqueInput;
    create: XOR<
      NotificacionCreateWithoutUsuarioInput,
      NotificacionUncheckedCreateWithoutUsuarioInput
    >;
  };

  export type NotificacionCreateManyUsuarioInputEnvelope = {
    data:
      | NotificacionCreateManyUsuarioInput
      | NotificacionCreateManyUsuarioInput[];
    skipDuplicates?: boolean;
  };

  export type UsuarioRolUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: UsuarioRolWhereUniqueInput;
    update: XOR<
      UsuarioRolUpdateWithoutUsuarioInput,
      UsuarioRolUncheckedUpdateWithoutUsuarioInput
    >;
    create: XOR<
      UsuarioRolCreateWithoutUsuarioInput,
      UsuarioRolUncheckedCreateWithoutUsuarioInput
    >;
  };

  export type UsuarioRolUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: UsuarioRolWhereUniqueInput;
    data: XOR<
      UsuarioRolUpdateWithoutUsuarioInput,
      UsuarioRolUncheckedUpdateWithoutUsuarioInput
    >;
  };

  export type UsuarioRolUpdateManyWithWhereWithoutUsuarioInput = {
    where: UsuarioRolScalarWhereInput;
    data: XOR<
      UsuarioRolUpdateManyMutationInput,
      UsuarioRolUncheckedUpdateManyWithoutUsuarioInput
    >;
  };

  export type UsuarioRolScalarWhereInput = {
    AND?: UsuarioRolScalarWhereInput | UsuarioRolScalarWhereInput[];
    OR?: UsuarioRolScalarWhereInput[];
    NOT?: UsuarioRolScalarWhereInput | UsuarioRolScalarWhereInput[];
    usuarioId?: IntFilter<'UsuarioRol'> | number;
    roleId?: IntFilter<'UsuarioRol'> | number;
  };

  export type CursoUpsertWithWhereUniqueWithoutInstructorInput = {
    where: CursoWhereUniqueInput;
    update: XOR<
      CursoUpdateWithoutInstructorInput,
      CursoUncheckedUpdateWithoutInstructorInput
    >;
    create: XOR<
      CursoCreateWithoutInstructorInput,
      CursoUncheckedCreateWithoutInstructorInput
    >;
  };

  export type CursoUpdateWithWhereUniqueWithoutInstructorInput = {
    where: CursoWhereUniqueInput;
    data: XOR<
      CursoUpdateWithoutInstructorInput,
      CursoUncheckedUpdateWithoutInstructorInput
    >;
  };

  export type CursoUpdateManyWithWhereWithoutInstructorInput = {
    where: CursoScalarWhereInput;
    data: XOR<
      CursoUpdateManyMutationInput,
      CursoUncheckedUpdateManyWithoutInstructorInput
    >;
  };

  export type CursoScalarWhereInput = {
    AND?: CursoScalarWhereInput | CursoScalarWhereInput[];
    OR?: CursoScalarWhereInput[];
    NOT?: CursoScalarWhereInput | CursoScalarWhereInput[];
    id?: IntFilter<'Curso'> | number;
    slug?: StringFilter<'Curso'> | string;
    titulo?: StringFilter<'Curso'> | string;
    resumen?: StringNullableFilter<'Curso'> | string | null;
    descripcionMD?: StringNullableFilter<'Curso'> | string | null;
    requisitos?: StringNullableFilter<'Curso'> | string | null;
    precio?: IntFilter<'Curso'> | number;
    publicado?: BoolFilter<'Curso'> | boolean;
    nivel?: EnumNivelCursoFilter<'Curso'> | $Enums.NivelCurso;
    portada?: StringNullableFilter<'Curso'> | string | null;
    destacado?: BoolFilter<'Curso'> | boolean;
    tags?: JsonNullableFilter<'Curso'>;
    ratingProm?:
      | DecimalNullableFilter<'Curso'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    ratingConteo?: IntFilter<'Curso'> | number;
    creadoEn?: DateTimeFilter<'Curso'> | Date | string;
    instructorId?: IntNullableFilter<'Curso'> | number | null;
  };

  export type InscripcionUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: InscripcionWhereUniqueInput;
    update: XOR<
      InscripcionUpdateWithoutUsuarioInput,
      InscripcionUncheckedUpdateWithoutUsuarioInput
    >;
    create: XOR<
      InscripcionCreateWithoutUsuarioInput,
      InscripcionUncheckedCreateWithoutUsuarioInput
    >;
  };

  export type InscripcionUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: InscripcionWhereUniqueInput;
    data: XOR<
      InscripcionUpdateWithoutUsuarioInput,
      InscripcionUncheckedUpdateWithoutUsuarioInput
    >;
  };

  export type InscripcionUpdateManyWithWhereWithoutUsuarioInput = {
    where: InscripcionScalarWhereInput;
    data: XOR<
      InscripcionUpdateManyMutationInput,
      InscripcionUncheckedUpdateManyWithoutUsuarioInput
    >;
  };

  export type InscripcionScalarWhereInput = {
    AND?: InscripcionScalarWhereInput | InscripcionScalarWhereInput[];
    OR?: InscripcionScalarWhereInput[];
    NOT?: InscripcionScalarWhereInput | InscripcionScalarWhereInput[];
    id?: IntFilter<'Inscripcion'> | number;
    usuarioId?: IntFilter<'Inscripcion'> | number;
    cursoId?: IntFilter<'Inscripcion'> | number;
    estado?:
      | EnumEstadoInscripcionFilter<'Inscripcion'>
      | $Enums.EstadoInscripcion;
    progreso?: JsonFilter<'Inscripcion'>;
    creadoEn?: DateTimeFilter<'Inscripcion'> | Date | string;
    actualizadoEn?: DateTimeFilter<'Inscripcion'> | Date | string;
  };

  export type ResenaUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: ResenaWhereUniqueInput;
    update: XOR<
      ResenaUpdateWithoutUsuarioInput,
      ResenaUncheckedUpdateWithoutUsuarioInput
    >;
    create: XOR<
      ResenaCreateWithoutUsuarioInput,
      ResenaUncheckedCreateWithoutUsuarioInput
    >;
  };

  export type ResenaUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: ResenaWhereUniqueInput;
    data: XOR<
      ResenaUpdateWithoutUsuarioInput,
      ResenaUncheckedUpdateWithoutUsuarioInput
    >;
  };

  export type ResenaUpdateManyWithWhereWithoutUsuarioInput = {
    where: ResenaScalarWhereInput;
    data: XOR<
      ResenaUpdateManyMutationInput,
      ResenaUncheckedUpdateManyWithoutUsuarioInput
    >;
  };

  export type ResenaScalarWhereInput = {
    AND?: ResenaScalarWhereInput | ResenaScalarWhereInput[];
    OR?: ResenaScalarWhereInput[];
    NOT?: ResenaScalarWhereInput | ResenaScalarWhereInput[];
    id?: IntFilter<'Resena'> | number;
    cursoId?: IntNullableFilter<'Resena'> | number | null;
    productoId?: IntNullableFilter<'Resena'> | number | null;
    usuarioId?: IntFilter<'Resena'> | number;
    puntaje?: IntFilter<'Resena'> | number;
    comentario?: StringNullableFilter<'Resena'> | string | null;
    creadoEn?: DateTimeFilter<'Resena'> | Date | string;
  };

  export type ResenaRespuestaUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: ResenaRespuestaWhereUniqueInput;
    update: XOR<
      ResenaRespuestaUpdateWithoutUsuarioInput,
      ResenaRespuestaUncheckedUpdateWithoutUsuarioInput
    >;
    create: XOR<
      ResenaRespuestaCreateWithoutUsuarioInput,
      ResenaRespuestaUncheckedCreateWithoutUsuarioInput
    >;
  };

  export type ResenaRespuestaUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: ResenaRespuestaWhereUniqueInput;
    data: XOR<
      ResenaRespuestaUpdateWithoutUsuarioInput,
      ResenaRespuestaUncheckedUpdateWithoutUsuarioInput
    >;
  };

  export type ResenaRespuestaUpdateManyWithWhereWithoutUsuarioInput = {
    where: ResenaRespuestaScalarWhereInput;
    data: XOR<
      ResenaRespuestaUpdateManyMutationInput,
      ResenaRespuestaUncheckedUpdateManyWithoutUsuarioInput
    >;
  };

  export type ResenaRespuestaScalarWhereInput = {
    AND?: ResenaRespuestaScalarWhereInput | ResenaRespuestaScalarWhereInput[];
    OR?: ResenaRespuestaScalarWhereInput[];
    NOT?: ResenaRespuestaScalarWhereInput | ResenaRespuestaScalarWhereInput[];
    id?: IntFilter<'ResenaRespuesta'> | number;
    resenaId?: IntFilter<'ResenaRespuesta'> | number;
    usuarioId?: IntFilter<'ResenaRespuesta'> | number;
    parentId?: IntNullableFilter<'ResenaRespuesta'> | number | null;
    contenido?: StringFilter<'ResenaRespuesta'> | string;
    eliminado?: BoolFilter<'ResenaRespuesta'> | boolean;
    creadoEn?: DateTimeFilter<'ResenaRespuesta'> | Date | string;
    actualizadoEn?: DateTimeFilter<'ResenaRespuesta'> | Date | string;
  };

  export type FavoritoUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: FavoritoWhereUniqueInput;
    update: XOR<
      FavoritoUpdateWithoutUsuarioInput,
      FavoritoUncheckedUpdateWithoutUsuarioInput
    >;
    create: XOR<
      FavoritoCreateWithoutUsuarioInput,
      FavoritoUncheckedCreateWithoutUsuarioInput
    >;
  };

  export type FavoritoUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: FavoritoWhereUniqueInput;
    data: XOR<
      FavoritoUpdateWithoutUsuarioInput,
      FavoritoUncheckedUpdateWithoutUsuarioInput
    >;
  };

  export type FavoritoUpdateManyWithWhereWithoutUsuarioInput = {
    where: FavoritoScalarWhereInput;
    data: XOR<
      FavoritoUpdateManyMutationInput,
      FavoritoUncheckedUpdateManyWithoutUsuarioInput
    >;
  };

  export type FavoritoScalarWhereInput = {
    AND?: FavoritoScalarWhereInput | FavoritoScalarWhereInput[];
    OR?: FavoritoScalarWhereInput[];
    NOT?: FavoritoScalarWhereInput | FavoritoScalarWhereInput[];
    id?: IntFilter<'Favorito'> | number;
    usuarioId?: IntFilter<'Favorito'> | number;
    productoId?: IntFilter<'Favorito'> | number;
    creadoEn?: DateTimeFilter<'Favorito'> | Date | string;
  };

  export type ResenaLikeUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: ResenaLikeWhereUniqueInput;
    update: XOR<
      ResenaLikeUpdateWithoutUsuarioInput,
      ResenaLikeUncheckedUpdateWithoutUsuarioInput
    >;
    create: XOR<
      ResenaLikeCreateWithoutUsuarioInput,
      ResenaLikeUncheckedCreateWithoutUsuarioInput
    >;
  };

  export type ResenaLikeUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: ResenaLikeWhereUniqueInput;
    data: XOR<
      ResenaLikeUpdateWithoutUsuarioInput,
      ResenaLikeUncheckedUpdateWithoutUsuarioInput
    >;
  };

  export type ResenaLikeUpdateManyWithWhereWithoutUsuarioInput = {
    where: ResenaLikeScalarWhereInput;
    data: XOR<
      ResenaLikeUpdateManyMutationInput,
      ResenaLikeUncheckedUpdateManyWithoutUsuarioInput
    >;
  };

  export type ResenaLikeScalarWhereInput = {
    AND?: ResenaLikeScalarWhereInput | ResenaLikeScalarWhereInput[];
    OR?: ResenaLikeScalarWhereInput[];
    NOT?: ResenaLikeScalarWhereInput | ResenaLikeScalarWhereInput[];
    id?: IntFilter<'ResenaLike'> | number;
    resenaId?: IntFilter<'ResenaLike'> | number;
    usuarioId?: IntFilter<'ResenaLike'> | number;
    tipo?: EnumTipoLikeFilter<'ResenaLike'> | $Enums.TipoLike;
    creadoEn?: DateTimeFilter<'ResenaLike'> | Date | string;
  };

  export type OrdenUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: OrdenWhereUniqueInput;
    update: XOR<
      OrdenUpdateWithoutUsuarioInput,
      OrdenUncheckedUpdateWithoutUsuarioInput
    >;
    create: XOR<
      OrdenCreateWithoutUsuarioInput,
      OrdenUncheckedCreateWithoutUsuarioInput
    >;
  };

  export type OrdenUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: OrdenWhereUniqueInput;
    data: XOR<
      OrdenUpdateWithoutUsuarioInput,
      OrdenUncheckedUpdateWithoutUsuarioInput
    >;
  };

  export type OrdenUpdateManyWithWhereWithoutUsuarioInput = {
    where: OrdenScalarWhereInput;
    data: XOR<
      OrdenUpdateManyMutationInput,
      OrdenUncheckedUpdateManyWithoutUsuarioInput
    >;
  };

  export type OrdenScalarWhereInput = {
    AND?: OrdenScalarWhereInput | OrdenScalarWhereInput[];
    OR?: OrdenScalarWhereInput[];
    NOT?: OrdenScalarWhereInput | OrdenScalarWhereInput[];
    id?: IntFilter<'Orden'> | number;
    usuarioId?: IntFilter<'Orden'> | number;
    estado?: EnumEstadoOrdenFilter<'Orden'> | $Enums.EstadoOrden;
    total?: IntFilter<'Orden'> | number;
    moneda?: StringFilter<'Orden'> | string;
    referenciaPago?: StringNullableFilter<'Orden'> | string | null;
    creadoEn?: DateTimeFilter<'Orden'> | Date | string;
    actualizadoEn?: DateTimeFilter<'Orden'> | Date | string;
    esSuscripcion?: BoolFilter<'Orden'> | boolean;
    suscripcionActiva?: BoolNullableFilter<'Orden'> | boolean | null;
    suscripcionId?: StringNullableFilter<'Orden'> | string | null;
    suscripcionFrecuencia?: IntNullableFilter<'Orden'> | number | null;
    suscripcionTipoFrecuencia?: StringNullableFilter<'Orden'> | string | null;
    metadatos?: JsonNullableFilter<'Orden'>;
    direccionEnvioId?: IntNullableFilter<'Orden'> | number | null;
    direccionFacturacionId?: IntNullableFilter<'Orden'> | number | null;
  };

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput;
    update: XOR<
      AuditLogUpdateWithoutUserInput,
      AuditLogUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      AuditLogCreateWithoutUserInput,
      AuditLogUncheckedCreateWithoutUserInput
    >;
  };

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput;
    data: XOR<
      AuditLogUpdateWithoutUserInput,
      AuditLogUncheckedUpdateWithoutUserInput
    >;
  };

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput;
    data: XOR<
      AuditLogUpdateManyMutationInput,
      AuditLogUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[];
    OR?: AuditLogScalarWhereInput[];
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[];
    id?: IntFilter<'AuditLog'> | number;
    tableName?: StringFilter<'AuditLog'> | string;
    recordId?: StringFilter<'AuditLog'> | string;
    action?: StringFilter<'AuditLog'> | string;
    oldData?: JsonNullableFilter<'AuditLog'>;
    newData?: JsonNullableFilter<'AuditLog'>;
    userId?: IntFilter<'AuditLog'> | number;
    userAgent?: StringNullableFilter<'AuditLog'> | string | null;
    ipAddress?: StringNullableFilter<'AuditLog'> | string | null;
    endpoint?: StringNullableFilter<'AuditLog'> | string | null;
    timestamp?: DateTimeFilter<'AuditLog'> | Date | string;
  };

  export type CarritoUpsertWithoutUsuarioInput = {
    update: XOR<
      CarritoUpdateWithoutUsuarioInput,
      CarritoUncheckedUpdateWithoutUsuarioInput
    >;
    create: XOR<
      CarritoCreateWithoutUsuarioInput,
      CarritoUncheckedCreateWithoutUsuarioInput
    >;
    where?: CarritoWhereInput;
  };

  export type CarritoUpdateToOneWithWhereWithoutUsuarioInput = {
    where?: CarritoWhereInput;
    data: XOR<
      CarritoUpdateWithoutUsuarioInput,
      CarritoUncheckedUpdateWithoutUsuarioInput
    >;
  };

  export type CarritoUpdateWithoutUsuarioInput = {
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    items?: ItemCarritoUpdateManyWithoutCarritoNestedInput;
  };

  export type CarritoUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    items?: ItemCarritoUncheckedUpdateManyWithoutCarritoNestedInput;
  };

  export type NotificacionUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: NotificacionWhereUniqueInput;
    update: XOR<
      NotificacionUpdateWithoutUsuarioInput,
      NotificacionUncheckedUpdateWithoutUsuarioInput
    >;
    create: XOR<
      NotificacionCreateWithoutUsuarioInput,
      NotificacionUncheckedCreateWithoutUsuarioInput
    >;
  };

  export type NotificacionUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: NotificacionWhereUniqueInput;
    data: XOR<
      NotificacionUpdateWithoutUsuarioInput,
      NotificacionUncheckedUpdateWithoutUsuarioInput
    >;
  };

  export type NotificacionUpdateManyWithWhereWithoutUsuarioInput = {
    where: NotificacionScalarWhereInput;
    data: XOR<
      NotificacionUpdateManyMutationInput,
      NotificacionUncheckedUpdateManyWithoutUsuarioInput
    >;
  };

  export type NotificacionScalarWhereInput = {
    AND?: NotificacionScalarWhereInput | NotificacionScalarWhereInput[];
    OR?: NotificacionScalarWhereInput[];
    NOT?: NotificacionScalarWhereInput | NotificacionScalarWhereInput[];
    id?: IntFilter<'Notificacion'> | number;
    usuarioId?: IntFilter<'Notificacion'> | number;
    tipo?: EnumTipoNotificacionFilter<'Notificacion'> | $Enums.TipoNotificacion;
    titulo?: StringFilter<'Notificacion'> | string;
    mensaje?: StringFilter<'Notificacion'> | string;
    leida?: BoolFilter<'Notificacion'> | boolean;
    url?: StringNullableFilter<'Notificacion'> | string | null;
    metadata?: JsonNullableFilter<'Notificacion'>;
    creadoEn?: DateTimeFilter<'Notificacion'> | Date | string;
  };

  export type UsuarioRolCreateWithoutRoleInput = {
    usuario: UsuarioCreateNestedOneWithoutRolesInput;
  };

  export type UsuarioRolUncheckedCreateWithoutRoleInput = {
    usuarioId: number;
  };

  export type UsuarioRolCreateOrConnectWithoutRoleInput = {
    where: UsuarioRolWhereUniqueInput;
    create: XOR<
      UsuarioRolCreateWithoutRoleInput,
      UsuarioRolUncheckedCreateWithoutRoleInput
    >;
  };

  export type UsuarioRolCreateManyRoleInputEnvelope = {
    data: UsuarioRolCreateManyRoleInput | UsuarioRolCreateManyRoleInput[];
    skipDuplicates?: boolean;
  };

  export type UsuarioRolUpsertWithWhereUniqueWithoutRoleInput = {
    where: UsuarioRolWhereUniqueInput;
    update: XOR<
      UsuarioRolUpdateWithoutRoleInput,
      UsuarioRolUncheckedUpdateWithoutRoleInput
    >;
    create: XOR<
      UsuarioRolCreateWithoutRoleInput,
      UsuarioRolUncheckedCreateWithoutRoleInput
    >;
  };

  export type UsuarioRolUpdateWithWhereUniqueWithoutRoleInput = {
    where: UsuarioRolWhereUniqueInput;
    data: XOR<
      UsuarioRolUpdateWithoutRoleInput,
      UsuarioRolUncheckedUpdateWithoutRoleInput
    >;
  };

  export type UsuarioRolUpdateManyWithWhereWithoutRoleInput = {
    where: UsuarioRolScalarWhereInput;
    data: XOR<
      UsuarioRolUpdateManyMutationInput,
      UsuarioRolUncheckedUpdateManyWithoutRoleInput
    >;
  };

  export type UsuarioCreateWithoutRolesInput = {
    email: string;
    nombre?: string | null;
    passwordHash: string;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
    emailVerificadoEn?: Date | string | null;
    cursosImpartidos?: CursoCreateNestedManyWithoutInstructorInput;
    inscripciones?: InscripcionCreateNestedManyWithoutUsuarioInput;
    resenas?: ResenaCreateNestedManyWithoutUsuarioInput;
    resenaRespuestas?: ResenaRespuestaCreateNestedManyWithoutUsuarioInput;
    favoritos?: FavoritoCreateNestedManyWithoutUsuarioInput;
    resenaLikes?: ResenaLikeCreateNestedManyWithoutUsuarioInput;
    ordenes?: OrdenCreateNestedManyWithoutUsuarioInput;
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput;
    carrito?: CarritoCreateNestedOneWithoutUsuarioInput;
    notificaciones?: NotificacionCreateNestedManyWithoutUsuarioInput;
  };

  export type UsuarioUncheckedCreateWithoutRolesInput = {
    id?: number;
    email: string;
    nombre?: string | null;
    passwordHash: string;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
    emailVerificadoEn?: Date | string | null;
    cursosImpartidos?: CursoUncheckedCreateNestedManyWithoutInstructorInput;
    inscripciones?: InscripcionUncheckedCreateNestedManyWithoutUsuarioInput;
    resenas?: ResenaUncheckedCreateNestedManyWithoutUsuarioInput;
    resenaRespuestas?: ResenaRespuestaUncheckedCreateNestedManyWithoutUsuarioInput;
    favoritos?: FavoritoUncheckedCreateNestedManyWithoutUsuarioInput;
    resenaLikes?: ResenaLikeUncheckedCreateNestedManyWithoutUsuarioInput;
    ordenes?: OrdenUncheckedCreateNestedManyWithoutUsuarioInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    carrito?: CarritoUncheckedCreateNestedOneWithoutUsuarioInput;
    notificaciones?: NotificacionUncheckedCreateNestedManyWithoutUsuarioInput;
  };

  export type UsuarioCreateOrConnectWithoutRolesInput = {
    where: UsuarioWhereUniqueInput;
    create: XOR<
      UsuarioCreateWithoutRolesInput,
      UsuarioUncheckedCreateWithoutRolesInput
    >;
  };

  export type RoleCreateWithoutUsuariosInput = {
    slug: string;
    name: string;
    createdAt?: Date | string;
  };

  export type RoleUncheckedCreateWithoutUsuariosInput = {
    id?: number;
    slug: string;
    name: string;
    createdAt?: Date | string;
  };

  export type RoleCreateOrConnectWithoutUsuariosInput = {
    where: RoleWhereUniqueInput;
    create: XOR<
      RoleCreateWithoutUsuariosInput,
      RoleUncheckedCreateWithoutUsuariosInput
    >;
  };

  export type UsuarioUpsertWithoutRolesInput = {
    update: XOR<
      UsuarioUpdateWithoutRolesInput,
      UsuarioUncheckedUpdateWithoutRolesInput
    >;
    create: XOR<
      UsuarioCreateWithoutRolesInput,
      UsuarioUncheckedCreateWithoutRolesInput
    >;
    where?: UsuarioWhereInput;
  };

  export type UsuarioUpdateToOneWithWhereWithoutRolesInput = {
    where?: UsuarioWhereInput;
    data: XOR<
      UsuarioUpdateWithoutRolesInput,
      UsuarioUncheckedUpdateWithoutRolesInput
    >;
  };

  export type UsuarioUpdateWithoutRolesInput = {
    email?: StringFieldUpdateOperationsInput | string;
    nombre?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    emailVerificadoEn?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    cursosImpartidos?: CursoUpdateManyWithoutInstructorNestedInput;
    inscripciones?: InscripcionUpdateManyWithoutUsuarioNestedInput;
    resenas?: ResenaUpdateManyWithoutUsuarioNestedInput;
    resenaRespuestas?: ResenaRespuestaUpdateManyWithoutUsuarioNestedInput;
    favoritos?: FavoritoUpdateManyWithoutUsuarioNestedInput;
    resenaLikes?: ResenaLikeUpdateManyWithoutUsuarioNestedInput;
    ordenes?: OrdenUpdateManyWithoutUsuarioNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput;
    carrito?: CarritoUpdateOneWithoutUsuarioNestedInput;
    notificaciones?: NotificacionUpdateManyWithoutUsuarioNestedInput;
  };

  export type UsuarioUncheckedUpdateWithoutRolesInput = {
    id?: IntFieldUpdateOperationsInput | number;
    email?: StringFieldUpdateOperationsInput | string;
    nombre?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    emailVerificadoEn?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    cursosImpartidos?: CursoUncheckedUpdateManyWithoutInstructorNestedInput;
    inscripciones?: InscripcionUncheckedUpdateManyWithoutUsuarioNestedInput;
    resenas?: ResenaUncheckedUpdateManyWithoutUsuarioNestedInput;
    resenaRespuestas?: ResenaRespuestaUncheckedUpdateManyWithoutUsuarioNestedInput;
    favoritos?: FavoritoUncheckedUpdateManyWithoutUsuarioNestedInput;
    resenaLikes?: ResenaLikeUncheckedUpdateManyWithoutUsuarioNestedInput;
    ordenes?: OrdenUncheckedUpdateManyWithoutUsuarioNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    carrito?: CarritoUncheckedUpdateOneWithoutUsuarioNestedInput;
    notificaciones?: NotificacionUncheckedUpdateManyWithoutUsuarioNestedInput;
  };

  export type RoleUpsertWithoutUsuariosInput = {
    update: XOR<
      RoleUpdateWithoutUsuariosInput,
      RoleUncheckedUpdateWithoutUsuariosInput
    >;
    create: XOR<
      RoleCreateWithoutUsuariosInput,
      RoleUncheckedCreateWithoutUsuariosInput
    >;
    where?: RoleWhereInput;
  };

  export type RoleUpdateToOneWithWhereWithoutUsuariosInput = {
    where?: RoleWhereInput;
    data: XOR<
      RoleUpdateWithoutUsuariosInput,
      RoleUncheckedUpdateWithoutUsuariosInput
    >;
  };

  export type RoleUpdateWithoutUsuariosInput = {
    slug?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type RoleUncheckedUpdateWithoutUsuariosInput = {
    id?: IntFieldUpdateOperationsInput | number;
    slug?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UsuarioCreateWithoutFavoritosInput = {
    email: string;
    nombre?: string | null;
    passwordHash: string;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
    emailVerificadoEn?: Date | string | null;
    roles?: UsuarioRolCreateNestedManyWithoutUsuarioInput;
    cursosImpartidos?: CursoCreateNestedManyWithoutInstructorInput;
    inscripciones?: InscripcionCreateNestedManyWithoutUsuarioInput;
    resenas?: ResenaCreateNestedManyWithoutUsuarioInput;
    resenaRespuestas?: ResenaRespuestaCreateNestedManyWithoutUsuarioInput;
    resenaLikes?: ResenaLikeCreateNestedManyWithoutUsuarioInput;
    ordenes?: OrdenCreateNestedManyWithoutUsuarioInput;
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput;
    carrito?: CarritoCreateNestedOneWithoutUsuarioInput;
    notificaciones?: NotificacionCreateNestedManyWithoutUsuarioInput;
  };

  export type UsuarioUncheckedCreateWithoutFavoritosInput = {
    id?: number;
    email: string;
    nombre?: string | null;
    passwordHash: string;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
    emailVerificadoEn?: Date | string | null;
    roles?: UsuarioRolUncheckedCreateNestedManyWithoutUsuarioInput;
    cursosImpartidos?: CursoUncheckedCreateNestedManyWithoutInstructorInput;
    inscripciones?: InscripcionUncheckedCreateNestedManyWithoutUsuarioInput;
    resenas?: ResenaUncheckedCreateNestedManyWithoutUsuarioInput;
    resenaRespuestas?: ResenaRespuestaUncheckedCreateNestedManyWithoutUsuarioInput;
    resenaLikes?: ResenaLikeUncheckedCreateNestedManyWithoutUsuarioInput;
    ordenes?: OrdenUncheckedCreateNestedManyWithoutUsuarioInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    carrito?: CarritoUncheckedCreateNestedOneWithoutUsuarioInput;
    notificaciones?: NotificacionUncheckedCreateNestedManyWithoutUsuarioInput;
  };

  export type UsuarioCreateOrConnectWithoutFavoritosInput = {
    where: UsuarioWhereUniqueInput;
    create: XOR<
      UsuarioCreateWithoutFavoritosInput,
      UsuarioUncheckedCreateWithoutFavoritosInput
    >;
  };

  export type ProductoCreateWithoutFavoritosInput = {
    slug: string;
    titulo: string;
    precio: number;
    stock?: number;
    publicado?: boolean;
    destacado?: boolean;
    imagen?: string | null;
    descripcionMD?: string | null;
    precioLista?: number | null;
    ratingProm?: Decimal | DecimalJsLike | number | string | null;
    ratingConteo?: number;
    creadoEn?: Date | string;
    marca?: MarcaCreateNestedOneWithoutProductosInput;
    categoria?: CategoriaCreateNestedOneWithoutProductosInput;
    imagenes?: ProductoImagenCreateNestedManyWithoutProductoInput;
    resenas?: ResenaCreateNestedManyWithoutProductoInput;
    itemsCarrito?: ItemCarritoCreateNestedManyWithoutProductoInput;
  };

  export type ProductoUncheckedCreateWithoutFavoritosInput = {
    id?: number;
    slug: string;
    titulo: string;
    precio: number;
    stock?: number;
    publicado?: boolean;
    destacado?: boolean;
    imagen?: string | null;
    descripcionMD?: string | null;
    precioLista?: number | null;
    ratingProm?: Decimal | DecimalJsLike | number | string | null;
    ratingConteo?: number;
    creadoEn?: Date | string;
    marcaId?: number | null;
    categoriaId?: number | null;
    imagenes?: ProductoImagenUncheckedCreateNestedManyWithoutProductoInput;
    resenas?: ResenaUncheckedCreateNestedManyWithoutProductoInput;
    itemsCarrito?: ItemCarritoUncheckedCreateNestedManyWithoutProductoInput;
  };

  export type ProductoCreateOrConnectWithoutFavoritosInput = {
    where: ProductoWhereUniqueInput;
    create: XOR<
      ProductoCreateWithoutFavoritosInput,
      ProductoUncheckedCreateWithoutFavoritosInput
    >;
  };

  export type UsuarioUpsertWithoutFavoritosInput = {
    update: XOR<
      UsuarioUpdateWithoutFavoritosInput,
      UsuarioUncheckedUpdateWithoutFavoritosInput
    >;
    create: XOR<
      UsuarioCreateWithoutFavoritosInput,
      UsuarioUncheckedCreateWithoutFavoritosInput
    >;
    where?: UsuarioWhereInput;
  };

  export type UsuarioUpdateToOneWithWhereWithoutFavoritosInput = {
    where?: UsuarioWhereInput;
    data: XOR<
      UsuarioUpdateWithoutFavoritosInput,
      UsuarioUncheckedUpdateWithoutFavoritosInput
    >;
  };

  export type UsuarioUpdateWithoutFavoritosInput = {
    email?: StringFieldUpdateOperationsInput | string;
    nombre?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    emailVerificadoEn?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    roles?: UsuarioRolUpdateManyWithoutUsuarioNestedInput;
    cursosImpartidos?: CursoUpdateManyWithoutInstructorNestedInput;
    inscripciones?: InscripcionUpdateManyWithoutUsuarioNestedInput;
    resenas?: ResenaUpdateManyWithoutUsuarioNestedInput;
    resenaRespuestas?: ResenaRespuestaUpdateManyWithoutUsuarioNestedInput;
    resenaLikes?: ResenaLikeUpdateManyWithoutUsuarioNestedInput;
    ordenes?: OrdenUpdateManyWithoutUsuarioNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput;
    carrito?: CarritoUpdateOneWithoutUsuarioNestedInput;
    notificaciones?: NotificacionUpdateManyWithoutUsuarioNestedInput;
  };

  export type UsuarioUncheckedUpdateWithoutFavoritosInput = {
    id?: IntFieldUpdateOperationsInput | number;
    email?: StringFieldUpdateOperationsInput | string;
    nombre?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    emailVerificadoEn?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    roles?: UsuarioRolUncheckedUpdateManyWithoutUsuarioNestedInput;
    cursosImpartidos?: CursoUncheckedUpdateManyWithoutInstructorNestedInput;
    inscripciones?: InscripcionUncheckedUpdateManyWithoutUsuarioNestedInput;
    resenas?: ResenaUncheckedUpdateManyWithoutUsuarioNestedInput;
    resenaRespuestas?: ResenaRespuestaUncheckedUpdateManyWithoutUsuarioNestedInput;
    resenaLikes?: ResenaLikeUncheckedUpdateManyWithoutUsuarioNestedInput;
    ordenes?: OrdenUncheckedUpdateManyWithoutUsuarioNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    carrito?: CarritoUncheckedUpdateOneWithoutUsuarioNestedInput;
    notificaciones?: NotificacionUncheckedUpdateManyWithoutUsuarioNestedInput;
  };

  export type ProductoUpsertWithoutFavoritosInput = {
    update: XOR<
      ProductoUpdateWithoutFavoritosInput,
      ProductoUncheckedUpdateWithoutFavoritosInput
    >;
    create: XOR<
      ProductoCreateWithoutFavoritosInput,
      ProductoUncheckedCreateWithoutFavoritosInput
    >;
    where?: ProductoWhereInput;
  };

  export type ProductoUpdateToOneWithWhereWithoutFavoritosInput = {
    where?: ProductoWhereInput;
    data: XOR<
      ProductoUpdateWithoutFavoritosInput,
      ProductoUncheckedUpdateWithoutFavoritosInput
    >;
  };

  export type ProductoUpdateWithoutFavoritosInput = {
    slug?: StringFieldUpdateOperationsInput | string;
    titulo?: StringFieldUpdateOperationsInput | string;
    precio?: IntFieldUpdateOperationsInput | number;
    stock?: IntFieldUpdateOperationsInput | number;
    publicado?: BoolFieldUpdateOperationsInput | boolean;
    destacado?: BoolFieldUpdateOperationsInput | boolean;
    imagen?: NullableStringFieldUpdateOperationsInput | string | null;
    descripcionMD?: NullableStringFieldUpdateOperationsInput | string | null;
    precioLista?: NullableIntFieldUpdateOperationsInput | number | null;
    ratingProm?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    ratingConteo?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    marca?: MarcaUpdateOneWithoutProductosNestedInput;
    categoria?: CategoriaUpdateOneWithoutProductosNestedInput;
    imagenes?: ProductoImagenUpdateManyWithoutProductoNestedInput;
    resenas?: ResenaUpdateManyWithoutProductoNestedInput;
    itemsCarrito?: ItemCarritoUpdateManyWithoutProductoNestedInput;
  };

  export type ProductoUncheckedUpdateWithoutFavoritosInput = {
    id?: IntFieldUpdateOperationsInput | number;
    slug?: StringFieldUpdateOperationsInput | string;
    titulo?: StringFieldUpdateOperationsInput | string;
    precio?: IntFieldUpdateOperationsInput | number;
    stock?: IntFieldUpdateOperationsInput | number;
    publicado?: BoolFieldUpdateOperationsInput | boolean;
    destacado?: BoolFieldUpdateOperationsInput | boolean;
    imagen?: NullableStringFieldUpdateOperationsInput | string | null;
    descripcionMD?: NullableStringFieldUpdateOperationsInput | string | null;
    precioLista?: NullableIntFieldUpdateOperationsInput | number | null;
    ratingProm?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    ratingConteo?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    marcaId?: NullableIntFieldUpdateOperationsInput | number | null;
    categoriaId?: NullableIntFieldUpdateOperationsInput | number | null;
    imagenes?: ProductoImagenUncheckedUpdateManyWithoutProductoNestedInput;
    resenas?: ResenaUncheckedUpdateManyWithoutProductoNestedInput;
    itemsCarrito?: ItemCarritoUncheckedUpdateManyWithoutProductoNestedInput;
  };

  export type UsuarioCreateWithoutCursosImpartidosInput = {
    email: string;
    nombre?: string | null;
    passwordHash: string;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
    emailVerificadoEn?: Date | string | null;
    roles?: UsuarioRolCreateNestedManyWithoutUsuarioInput;
    inscripciones?: InscripcionCreateNestedManyWithoutUsuarioInput;
    resenas?: ResenaCreateNestedManyWithoutUsuarioInput;
    resenaRespuestas?: ResenaRespuestaCreateNestedManyWithoutUsuarioInput;
    favoritos?: FavoritoCreateNestedManyWithoutUsuarioInput;
    resenaLikes?: ResenaLikeCreateNestedManyWithoutUsuarioInput;
    ordenes?: OrdenCreateNestedManyWithoutUsuarioInput;
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput;
    carrito?: CarritoCreateNestedOneWithoutUsuarioInput;
    notificaciones?: NotificacionCreateNestedManyWithoutUsuarioInput;
  };

  export type UsuarioUncheckedCreateWithoutCursosImpartidosInput = {
    id?: number;
    email: string;
    nombre?: string | null;
    passwordHash: string;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
    emailVerificadoEn?: Date | string | null;
    roles?: UsuarioRolUncheckedCreateNestedManyWithoutUsuarioInput;
    inscripciones?: InscripcionUncheckedCreateNestedManyWithoutUsuarioInput;
    resenas?: ResenaUncheckedCreateNestedManyWithoutUsuarioInput;
    resenaRespuestas?: ResenaRespuestaUncheckedCreateNestedManyWithoutUsuarioInput;
    favoritos?: FavoritoUncheckedCreateNestedManyWithoutUsuarioInput;
    resenaLikes?: ResenaLikeUncheckedCreateNestedManyWithoutUsuarioInput;
    ordenes?: OrdenUncheckedCreateNestedManyWithoutUsuarioInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    carrito?: CarritoUncheckedCreateNestedOneWithoutUsuarioInput;
    notificaciones?: NotificacionUncheckedCreateNestedManyWithoutUsuarioInput;
  };

  export type UsuarioCreateOrConnectWithoutCursosImpartidosInput = {
    where: UsuarioWhereUniqueInput;
    create: XOR<
      UsuarioCreateWithoutCursosImpartidosInput,
      UsuarioUncheckedCreateWithoutCursosImpartidosInput
    >;
  };

  export type ModuloCreateWithoutCursoInput = {
    titulo: string;
    orden: number;
    parentId?: number | null;
    lecciones?: LeccionCreateNestedManyWithoutModuloInput;
  };

  export type ModuloUncheckedCreateWithoutCursoInput = {
    id?: number;
    titulo: string;
    orden: number;
    parentId?: number | null;
    lecciones?: LeccionUncheckedCreateNestedManyWithoutModuloInput;
  };

  export type ModuloCreateOrConnectWithoutCursoInput = {
    where: ModuloWhereUniqueInput;
    create: XOR<
      ModuloCreateWithoutCursoInput,
      ModuloUncheckedCreateWithoutCursoInput
    >;
  };

  export type ModuloCreateManyCursoInputEnvelope = {
    data: ModuloCreateManyCursoInput | ModuloCreateManyCursoInput[];
    skipDuplicates?: boolean;
  };

  export type ResenaCreateWithoutCursoInput = {
    puntaje: number;
    comentario?: string | null;
    creadoEn?: Date | string;
    producto?: ProductoCreateNestedOneWithoutResenasInput;
    usuario: UsuarioCreateNestedOneWithoutResenasInput;
    respuestas?: ResenaRespuestaCreateNestedManyWithoutResenaInput;
    likes?: ResenaLikeCreateNestedManyWithoutResenaInput;
  };

  export type ResenaUncheckedCreateWithoutCursoInput = {
    id?: number;
    productoId?: number | null;
    usuarioId: number;
    puntaje: number;
    comentario?: string | null;
    creadoEn?: Date | string;
    respuestas?: ResenaRespuestaUncheckedCreateNestedManyWithoutResenaInput;
    likes?: ResenaLikeUncheckedCreateNestedManyWithoutResenaInput;
  };

  export type ResenaCreateOrConnectWithoutCursoInput = {
    where: ResenaWhereUniqueInput;
    create: XOR<
      ResenaCreateWithoutCursoInput,
      ResenaUncheckedCreateWithoutCursoInput
    >;
  };

  export type ResenaCreateManyCursoInputEnvelope = {
    data: ResenaCreateManyCursoInput | ResenaCreateManyCursoInput[];
    skipDuplicates?: boolean;
  };

  export type InscripcionCreateWithoutCursoInput = {
    estado?: $Enums.EstadoInscripcion;
    progreso: JsonNullValueInput | InputJsonValue;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
    usuario: UsuarioCreateNestedOneWithoutInscripcionesInput;
  };

  export type InscripcionUncheckedCreateWithoutCursoInput = {
    id?: number;
    usuarioId: number;
    estado?: $Enums.EstadoInscripcion;
    progreso: JsonNullValueInput | InputJsonValue;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
  };

  export type InscripcionCreateOrConnectWithoutCursoInput = {
    where: InscripcionWhereUniqueInput;
    create: XOR<
      InscripcionCreateWithoutCursoInput,
      InscripcionUncheckedCreateWithoutCursoInput
    >;
  };

  export type InscripcionCreateManyCursoInputEnvelope = {
    data: InscripcionCreateManyCursoInput | InscripcionCreateManyCursoInput[];
    skipDuplicates?: boolean;
  };

  export type ItemCarritoCreateWithoutCursoInput = {
    tipo: $Enums.TipoItemOrden;
    cantidad?: number;
    creadoEn?: Date | string;
    carrito: CarritoCreateNestedOneWithoutItemsInput;
    producto?: ProductoCreateNestedOneWithoutItemsCarritoInput;
  };

  export type ItemCarritoUncheckedCreateWithoutCursoInput = {
    id?: number;
    carritoId: number;
    tipo: $Enums.TipoItemOrden;
    productoId?: number | null;
    cantidad?: number;
    creadoEn?: Date | string;
  };

  export type ItemCarritoCreateOrConnectWithoutCursoInput = {
    where: ItemCarritoWhereUniqueInput;
    create: XOR<
      ItemCarritoCreateWithoutCursoInput,
      ItemCarritoUncheckedCreateWithoutCursoInput
    >;
  };

  export type ItemCarritoCreateManyCursoInputEnvelope = {
    data: ItemCarritoCreateManyCursoInput | ItemCarritoCreateManyCursoInput[];
    skipDuplicates?: boolean;
  };

  export type UsuarioUpsertWithoutCursosImpartidosInput = {
    update: XOR<
      UsuarioUpdateWithoutCursosImpartidosInput,
      UsuarioUncheckedUpdateWithoutCursosImpartidosInput
    >;
    create: XOR<
      UsuarioCreateWithoutCursosImpartidosInput,
      UsuarioUncheckedCreateWithoutCursosImpartidosInput
    >;
    where?: UsuarioWhereInput;
  };

  export type UsuarioUpdateToOneWithWhereWithoutCursosImpartidosInput = {
    where?: UsuarioWhereInput;
    data: XOR<
      UsuarioUpdateWithoutCursosImpartidosInput,
      UsuarioUncheckedUpdateWithoutCursosImpartidosInput
    >;
  };

  export type UsuarioUpdateWithoutCursosImpartidosInput = {
    email?: StringFieldUpdateOperationsInput | string;
    nombre?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    emailVerificadoEn?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    roles?: UsuarioRolUpdateManyWithoutUsuarioNestedInput;
    inscripciones?: InscripcionUpdateManyWithoutUsuarioNestedInput;
    resenas?: ResenaUpdateManyWithoutUsuarioNestedInput;
    resenaRespuestas?: ResenaRespuestaUpdateManyWithoutUsuarioNestedInput;
    favoritos?: FavoritoUpdateManyWithoutUsuarioNestedInput;
    resenaLikes?: ResenaLikeUpdateManyWithoutUsuarioNestedInput;
    ordenes?: OrdenUpdateManyWithoutUsuarioNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput;
    carrito?: CarritoUpdateOneWithoutUsuarioNestedInput;
    notificaciones?: NotificacionUpdateManyWithoutUsuarioNestedInput;
  };

  export type UsuarioUncheckedUpdateWithoutCursosImpartidosInput = {
    id?: IntFieldUpdateOperationsInput | number;
    email?: StringFieldUpdateOperationsInput | string;
    nombre?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    emailVerificadoEn?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    roles?: UsuarioRolUncheckedUpdateManyWithoutUsuarioNestedInput;
    inscripciones?: InscripcionUncheckedUpdateManyWithoutUsuarioNestedInput;
    resenas?: ResenaUncheckedUpdateManyWithoutUsuarioNestedInput;
    resenaRespuestas?: ResenaRespuestaUncheckedUpdateManyWithoutUsuarioNestedInput;
    favoritos?: FavoritoUncheckedUpdateManyWithoutUsuarioNestedInput;
    resenaLikes?: ResenaLikeUncheckedUpdateManyWithoutUsuarioNestedInput;
    ordenes?: OrdenUncheckedUpdateManyWithoutUsuarioNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    carrito?: CarritoUncheckedUpdateOneWithoutUsuarioNestedInput;
    notificaciones?: NotificacionUncheckedUpdateManyWithoutUsuarioNestedInput;
  };

  export type ModuloUpsertWithWhereUniqueWithoutCursoInput = {
    where: ModuloWhereUniqueInput;
    update: XOR<
      ModuloUpdateWithoutCursoInput,
      ModuloUncheckedUpdateWithoutCursoInput
    >;
    create: XOR<
      ModuloCreateWithoutCursoInput,
      ModuloUncheckedCreateWithoutCursoInput
    >;
  };

  export type ModuloUpdateWithWhereUniqueWithoutCursoInput = {
    where: ModuloWhereUniqueInput;
    data: XOR<
      ModuloUpdateWithoutCursoInput,
      ModuloUncheckedUpdateWithoutCursoInput
    >;
  };

  export type ModuloUpdateManyWithWhereWithoutCursoInput = {
    where: ModuloScalarWhereInput;
    data: XOR<
      ModuloUpdateManyMutationInput,
      ModuloUncheckedUpdateManyWithoutCursoInput
    >;
  };

  export type ModuloScalarWhereInput = {
    AND?: ModuloScalarWhereInput | ModuloScalarWhereInput[];
    OR?: ModuloScalarWhereInput[];
    NOT?: ModuloScalarWhereInput | ModuloScalarWhereInput[];
    id?: IntFilter<'Modulo'> | number;
    cursoId?: IntFilter<'Modulo'> | number;
    titulo?: StringFilter<'Modulo'> | string;
    orden?: IntFilter<'Modulo'> | number;
    parentId?: IntNullableFilter<'Modulo'> | number | null;
  };

  export type ResenaUpsertWithWhereUniqueWithoutCursoInput = {
    where: ResenaWhereUniqueInput;
    update: XOR<
      ResenaUpdateWithoutCursoInput,
      ResenaUncheckedUpdateWithoutCursoInput
    >;
    create: XOR<
      ResenaCreateWithoutCursoInput,
      ResenaUncheckedCreateWithoutCursoInput
    >;
  };

  export type ResenaUpdateWithWhereUniqueWithoutCursoInput = {
    where: ResenaWhereUniqueInput;
    data: XOR<
      ResenaUpdateWithoutCursoInput,
      ResenaUncheckedUpdateWithoutCursoInput
    >;
  };

  export type ResenaUpdateManyWithWhereWithoutCursoInput = {
    where: ResenaScalarWhereInput;
    data: XOR<
      ResenaUpdateManyMutationInput,
      ResenaUncheckedUpdateManyWithoutCursoInput
    >;
  };

  export type InscripcionUpsertWithWhereUniqueWithoutCursoInput = {
    where: InscripcionWhereUniqueInput;
    update: XOR<
      InscripcionUpdateWithoutCursoInput,
      InscripcionUncheckedUpdateWithoutCursoInput
    >;
    create: XOR<
      InscripcionCreateWithoutCursoInput,
      InscripcionUncheckedCreateWithoutCursoInput
    >;
  };

  export type InscripcionUpdateWithWhereUniqueWithoutCursoInput = {
    where: InscripcionWhereUniqueInput;
    data: XOR<
      InscripcionUpdateWithoutCursoInput,
      InscripcionUncheckedUpdateWithoutCursoInput
    >;
  };

  export type InscripcionUpdateManyWithWhereWithoutCursoInput = {
    where: InscripcionScalarWhereInput;
    data: XOR<
      InscripcionUpdateManyMutationInput,
      InscripcionUncheckedUpdateManyWithoutCursoInput
    >;
  };

  export type ItemCarritoUpsertWithWhereUniqueWithoutCursoInput = {
    where: ItemCarritoWhereUniqueInput;
    update: XOR<
      ItemCarritoUpdateWithoutCursoInput,
      ItemCarritoUncheckedUpdateWithoutCursoInput
    >;
    create: XOR<
      ItemCarritoCreateWithoutCursoInput,
      ItemCarritoUncheckedCreateWithoutCursoInput
    >;
  };

  export type ItemCarritoUpdateWithWhereUniqueWithoutCursoInput = {
    where: ItemCarritoWhereUniqueInput;
    data: XOR<
      ItemCarritoUpdateWithoutCursoInput,
      ItemCarritoUncheckedUpdateWithoutCursoInput
    >;
  };

  export type ItemCarritoUpdateManyWithWhereWithoutCursoInput = {
    where: ItemCarritoScalarWhereInput;
    data: XOR<
      ItemCarritoUpdateManyMutationInput,
      ItemCarritoUncheckedUpdateManyWithoutCursoInput
    >;
  };

  export type ItemCarritoScalarWhereInput = {
    AND?: ItemCarritoScalarWhereInput | ItemCarritoScalarWhereInput[];
    OR?: ItemCarritoScalarWhereInput[];
    NOT?: ItemCarritoScalarWhereInput | ItemCarritoScalarWhereInput[];
    id?: IntFilter<'ItemCarrito'> | number;
    carritoId?: IntFilter<'ItemCarrito'> | number;
    tipo?: EnumTipoItemOrdenFilter<'ItemCarrito'> | $Enums.TipoItemOrden;
    productoId?: IntNullableFilter<'ItemCarrito'> | number | null;
    cursoId?: IntNullableFilter<'ItemCarrito'> | number | null;
    cantidad?: IntFilter<'ItemCarrito'> | number;
    creadoEn?: DateTimeFilter<'ItemCarrito'> | Date | string;
  };

  export type UsuarioCreateWithoutInscripcionesInput = {
    email: string;
    nombre?: string | null;
    passwordHash: string;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
    emailVerificadoEn?: Date | string | null;
    roles?: UsuarioRolCreateNestedManyWithoutUsuarioInput;
    cursosImpartidos?: CursoCreateNestedManyWithoutInstructorInput;
    resenas?: ResenaCreateNestedManyWithoutUsuarioInput;
    resenaRespuestas?: ResenaRespuestaCreateNestedManyWithoutUsuarioInput;
    favoritos?: FavoritoCreateNestedManyWithoutUsuarioInput;
    resenaLikes?: ResenaLikeCreateNestedManyWithoutUsuarioInput;
    ordenes?: OrdenCreateNestedManyWithoutUsuarioInput;
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput;
    carrito?: CarritoCreateNestedOneWithoutUsuarioInput;
    notificaciones?: NotificacionCreateNestedManyWithoutUsuarioInput;
  };

  export type UsuarioUncheckedCreateWithoutInscripcionesInput = {
    id?: number;
    email: string;
    nombre?: string | null;
    passwordHash: string;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
    emailVerificadoEn?: Date | string | null;
    roles?: UsuarioRolUncheckedCreateNestedManyWithoutUsuarioInput;
    cursosImpartidos?: CursoUncheckedCreateNestedManyWithoutInstructorInput;
    resenas?: ResenaUncheckedCreateNestedManyWithoutUsuarioInput;
    resenaRespuestas?: ResenaRespuestaUncheckedCreateNestedManyWithoutUsuarioInput;
    favoritos?: FavoritoUncheckedCreateNestedManyWithoutUsuarioInput;
    resenaLikes?: ResenaLikeUncheckedCreateNestedManyWithoutUsuarioInput;
    ordenes?: OrdenUncheckedCreateNestedManyWithoutUsuarioInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    carrito?: CarritoUncheckedCreateNestedOneWithoutUsuarioInput;
    notificaciones?: NotificacionUncheckedCreateNestedManyWithoutUsuarioInput;
  };

  export type UsuarioCreateOrConnectWithoutInscripcionesInput = {
    where: UsuarioWhereUniqueInput;
    create: XOR<
      UsuarioCreateWithoutInscripcionesInput,
      UsuarioUncheckedCreateWithoutInscripcionesInput
    >;
  };

  export type CursoCreateWithoutInscripcionesInput = {
    slug: string;
    titulo: string;
    resumen?: string | null;
    descripcionMD?: string | null;
    requisitos?: string | null;
    precio: number;
    publicado?: boolean;
    nivel?: $Enums.NivelCurso;
    portada?: string | null;
    destacado?: boolean;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    ratingProm?: Decimal | DecimalJsLike | number | string | null;
    ratingConteo?: number;
    creadoEn?: Date | string;
    instructor?: UsuarioCreateNestedOneWithoutCursosImpartidosInput;
    modulos?: ModuloCreateNestedManyWithoutCursoInput;
    resenas?: ResenaCreateNestedManyWithoutCursoInput;
    itemsCarrito?: ItemCarritoCreateNestedManyWithoutCursoInput;
  };

  export type CursoUncheckedCreateWithoutInscripcionesInput = {
    id?: number;
    slug: string;
    titulo: string;
    resumen?: string | null;
    descripcionMD?: string | null;
    requisitos?: string | null;
    precio: number;
    publicado?: boolean;
    nivel?: $Enums.NivelCurso;
    portada?: string | null;
    destacado?: boolean;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    ratingProm?: Decimal | DecimalJsLike | number | string | null;
    ratingConteo?: number;
    creadoEn?: Date | string;
    instructorId?: number | null;
    modulos?: ModuloUncheckedCreateNestedManyWithoutCursoInput;
    resenas?: ResenaUncheckedCreateNestedManyWithoutCursoInput;
    itemsCarrito?: ItemCarritoUncheckedCreateNestedManyWithoutCursoInput;
  };

  export type CursoCreateOrConnectWithoutInscripcionesInput = {
    where: CursoWhereUniqueInput;
    create: XOR<
      CursoCreateWithoutInscripcionesInput,
      CursoUncheckedCreateWithoutInscripcionesInput
    >;
  };

  export type UsuarioUpsertWithoutInscripcionesInput = {
    update: XOR<
      UsuarioUpdateWithoutInscripcionesInput,
      UsuarioUncheckedUpdateWithoutInscripcionesInput
    >;
    create: XOR<
      UsuarioCreateWithoutInscripcionesInput,
      UsuarioUncheckedCreateWithoutInscripcionesInput
    >;
    where?: UsuarioWhereInput;
  };

  export type UsuarioUpdateToOneWithWhereWithoutInscripcionesInput = {
    where?: UsuarioWhereInput;
    data: XOR<
      UsuarioUpdateWithoutInscripcionesInput,
      UsuarioUncheckedUpdateWithoutInscripcionesInput
    >;
  };

  export type UsuarioUpdateWithoutInscripcionesInput = {
    email?: StringFieldUpdateOperationsInput | string;
    nombre?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    emailVerificadoEn?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    roles?: UsuarioRolUpdateManyWithoutUsuarioNestedInput;
    cursosImpartidos?: CursoUpdateManyWithoutInstructorNestedInput;
    resenas?: ResenaUpdateManyWithoutUsuarioNestedInput;
    resenaRespuestas?: ResenaRespuestaUpdateManyWithoutUsuarioNestedInput;
    favoritos?: FavoritoUpdateManyWithoutUsuarioNestedInput;
    resenaLikes?: ResenaLikeUpdateManyWithoutUsuarioNestedInput;
    ordenes?: OrdenUpdateManyWithoutUsuarioNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput;
    carrito?: CarritoUpdateOneWithoutUsuarioNestedInput;
    notificaciones?: NotificacionUpdateManyWithoutUsuarioNestedInput;
  };

  export type UsuarioUncheckedUpdateWithoutInscripcionesInput = {
    id?: IntFieldUpdateOperationsInput | number;
    email?: StringFieldUpdateOperationsInput | string;
    nombre?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    emailVerificadoEn?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    roles?: UsuarioRolUncheckedUpdateManyWithoutUsuarioNestedInput;
    cursosImpartidos?: CursoUncheckedUpdateManyWithoutInstructorNestedInput;
    resenas?: ResenaUncheckedUpdateManyWithoutUsuarioNestedInput;
    resenaRespuestas?: ResenaRespuestaUncheckedUpdateManyWithoutUsuarioNestedInput;
    favoritos?: FavoritoUncheckedUpdateManyWithoutUsuarioNestedInput;
    resenaLikes?: ResenaLikeUncheckedUpdateManyWithoutUsuarioNestedInput;
    ordenes?: OrdenUncheckedUpdateManyWithoutUsuarioNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    carrito?: CarritoUncheckedUpdateOneWithoutUsuarioNestedInput;
    notificaciones?: NotificacionUncheckedUpdateManyWithoutUsuarioNestedInput;
  };

  export type CursoUpsertWithoutInscripcionesInput = {
    update: XOR<
      CursoUpdateWithoutInscripcionesInput,
      CursoUncheckedUpdateWithoutInscripcionesInput
    >;
    create: XOR<
      CursoCreateWithoutInscripcionesInput,
      CursoUncheckedCreateWithoutInscripcionesInput
    >;
    where?: CursoWhereInput;
  };

  export type CursoUpdateToOneWithWhereWithoutInscripcionesInput = {
    where?: CursoWhereInput;
    data: XOR<
      CursoUpdateWithoutInscripcionesInput,
      CursoUncheckedUpdateWithoutInscripcionesInput
    >;
  };

  export type CursoUpdateWithoutInscripcionesInput = {
    slug?: StringFieldUpdateOperationsInput | string;
    titulo?: StringFieldUpdateOperationsInput | string;
    resumen?: NullableStringFieldUpdateOperationsInput | string | null;
    descripcionMD?: NullableStringFieldUpdateOperationsInput | string | null;
    requisitos?: NullableStringFieldUpdateOperationsInput | string | null;
    precio?: IntFieldUpdateOperationsInput | number;
    publicado?: BoolFieldUpdateOperationsInput | boolean;
    nivel?: EnumNivelCursoFieldUpdateOperationsInput | $Enums.NivelCurso;
    portada?: NullableStringFieldUpdateOperationsInput | string | null;
    destacado?: BoolFieldUpdateOperationsInput | boolean;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    ratingProm?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    ratingConteo?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    instructor?: UsuarioUpdateOneWithoutCursosImpartidosNestedInput;
    modulos?: ModuloUpdateManyWithoutCursoNestedInput;
    resenas?: ResenaUpdateManyWithoutCursoNestedInput;
    itemsCarrito?: ItemCarritoUpdateManyWithoutCursoNestedInput;
  };

  export type CursoUncheckedUpdateWithoutInscripcionesInput = {
    id?: IntFieldUpdateOperationsInput | number;
    slug?: StringFieldUpdateOperationsInput | string;
    titulo?: StringFieldUpdateOperationsInput | string;
    resumen?: NullableStringFieldUpdateOperationsInput | string | null;
    descripcionMD?: NullableStringFieldUpdateOperationsInput | string | null;
    requisitos?: NullableStringFieldUpdateOperationsInput | string | null;
    precio?: IntFieldUpdateOperationsInput | number;
    publicado?: BoolFieldUpdateOperationsInput | boolean;
    nivel?: EnumNivelCursoFieldUpdateOperationsInput | $Enums.NivelCurso;
    portada?: NullableStringFieldUpdateOperationsInput | string | null;
    destacado?: BoolFieldUpdateOperationsInput | boolean;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    ratingProm?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    ratingConteo?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    instructorId?: NullableIntFieldUpdateOperationsInput | number | null;
    modulos?: ModuloUncheckedUpdateManyWithoutCursoNestedInput;
    resenas?: ResenaUncheckedUpdateManyWithoutCursoNestedInput;
    itemsCarrito?: ItemCarritoUncheckedUpdateManyWithoutCursoNestedInput;
  };

  export type CursoCreateWithoutModulosInput = {
    slug: string;
    titulo: string;
    resumen?: string | null;
    descripcionMD?: string | null;
    requisitos?: string | null;
    precio: number;
    publicado?: boolean;
    nivel?: $Enums.NivelCurso;
    portada?: string | null;
    destacado?: boolean;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    ratingProm?: Decimal | DecimalJsLike | number | string | null;
    ratingConteo?: number;
    creadoEn?: Date | string;
    instructor?: UsuarioCreateNestedOneWithoutCursosImpartidosInput;
    resenas?: ResenaCreateNestedManyWithoutCursoInput;
    inscripciones?: InscripcionCreateNestedManyWithoutCursoInput;
    itemsCarrito?: ItemCarritoCreateNestedManyWithoutCursoInput;
  };

  export type CursoUncheckedCreateWithoutModulosInput = {
    id?: number;
    slug: string;
    titulo: string;
    resumen?: string | null;
    descripcionMD?: string | null;
    requisitos?: string | null;
    precio: number;
    publicado?: boolean;
    nivel?: $Enums.NivelCurso;
    portada?: string | null;
    destacado?: boolean;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    ratingProm?: Decimal | DecimalJsLike | number | string | null;
    ratingConteo?: number;
    creadoEn?: Date | string;
    instructorId?: number | null;
    resenas?: ResenaUncheckedCreateNestedManyWithoutCursoInput;
    inscripciones?: InscripcionUncheckedCreateNestedManyWithoutCursoInput;
    itemsCarrito?: ItemCarritoUncheckedCreateNestedManyWithoutCursoInput;
  };

  export type CursoCreateOrConnectWithoutModulosInput = {
    where: CursoWhereUniqueInput;
    create: XOR<
      CursoCreateWithoutModulosInput,
      CursoUncheckedCreateWithoutModulosInput
    >;
  };

  export type LeccionCreateWithoutModuloInput = {
    titulo: string;
    rutaSrc?: string | null;
    orden: number;
    tipo?: $Enums.TipoLeccion;
    descripcion?: string | null;
    contenido?: NullableJsonNullValueInput | InputJsonValue;
    previewUrl?: string | null;
    duracion?: number;
  };

  export type LeccionUncheckedCreateWithoutModuloInput = {
    id?: number;
    titulo: string;
    rutaSrc?: string | null;
    orden: number;
    tipo?: $Enums.TipoLeccion;
    descripcion?: string | null;
    contenido?: NullableJsonNullValueInput | InputJsonValue;
    previewUrl?: string | null;
    duracion?: number;
  };

  export type LeccionCreateOrConnectWithoutModuloInput = {
    where: LeccionWhereUniqueInput;
    create: XOR<
      LeccionCreateWithoutModuloInput,
      LeccionUncheckedCreateWithoutModuloInput
    >;
  };

  export type LeccionCreateManyModuloInputEnvelope = {
    data: LeccionCreateManyModuloInput | LeccionCreateManyModuloInput[];
    skipDuplicates?: boolean;
  };

  export type CursoUpsertWithoutModulosInput = {
    update: XOR<
      CursoUpdateWithoutModulosInput,
      CursoUncheckedUpdateWithoutModulosInput
    >;
    create: XOR<
      CursoCreateWithoutModulosInput,
      CursoUncheckedCreateWithoutModulosInput
    >;
    where?: CursoWhereInput;
  };

  export type CursoUpdateToOneWithWhereWithoutModulosInput = {
    where?: CursoWhereInput;
    data: XOR<
      CursoUpdateWithoutModulosInput,
      CursoUncheckedUpdateWithoutModulosInput
    >;
  };

  export type CursoUpdateWithoutModulosInput = {
    slug?: StringFieldUpdateOperationsInput | string;
    titulo?: StringFieldUpdateOperationsInput | string;
    resumen?: NullableStringFieldUpdateOperationsInput | string | null;
    descripcionMD?: NullableStringFieldUpdateOperationsInput | string | null;
    requisitos?: NullableStringFieldUpdateOperationsInput | string | null;
    precio?: IntFieldUpdateOperationsInput | number;
    publicado?: BoolFieldUpdateOperationsInput | boolean;
    nivel?: EnumNivelCursoFieldUpdateOperationsInput | $Enums.NivelCurso;
    portada?: NullableStringFieldUpdateOperationsInput | string | null;
    destacado?: BoolFieldUpdateOperationsInput | boolean;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    ratingProm?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    ratingConteo?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    instructor?: UsuarioUpdateOneWithoutCursosImpartidosNestedInput;
    resenas?: ResenaUpdateManyWithoutCursoNestedInput;
    inscripciones?: InscripcionUpdateManyWithoutCursoNestedInput;
    itemsCarrito?: ItemCarritoUpdateManyWithoutCursoNestedInput;
  };

  export type CursoUncheckedUpdateWithoutModulosInput = {
    id?: IntFieldUpdateOperationsInput | number;
    slug?: StringFieldUpdateOperationsInput | string;
    titulo?: StringFieldUpdateOperationsInput | string;
    resumen?: NullableStringFieldUpdateOperationsInput | string | null;
    descripcionMD?: NullableStringFieldUpdateOperationsInput | string | null;
    requisitos?: NullableStringFieldUpdateOperationsInput | string | null;
    precio?: IntFieldUpdateOperationsInput | number;
    publicado?: BoolFieldUpdateOperationsInput | boolean;
    nivel?: EnumNivelCursoFieldUpdateOperationsInput | $Enums.NivelCurso;
    portada?: NullableStringFieldUpdateOperationsInput | string | null;
    destacado?: BoolFieldUpdateOperationsInput | boolean;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    ratingProm?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    ratingConteo?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    instructorId?: NullableIntFieldUpdateOperationsInput | number | null;
    resenas?: ResenaUncheckedUpdateManyWithoutCursoNestedInput;
    inscripciones?: InscripcionUncheckedUpdateManyWithoutCursoNestedInput;
    itemsCarrito?: ItemCarritoUncheckedUpdateManyWithoutCursoNestedInput;
  };

  export type LeccionUpsertWithWhereUniqueWithoutModuloInput = {
    where: LeccionWhereUniqueInput;
    update: XOR<
      LeccionUpdateWithoutModuloInput,
      LeccionUncheckedUpdateWithoutModuloInput
    >;
    create: XOR<
      LeccionCreateWithoutModuloInput,
      LeccionUncheckedCreateWithoutModuloInput
    >;
  };

  export type LeccionUpdateWithWhereUniqueWithoutModuloInput = {
    where: LeccionWhereUniqueInput;
    data: XOR<
      LeccionUpdateWithoutModuloInput,
      LeccionUncheckedUpdateWithoutModuloInput
    >;
  };

  export type LeccionUpdateManyWithWhereWithoutModuloInput = {
    where: LeccionScalarWhereInput;
    data: XOR<
      LeccionUpdateManyMutationInput,
      LeccionUncheckedUpdateManyWithoutModuloInput
    >;
  };

  export type LeccionScalarWhereInput = {
    AND?: LeccionScalarWhereInput | LeccionScalarWhereInput[];
    OR?: LeccionScalarWhereInput[];
    NOT?: LeccionScalarWhereInput | LeccionScalarWhereInput[];
    id?: IntFilter<'Leccion'> | number;
    moduloId?: IntFilter<'Leccion'> | number;
    titulo?: StringFilter<'Leccion'> | string;
    rutaSrc?: StringNullableFilter<'Leccion'> | string | null;
    orden?: IntFilter<'Leccion'> | number;
    tipo?: EnumTipoLeccionFilter<'Leccion'> | $Enums.TipoLeccion;
    descripcion?: StringNullableFilter<'Leccion'> | string | null;
    contenido?: JsonNullableFilter<'Leccion'>;
    previewUrl?: StringNullableFilter<'Leccion'> | string | null;
    duracion?: FloatFilter<'Leccion'> | number;
  };

  export type ModuloCreateWithoutLeccionesInput = {
    titulo: string;
    orden: number;
    parentId?: number | null;
    curso: CursoCreateNestedOneWithoutModulosInput;
  };

  export type ModuloUncheckedCreateWithoutLeccionesInput = {
    id?: number;
    cursoId: number;
    titulo: string;
    orden: number;
    parentId?: number | null;
  };

  export type ModuloCreateOrConnectWithoutLeccionesInput = {
    where: ModuloWhereUniqueInput;
    create: XOR<
      ModuloCreateWithoutLeccionesInput,
      ModuloUncheckedCreateWithoutLeccionesInput
    >;
  };

  export type ModuloUpsertWithoutLeccionesInput = {
    update: XOR<
      ModuloUpdateWithoutLeccionesInput,
      ModuloUncheckedUpdateWithoutLeccionesInput
    >;
    create: XOR<
      ModuloCreateWithoutLeccionesInput,
      ModuloUncheckedCreateWithoutLeccionesInput
    >;
    where?: ModuloWhereInput;
  };

  export type ModuloUpdateToOneWithWhereWithoutLeccionesInput = {
    where?: ModuloWhereInput;
    data: XOR<
      ModuloUpdateWithoutLeccionesInput,
      ModuloUncheckedUpdateWithoutLeccionesInput
    >;
  };

  export type ModuloUpdateWithoutLeccionesInput = {
    titulo?: StringFieldUpdateOperationsInput | string;
    orden?: IntFieldUpdateOperationsInput | number;
    parentId?: NullableIntFieldUpdateOperationsInput | number | null;
    curso?: CursoUpdateOneRequiredWithoutModulosNestedInput;
  };

  export type ModuloUncheckedUpdateWithoutLeccionesInput = {
    id?: IntFieldUpdateOperationsInput | number;
    cursoId?: IntFieldUpdateOperationsInput | number;
    titulo?: StringFieldUpdateOperationsInput | string;
    orden?: IntFieldUpdateOperationsInput | number;
    parentId?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type MarcaCreateWithoutProductosInput = {
    slug: string;
    nombre: string;
    imagen?: string | null;
    activa?: boolean;
    orden?: number;
    creadoEn?: Date | string;
  };

  export type MarcaUncheckedCreateWithoutProductosInput = {
    id?: number;
    slug: string;
    nombre: string;
    imagen?: string | null;
    activa?: boolean;
    orden?: number;
    creadoEn?: Date | string;
  };

  export type MarcaCreateOrConnectWithoutProductosInput = {
    where: MarcaWhereUniqueInput;
    create: XOR<
      MarcaCreateWithoutProductosInput,
      MarcaUncheckedCreateWithoutProductosInput
    >;
  };

  export type CategoriaCreateWithoutProductosInput = {
    slug: string;
    nombre: string;
    descripcion?: string | null;
    imagen?: string | null;
    activa?: boolean;
    orden?: number;
    creadoEn?: Date | string;
    parent?: CategoriaCreateNestedOneWithoutHijosInput;
    hijos?: CategoriaCreateNestedManyWithoutParentInput;
  };

  export type CategoriaUncheckedCreateWithoutProductosInput = {
    id?: number;
    slug: string;
    nombre: string;
    descripcion?: string | null;
    imagen?: string | null;
    activa?: boolean;
    orden?: number;
    creadoEn?: Date | string;
    parentId?: number | null;
    hijos?: CategoriaUncheckedCreateNestedManyWithoutParentInput;
  };

  export type CategoriaCreateOrConnectWithoutProductosInput = {
    where: CategoriaWhereUniqueInput;
    create: XOR<
      CategoriaCreateWithoutProductosInput,
      CategoriaUncheckedCreateWithoutProductosInput
    >;
  };

  export type ProductoImagenCreateWithoutProductoInput = {
    archivo: string;
    alt?: string | null;
    orden?: number;
  };

  export type ProductoImagenUncheckedCreateWithoutProductoInput = {
    id?: number;
    archivo: string;
    alt?: string | null;
    orden?: number;
  };

  export type ProductoImagenCreateOrConnectWithoutProductoInput = {
    where: ProductoImagenWhereUniqueInput;
    create: XOR<
      ProductoImagenCreateWithoutProductoInput,
      ProductoImagenUncheckedCreateWithoutProductoInput
    >;
  };

  export type ProductoImagenCreateManyProductoInputEnvelope = {
    data:
      | ProductoImagenCreateManyProductoInput
      | ProductoImagenCreateManyProductoInput[];
    skipDuplicates?: boolean;
  };

  export type ResenaCreateWithoutProductoInput = {
    puntaje: number;
    comentario?: string | null;
    creadoEn?: Date | string;
    curso?: CursoCreateNestedOneWithoutResenasInput;
    usuario: UsuarioCreateNestedOneWithoutResenasInput;
    respuestas?: ResenaRespuestaCreateNestedManyWithoutResenaInput;
    likes?: ResenaLikeCreateNestedManyWithoutResenaInput;
  };

  export type ResenaUncheckedCreateWithoutProductoInput = {
    id?: number;
    cursoId?: number | null;
    usuarioId: number;
    puntaje: number;
    comentario?: string | null;
    creadoEn?: Date | string;
    respuestas?: ResenaRespuestaUncheckedCreateNestedManyWithoutResenaInput;
    likes?: ResenaLikeUncheckedCreateNestedManyWithoutResenaInput;
  };

  export type ResenaCreateOrConnectWithoutProductoInput = {
    where: ResenaWhereUniqueInput;
    create: XOR<
      ResenaCreateWithoutProductoInput,
      ResenaUncheckedCreateWithoutProductoInput
    >;
  };

  export type ResenaCreateManyProductoInputEnvelope = {
    data: ResenaCreateManyProductoInput | ResenaCreateManyProductoInput[];
    skipDuplicates?: boolean;
  };

  export type FavoritoCreateWithoutProductoInput = {
    creadoEn?: Date | string;
    usuario: UsuarioCreateNestedOneWithoutFavoritosInput;
  };

  export type FavoritoUncheckedCreateWithoutProductoInput = {
    id?: number;
    usuarioId: number;
    creadoEn?: Date | string;
  };

  export type FavoritoCreateOrConnectWithoutProductoInput = {
    where: FavoritoWhereUniqueInput;
    create: XOR<
      FavoritoCreateWithoutProductoInput,
      FavoritoUncheckedCreateWithoutProductoInput
    >;
  };

  export type FavoritoCreateManyProductoInputEnvelope = {
    data: FavoritoCreateManyProductoInput | FavoritoCreateManyProductoInput[];
    skipDuplicates?: boolean;
  };

  export type ItemCarritoCreateWithoutProductoInput = {
    tipo: $Enums.TipoItemOrden;
    cantidad?: number;
    creadoEn?: Date | string;
    carrito: CarritoCreateNestedOneWithoutItemsInput;
    curso?: CursoCreateNestedOneWithoutItemsCarritoInput;
  };

  export type ItemCarritoUncheckedCreateWithoutProductoInput = {
    id?: number;
    carritoId: number;
    tipo: $Enums.TipoItemOrden;
    cursoId?: number | null;
    cantidad?: number;
    creadoEn?: Date | string;
  };

  export type ItemCarritoCreateOrConnectWithoutProductoInput = {
    where: ItemCarritoWhereUniqueInput;
    create: XOR<
      ItemCarritoCreateWithoutProductoInput,
      ItemCarritoUncheckedCreateWithoutProductoInput
    >;
  };

  export type ItemCarritoCreateManyProductoInputEnvelope = {
    data:
      | ItemCarritoCreateManyProductoInput
      | ItemCarritoCreateManyProductoInput[];
    skipDuplicates?: boolean;
  };

  export type MarcaUpsertWithoutProductosInput = {
    update: XOR<
      MarcaUpdateWithoutProductosInput,
      MarcaUncheckedUpdateWithoutProductosInput
    >;
    create: XOR<
      MarcaCreateWithoutProductosInput,
      MarcaUncheckedCreateWithoutProductosInput
    >;
    where?: MarcaWhereInput;
  };

  export type MarcaUpdateToOneWithWhereWithoutProductosInput = {
    where?: MarcaWhereInput;
    data: XOR<
      MarcaUpdateWithoutProductosInput,
      MarcaUncheckedUpdateWithoutProductosInput
    >;
  };

  export type MarcaUpdateWithoutProductosInput = {
    slug?: StringFieldUpdateOperationsInput | string;
    nombre?: StringFieldUpdateOperationsInput | string;
    imagen?: NullableStringFieldUpdateOperationsInput | string | null;
    activa?: BoolFieldUpdateOperationsInput | boolean;
    orden?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type MarcaUncheckedUpdateWithoutProductosInput = {
    id?: IntFieldUpdateOperationsInput | number;
    slug?: StringFieldUpdateOperationsInput | string;
    nombre?: StringFieldUpdateOperationsInput | string;
    imagen?: NullableStringFieldUpdateOperationsInput | string | null;
    activa?: BoolFieldUpdateOperationsInput | boolean;
    orden?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type CategoriaUpsertWithoutProductosInput = {
    update: XOR<
      CategoriaUpdateWithoutProductosInput,
      CategoriaUncheckedUpdateWithoutProductosInput
    >;
    create: XOR<
      CategoriaCreateWithoutProductosInput,
      CategoriaUncheckedCreateWithoutProductosInput
    >;
    where?: CategoriaWhereInput;
  };

  export type CategoriaUpdateToOneWithWhereWithoutProductosInput = {
    where?: CategoriaWhereInput;
    data: XOR<
      CategoriaUpdateWithoutProductosInput,
      CategoriaUncheckedUpdateWithoutProductosInput
    >;
  };

  export type CategoriaUpdateWithoutProductosInput = {
    slug?: StringFieldUpdateOperationsInput | string;
    nombre?: StringFieldUpdateOperationsInput | string;
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null;
    imagen?: NullableStringFieldUpdateOperationsInput | string | null;
    activa?: BoolFieldUpdateOperationsInput | boolean;
    orden?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    parent?: CategoriaUpdateOneWithoutHijosNestedInput;
    hijos?: CategoriaUpdateManyWithoutParentNestedInput;
  };

  export type CategoriaUncheckedUpdateWithoutProductosInput = {
    id?: IntFieldUpdateOperationsInput | number;
    slug?: StringFieldUpdateOperationsInput | string;
    nombre?: StringFieldUpdateOperationsInput | string;
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null;
    imagen?: NullableStringFieldUpdateOperationsInput | string | null;
    activa?: BoolFieldUpdateOperationsInput | boolean;
    orden?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    parentId?: NullableIntFieldUpdateOperationsInput | number | null;
    hijos?: CategoriaUncheckedUpdateManyWithoutParentNestedInput;
  };

  export type ProductoImagenUpsertWithWhereUniqueWithoutProductoInput = {
    where: ProductoImagenWhereUniqueInput;
    update: XOR<
      ProductoImagenUpdateWithoutProductoInput,
      ProductoImagenUncheckedUpdateWithoutProductoInput
    >;
    create: XOR<
      ProductoImagenCreateWithoutProductoInput,
      ProductoImagenUncheckedCreateWithoutProductoInput
    >;
  };

  export type ProductoImagenUpdateWithWhereUniqueWithoutProductoInput = {
    where: ProductoImagenWhereUniqueInput;
    data: XOR<
      ProductoImagenUpdateWithoutProductoInput,
      ProductoImagenUncheckedUpdateWithoutProductoInput
    >;
  };

  export type ProductoImagenUpdateManyWithWhereWithoutProductoInput = {
    where: ProductoImagenScalarWhereInput;
    data: XOR<
      ProductoImagenUpdateManyMutationInput,
      ProductoImagenUncheckedUpdateManyWithoutProductoInput
    >;
  };

  export type ProductoImagenScalarWhereInput = {
    AND?: ProductoImagenScalarWhereInput | ProductoImagenScalarWhereInput[];
    OR?: ProductoImagenScalarWhereInput[];
    NOT?: ProductoImagenScalarWhereInput | ProductoImagenScalarWhereInput[];
    id?: IntFilter<'ProductoImagen'> | number;
    productoId?: IntFilter<'ProductoImagen'> | number;
    archivo?: StringFilter<'ProductoImagen'> | string;
    alt?: StringNullableFilter<'ProductoImagen'> | string | null;
    orden?: IntFilter<'ProductoImagen'> | number;
  };

  export type ResenaUpsertWithWhereUniqueWithoutProductoInput = {
    where: ResenaWhereUniqueInput;
    update: XOR<
      ResenaUpdateWithoutProductoInput,
      ResenaUncheckedUpdateWithoutProductoInput
    >;
    create: XOR<
      ResenaCreateWithoutProductoInput,
      ResenaUncheckedCreateWithoutProductoInput
    >;
  };

  export type ResenaUpdateWithWhereUniqueWithoutProductoInput = {
    where: ResenaWhereUniqueInput;
    data: XOR<
      ResenaUpdateWithoutProductoInput,
      ResenaUncheckedUpdateWithoutProductoInput
    >;
  };

  export type ResenaUpdateManyWithWhereWithoutProductoInput = {
    where: ResenaScalarWhereInput;
    data: XOR<
      ResenaUpdateManyMutationInput,
      ResenaUncheckedUpdateManyWithoutProductoInput
    >;
  };

  export type FavoritoUpsertWithWhereUniqueWithoutProductoInput = {
    where: FavoritoWhereUniqueInput;
    update: XOR<
      FavoritoUpdateWithoutProductoInput,
      FavoritoUncheckedUpdateWithoutProductoInput
    >;
    create: XOR<
      FavoritoCreateWithoutProductoInput,
      FavoritoUncheckedCreateWithoutProductoInput
    >;
  };

  export type FavoritoUpdateWithWhereUniqueWithoutProductoInput = {
    where: FavoritoWhereUniqueInput;
    data: XOR<
      FavoritoUpdateWithoutProductoInput,
      FavoritoUncheckedUpdateWithoutProductoInput
    >;
  };

  export type FavoritoUpdateManyWithWhereWithoutProductoInput = {
    where: FavoritoScalarWhereInput;
    data: XOR<
      FavoritoUpdateManyMutationInput,
      FavoritoUncheckedUpdateManyWithoutProductoInput
    >;
  };

  export type ItemCarritoUpsertWithWhereUniqueWithoutProductoInput = {
    where: ItemCarritoWhereUniqueInput;
    update: XOR<
      ItemCarritoUpdateWithoutProductoInput,
      ItemCarritoUncheckedUpdateWithoutProductoInput
    >;
    create: XOR<
      ItemCarritoCreateWithoutProductoInput,
      ItemCarritoUncheckedCreateWithoutProductoInput
    >;
  };

  export type ItemCarritoUpdateWithWhereUniqueWithoutProductoInput = {
    where: ItemCarritoWhereUniqueInput;
    data: XOR<
      ItemCarritoUpdateWithoutProductoInput,
      ItemCarritoUncheckedUpdateWithoutProductoInput
    >;
  };

  export type ItemCarritoUpdateManyWithWhereWithoutProductoInput = {
    where: ItemCarritoScalarWhereInput;
    data: XOR<
      ItemCarritoUpdateManyMutationInput,
      ItemCarritoUncheckedUpdateManyWithoutProductoInput
    >;
  };

  export type ProductoCreateWithoutImagenesInput = {
    slug: string;
    titulo: string;
    precio: number;
    stock?: number;
    publicado?: boolean;
    destacado?: boolean;
    imagen?: string | null;
    descripcionMD?: string | null;
    precioLista?: number | null;
    ratingProm?: Decimal | DecimalJsLike | number | string | null;
    ratingConteo?: number;
    creadoEn?: Date | string;
    marca?: MarcaCreateNestedOneWithoutProductosInput;
    categoria?: CategoriaCreateNestedOneWithoutProductosInput;
    resenas?: ResenaCreateNestedManyWithoutProductoInput;
    favoritos?: FavoritoCreateNestedManyWithoutProductoInput;
    itemsCarrito?: ItemCarritoCreateNestedManyWithoutProductoInput;
  };

  export type ProductoUncheckedCreateWithoutImagenesInput = {
    id?: number;
    slug: string;
    titulo: string;
    precio: number;
    stock?: number;
    publicado?: boolean;
    destacado?: boolean;
    imagen?: string | null;
    descripcionMD?: string | null;
    precioLista?: number | null;
    ratingProm?: Decimal | DecimalJsLike | number | string | null;
    ratingConteo?: number;
    creadoEn?: Date | string;
    marcaId?: number | null;
    categoriaId?: number | null;
    resenas?: ResenaUncheckedCreateNestedManyWithoutProductoInput;
    favoritos?: FavoritoUncheckedCreateNestedManyWithoutProductoInput;
    itemsCarrito?: ItemCarritoUncheckedCreateNestedManyWithoutProductoInput;
  };

  export type ProductoCreateOrConnectWithoutImagenesInput = {
    where: ProductoWhereUniqueInput;
    create: XOR<
      ProductoCreateWithoutImagenesInput,
      ProductoUncheckedCreateWithoutImagenesInput
    >;
  };

  export type ProductoUpsertWithoutImagenesInput = {
    update: XOR<
      ProductoUpdateWithoutImagenesInput,
      ProductoUncheckedUpdateWithoutImagenesInput
    >;
    create: XOR<
      ProductoCreateWithoutImagenesInput,
      ProductoUncheckedCreateWithoutImagenesInput
    >;
    where?: ProductoWhereInput;
  };

  export type ProductoUpdateToOneWithWhereWithoutImagenesInput = {
    where?: ProductoWhereInput;
    data: XOR<
      ProductoUpdateWithoutImagenesInput,
      ProductoUncheckedUpdateWithoutImagenesInput
    >;
  };

  export type ProductoUpdateWithoutImagenesInput = {
    slug?: StringFieldUpdateOperationsInput | string;
    titulo?: StringFieldUpdateOperationsInput | string;
    precio?: IntFieldUpdateOperationsInput | number;
    stock?: IntFieldUpdateOperationsInput | number;
    publicado?: BoolFieldUpdateOperationsInput | boolean;
    destacado?: BoolFieldUpdateOperationsInput | boolean;
    imagen?: NullableStringFieldUpdateOperationsInput | string | null;
    descripcionMD?: NullableStringFieldUpdateOperationsInput | string | null;
    precioLista?: NullableIntFieldUpdateOperationsInput | number | null;
    ratingProm?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    ratingConteo?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    marca?: MarcaUpdateOneWithoutProductosNestedInput;
    categoria?: CategoriaUpdateOneWithoutProductosNestedInput;
    resenas?: ResenaUpdateManyWithoutProductoNestedInput;
    favoritos?: FavoritoUpdateManyWithoutProductoNestedInput;
    itemsCarrito?: ItemCarritoUpdateManyWithoutProductoNestedInput;
  };

  export type ProductoUncheckedUpdateWithoutImagenesInput = {
    id?: IntFieldUpdateOperationsInput | number;
    slug?: StringFieldUpdateOperationsInput | string;
    titulo?: StringFieldUpdateOperationsInput | string;
    precio?: IntFieldUpdateOperationsInput | number;
    stock?: IntFieldUpdateOperationsInput | number;
    publicado?: BoolFieldUpdateOperationsInput | boolean;
    destacado?: BoolFieldUpdateOperationsInput | boolean;
    imagen?: NullableStringFieldUpdateOperationsInput | string | null;
    descripcionMD?: NullableStringFieldUpdateOperationsInput | string | null;
    precioLista?: NullableIntFieldUpdateOperationsInput | number | null;
    ratingProm?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    ratingConteo?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    marcaId?: NullableIntFieldUpdateOperationsInput | number | null;
    categoriaId?: NullableIntFieldUpdateOperationsInput | number | null;
    resenas?: ResenaUncheckedUpdateManyWithoutProductoNestedInput;
    favoritos?: FavoritoUncheckedUpdateManyWithoutProductoNestedInput;
    itemsCarrito?: ItemCarritoUncheckedUpdateManyWithoutProductoNestedInput;
  };

  export type ProductoCreateWithoutMarcaInput = {
    slug: string;
    titulo: string;
    precio: number;
    stock?: number;
    publicado?: boolean;
    destacado?: boolean;
    imagen?: string | null;
    descripcionMD?: string | null;
    precioLista?: number | null;
    ratingProm?: Decimal | DecimalJsLike | number | string | null;
    ratingConteo?: number;
    creadoEn?: Date | string;
    categoria?: CategoriaCreateNestedOneWithoutProductosInput;
    imagenes?: ProductoImagenCreateNestedManyWithoutProductoInput;
    resenas?: ResenaCreateNestedManyWithoutProductoInput;
    favoritos?: FavoritoCreateNestedManyWithoutProductoInput;
    itemsCarrito?: ItemCarritoCreateNestedManyWithoutProductoInput;
  };

  export type ProductoUncheckedCreateWithoutMarcaInput = {
    id?: number;
    slug: string;
    titulo: string;
    precio: number;
    stock?: number;
    publicado?: boolean;
    destacado?: boolean;
    imagen?: string | null;
    descripcionMD?: string | null;
    precioLista?: number | null;
    ratingProm?: Decimal | DecimalJsLike | number | string | null;
    ratingConteo?: number;
    creadoEn?: Date | string;
    categoriaId?: number | null;
    imagenes?: ProductoImagenUncheckedCreateNestedManyWithoutProductoInput;
    resenas?: ResenaUncheckedCreateNestedManyWithoutProductoInput;
    favoritos?: FavoritoUncheckedCreateNestedManyWithoutProductoInput;
    itemsCarrito?: ItemCarritoUncheckedCreateNestedManyWithoutProductoInput;
  };

  export type ProductoCreateOrConnectWithoutMarcaInput = {
    where: ProductoWhereUniqueInput;
    create: XOR<
      ProductoCreateWithoutMarcaInput,
      ProductoUncheckedCreateWithoutMarcaInput
    >;
  };

  export type ProductoCreateManyMarcaInputEnvelope = {
    data: ProductoCreateManyMarcaInput | ProductoCreateManyMarcaInput[];
    skipDuplicates?: boolean;
  };

  export type ProductoUpsertWithWhereUniqueWithoutMarcaInput = {
    where: ProductoWhereUniqueInput;
    update: XOR<
      ProductoUpdateWithoutMarcaInput,
      ProductoUncheckedUpdateWithoutMarcaInput
    >;
    create: XOR<
      ProductoCreateWithoutMarcaInput,
      ProductoUncheckedCreateWithoutMarcaInput
    >;
  };

  export type ProductoUpdateWithWhereUniqueWithoutMarcaInput = {
    where: ProductoWhereUniqueInput;
    data: XOR<
      ProductoUpdateWithoutMarcaInput,
      ProductoUncheckedUpdateWithoutMarcaInput
    >;
  };

  export type ProductoUpdateManyWithWhereWithoutMarcaInput = {
    where: ProductoScalarWhereInput;
    data: XOR<
      ProductoUpdateManyMutationInput,
      ProductoUncheckedUpdateManyWithoutMarcaInput
    >;
  };

  export type ProductoScalarWhereInput = {
    AND?: ProductoScalarWhereInput | ProductoScalarWhereInput[];
    OR?: ProductoScalarWhereInput[];
    NOT?: ProductoScalarWhereInput | ProductoScalarWhereInput[];
    id?: IntFilter<'Producto'> | number;
    slug?: StringFilter<'Producto'> | string;
    titulo?: StringFilter<'Producto'> | string;
    precio?: IntFilter<'Producto'> | number;
    stock?: IntFilter<'Producto'> | number;
    publicado?: BoolFilter<'Producto'> | boolean;
    destacado?: BoolFilter<'Producto'> | boolean;
    imagen?: StringNullableFilter<'Producto'> | string | null;
    descripcionMD?: StringNullableFilter<'Producto'> | string | null;
    precioLista?: IntNullableFilter<'Producto'> | number | null;
    ratingProm?:
      | DecimalNullableFilter<'Producto'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    ratingConteo?: IntFilter<'Producto'> | number;
    creadoEn?: DateTimeFilter<'Producto'> | Date | string;
    marcaId?: IntNullableFilter<'Producto'> | number | null;
    categoriaId?: IntNullableFilter<'Producto'> | number | null;
  };

  export type CategoriaCreateWithoutHijosInput = {
    slug: string;
    nombre: string;
    descripcion?: string | null;
    imagen?: string | null;
    activa?: boolean;
    orden?: number;
    creadoEn?: Date | string;
    parent?: CategoriaCreateNestedOneWithoutHijosInput;
    productos?: ProductoCreateNestedManyWithoutCategoriaInput;
  };

  export type CategoriaUncheckedCreateWithoutHijosInput = {
    id?: number;
    slug: string;
    nombre: string;
    descripcion?: string | null;
    imagen?: string | null;
    activa?: boolean;
    orden?: number;
    creadoEn?: Date | string;
    parentId?: number | null;
    productos?: ProductoUncheckedCreateNestedManyWithoutCategoriaInput;
  };

  export type CategoriaCreateOrConnectWithoutHijosInput = {
    where: CategoriaWhereUniqueInput;
    create: XOR<
      CategoriaCreateWithoutHijosInput,
      CategoriaUncheckedCreateWithoutHijosInput
    >;
  };

  export type CategoriaCreateWithoutParentInput = {
    slug: string;
    nombre: string;
    descripcion?: string | null;
    imagen?: string | null;
    activa?: boolean;
    orden?: number;
    creadoEn?: Date | string;
    hijos?: CategoriaCreateNestedManyWithoutParentInput;
    productos?: ProductoCreateNestedManyWithoutCategoriaInput;
  };

  export type CategoriaUncheckedCreateWithoutParentInput = {
    id?: number;
    slug: string;
    nombre: string;
    descripcion?: string | null;
    imagen?: string | null;
    activa?: boolean;
    orden?: number;
    creadoEn?: Date | string;
    hijos?: CategoriaUncheckedCreateNestedManyWithoutParentInput;
    productos?: ProductoUncheckedCreateNestedManyWithoutCategoriaInput;
  };

  export type CategoriaCreateOrConnectWithoutParentInput = {
    where: CategoriaWhereUniqueInput;
    create: XOR<
      CategoriaCreateWithoutParentInput,
      CategoriaUncheckedCreateWithoutParentInput
    >;
  };

  export type CategoriaCreateManyParentInputEnvelope = {
    data: CategoriaCreateManyParentInput | CategoriaCreateManyParentInput[];
    skipDuplicates?: boolean;
  };

  export type ProductoCreateWithoutCategoriaInput = {
    slug: string;
    titulo: string;
    precio: number;
    stock?: number;
    publicado?: boolean;
    destacado?: boolean;
    imagen?: string | null;
    descripcionMD?: string | null;
    precioLista?: number | null;
    ratingProm?: Decimal | DecimalJsLike | number | string | null;
    ratingConteo?: number;
    creadoEn?: Date | string;
    marca?: MarcaCreateNestedOneWithoutProductosInput;
    imagenes?: ProductoImagenCreateNestedManyWithoutProductoInput;
    resenas?: ResenaCreateNestedManyWithoutProductoInput;
    favoritos?: FavoritoCreateNestedManyWithoutProductoInput;
    itemsCarrito?: ItemCarritoCreateNestedManyWithoutProductoInput;
  };

  export type ProductoUncheckedCreateWithoutCategoriaInput = {
    id?: number;
    slug: string;
    titulo: string;
    precio: number;
    stock?: number;
    publicado?: boolean;
    destacado?: boolean;
    imagen?: string | null;
    descripcionMD?: string | null;
    precioLista?: number | null;
    ratingProm?: Decimal | DecimalJsLike | number | string | null;
    ratingConteo?: number;
    creadoEn?: Date | string;
    marcaId?: number | null;
    imagenes?: ProductoImagenUncheckedCreateNestedManyWithoutProductoInput;
    resenas?: ResenaUncheckedCreateNestedManyWithoutProductoInput;
    favoritos?: FavoritoUncheckedCreateNestedManyWithoutProductoInput;
    itemsCarrito?: ItemCarritoUncheckedCreateNestedManyWithoutProductoInput;
  };

  export type ProductoCreateOrConnectWithoutCategoriaInput = {
    where: ProductoWhereUniqueInput;
    create: XOR<
      ProductoCreateWithoutCategoriaInput,
      ProductoUncheckedCreateWithoutCategoriaInput
    >;
  };

  export type ProductoCreateManyCategoriaInputEnvelope = {
    data: ProductoCreateManyCategoriaInput | ProductoCreateManyCategoriaInput[];
    skipDuplicates?: boolean;
  };

  export type CategoriaUpsertWithoutHijosInput = {
    update: XOR<
      CategoriaUpdateWithoutHijosInput,
      CategoriaUncheckedUpdateWithoutHijosInput
    >;
    create: XOR<
      CategoriaCreateWithoutHijosInput,
      CategoriaUncheckedCreateWithoutHijosInput
    >;
    where?: CategoriaWhereInput;
  };

  export type CategoriaUpdateToOneWithWhereWithoutHijosInput = {
    where?: CategoriaWhereInput;
    data: XOR<
      CategoriaUpdateWithoutHijosInput,
      CategoriaUncheckedUpdateWithoutHijosInput
    >;
  };

  export type CategoriaUpdateWithoutHijosInput = {
    slug?: StringFieldUpdateOperationsInput | string;
    nombre?: StringFieldUpdateOperationsInput | string;
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null;
    imagen?: NullableStringFieldUpdateOperationsInput | string | null;
    activa?: BoolFieldUpdateOperationsInput | boolean;
    orden?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    parent?: CategoriaUpdateOneWithoutHijosNestedInput;
    productos?: ProductoUpdateManyWithoutCategoriaNestedInput;
  };

  export type CategoriaUncheckedUpdateWithoutHijosInput = {
    id?: IntFieldUpdateOperationsInput | number;
    slug?: StringFieldUpdateOperationsInput | string;
    nombre?: StringFieldUpdateOperationsInput | string;
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null;
    imagen?: NullableStringFieldUpdateOperationsInput | string | null;
    activa?: BoolFieldUpdateOperationsInput | boolean;
    orden?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    parentId?: NullableIntFieldUpdateOperationsInput | number | null;
    productos?: ProductoUncheckedUpdateManyWithoutCategoriaNestedInput;
  };

  export type CategoriaUpsertWithWhereUniqueWithoutParentInput = {
    where: CategoriaWhereUniqueInput;
    update: XOR<
      CategoriaUpdateWithoutParentInput,
      CategoriaUncheckedUpdateWithoutParentInput
    >;
    create: XOR<
      CategoriaCreateWithoutParentInput,
      CategoriaUncheckedCreateWithoutParentInput
    >;
  };

  export type CategoriaUpdateWithWhereUniqueWithoutParentInput = {
    where: CategoriaWhereUniqueInput;
    data: XOR<
      CategoriaUpdateWithoutParentInput,
      CategoriaUncheckedUpdateWithoutParentInput
    >;
  };

  export type CategoriaUpdateManyWithWhereWithoutParentInput = {
    where: CategoriaScalarWhereInput;
    data: XOR<
      CategoriaUpdateManyMutationInput,
      CategoriaUncheckedUpdateManyWithoutParentInput
    >;
  };

  export type CategoriaScalarWhereInput = {
    AND?: CategoriaScalarWhereInput | CategoriaScalarWhereInput[];
    OR?: CategoriaScalarWhereInput[];
    NOT?: CategoriaScalarWhereInput | CategoriaScalarWhereInput[];
    id?: IntFilter<'Categoria'> | number;
    slug?: StringFilter<'Categoria'> | string;
    nombre?: StringFilter<'Categoria'> | string;
    descripcion?: StringNullableFilter<'Categoria'> | string | null;
    imagen?: StringNullableFilter<'Categoria'> | string | null;
    activa?: BoolFilter<'Categoria'> | boolean;
    orden?: IntFilter<'Categoria'> | number;
    creadoEn?: DateTimeFilter<'Categoria'> | Date | string;
    parentId?: IntNullableFilter<'Categoria'> | number | null;
  };

  export type ProductoUpsertWithWhereUniqueWithoutCategoriaInput = {
    where: ProductoWhereUniqueInput;
    update: XOR<
      ProductoUpdateWithoutCategoriaInput,
      ProductoUncheckedUpdateWithoutCategoriaInput
    >;
    create: XOR<
      ProductoCreateWithoutCategoriaInput,
      ProductoUncheckedCreateWithoutCategoriaInput
    >;
  };

  export type ProductoUpdateWithWhereUniqueWithoutCategoriaInput = {
    where: ProductoWhereUniqueInput;
    data: XOR<
      ProductoUpdateWithoutCategoriaInput,
      ProductoUncheckedUpdateWithoutCategoriaInput
    >;
  };

  export type ProductoUpdateManyWithWhereWithoutCategoriaInput = {
    where: ProductoScalarWhereInput;
    data: XOR<
      ProductoUpdateManyMutationInput,
      ProductoUncheckedUpdateManyWithoutCategoriaInput
    >;
  };

  export type UsuarioCreateWithoutOrdenesInput = {
    email: string;
    nombre?: string | null;
    passwordHash: string;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
    emailVerificadoEn?: Date | string | null;
    roles?: UsuarioRolCreateNestedManyWithoutUsuarioInput;
    cursosImpartidos?: CursoCreateNestedManyWithoutInstructorInput;
    inscripciones?: InscripcionCreateNestedManyWithoutUsuarioInput;
    resenas?: ResenaCreateNestedManyWithoutUsuarioInput;
    resenaRespuestas?: ResenaRespuestaCreateNestedManyWithoutUsuarioInput;
    favoritos?: FavoritoCreateNestedManyWithoutUsuarioInput;
    resenaLikes?: ResenaLikeCreateNestedManyWithoutUsuarioInput;
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput;
    carrito?: CarritoCreateNestedOneWithoutUsuarioInput;
    notificaciones?: NotificacionCreateNestedManyWithoutUsuarioInput;
  };

  export type UsuarioUncheckedCreateWithoutOrdenesInput = {
    id?: number;
    email: string;
    nombre?: string | null;
    passwordHash: string;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
    emailVerificadoEn?: Date | string | null;
    roles?: UsuarioRolUncheckedCreateNestedManyWithoutUsuarioInput;
    cursosImpartidos?: CursoUncheckedCreateNestedManyWithoutInstructorInput;
    inscripciones?: InscripcionUncheckedCreateNestedManyWithoutUsuarioInput;
    resenas?: ResenaUncheckedCreateNestedManyWithoutUsuarioInput;
    resenaRespuestas?: ResenaRespuestaUncheckedCreateNestedManyWithoutUsuarioInput;
    favoritos?: FavoritoUncheckedCreateNestedManyWithoutUsuarioInput;
    resenaLikes?: ResenaLikeUncheckedCreateNestedManyWithoutUsuarioInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    carrito?: CarritoUncheckedCreateNestedOneWithoutUsuarioInput;
    notificaciones?: NotificacionUncheckedCreateNestedManyWithoutUsuarioInput;
  };

  export type UsuarioCreateOrConnectWithoutOrdenesInput = {
    where: UsuarioWhereUniqueInput;
    create: XOR<
      UsuarioCreateWithoutOrdenesInput,
      UsuarioUncheckedCreateWithoutOrdenesInput
    >;
  };

  export type DireccionCreateWithoutOrdenesEnvioInput = {
    usuarioId: number;
    etiqueta?: string | null;
    nombre: string;
    telefono?: string | null;
    calle: string;
    numero?: string | null;
    pisoDepto?: string | null;
    ciudad: string;
    provincia: string;
    cp: string;
    pais?: string;
    predeterminada?: boolean;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
    ordenesFacturacion?: OrdenCreateNestedManyWithoutDireccionFacturacionInput;
  };

  export type DireccionUncheckedCreateWithoutOrdenesEnvioInput = {
    id?: number;
    usuarioId: number;
    etiqueta?: string | null;
    nombre: string;
    telefono?: string | null;
    calle: string;
    numero?: string | null;
    pisoDepto?: string | null;
    ciudad: string;
    provincia: string;
    cp: string;
    pais?: string;
    predeterminada?: boolean;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
    ordenesFacturacion?: OrdenUncheckedCreateNestedManyWithoutDireccionFacturacionInput;
  };

  export type DireccionCreateOrConnectWithoutOrdenesEnvioInput = {
    where: DireccionWhereUniqueInput;
    create: XOR<
      DireccionCreateWithoutOrdenesEnvioInput,
      DireccionUncheckedCreateWithoutOrdenesEnvioInput
    >;
  };

  export type DireccionCreateWithoutOrdenesFacturacionInput = {
    usuarioId: number;
    etiqueta?: string | null;
    nombre: string;
    telefono?: string | null;
    calle: string;
    numero?: string | null;
    pisoDepto?: string | null;
    ciudad: string;
    provincia: string;
    cp: string;
    pais?: string;
    predeterminada?: boolean;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
    ordenesEnvio?: OrdenCreateNestedManyWithoutDireccionEnvioInput;
  };

  export type DireccionUncheckedCreateWithoutOrdenesFacturacionInput = {
    id?: number;
    usuarioId: number;
    etiqueta?: string | null;
    nombre: string;
    telefono?: string | null;
    calle: string;
    numero?: string | null;
    pisoDepto?: string | null;
    ciudad: string;
    provincia: string;
    cp: string;
    pais?: string;
    predeterminada?: boolean;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
    ordenesEnvio?: OrdenUncheckedCreateNestedManyWithoutDireccionEnvioInput;
  };

  export type DireccionCreateOrConnectWithoutOrdenesFacturacionInput = {
    where: DireccionWhereUniqueInput;
    create: XOR<
      DireccionCreateWithoutOrdenesFacturacionInput,
      DireccionUncheckedCreateWithoutOrdenesFacturacionInput
    >;
  };

  export type ItemOrdenCreateWithoutOrdenInput = {
    tipo: $Enums.TipoItemOrden;
    refId: number;
    titulo: string;
    cantidad?: number;
    precioUnitario: number;
  };

  export type ItemOrdenUncheckedCreateWithoutOrdenInput = {
    id?: number;
    tipo: $Enums.TipoItemOrden;
    refId: number;
    titulo: string;
    cantidad?: number;
    precioUnitario: number;
  };

  export type ItemOrdenCreateOrConnectWithoutOrdenInput = {
    where: ItemOrdenWhereUniqueInput;
    create: XOR<
      ItemOrdenCreateWithoutOrdenInput,
      ItemOrdenUncheckedCreateWithoutOrdenInput
    >;
  };

  export type ItemOrdenCreateManyOrdenInputEnvelope = {
    data: ItemOrdenCreateManyOrdenInput | ItemOrdenCreateManyOrdenInput[];
    skipDuplicates?: boolean;
  };

  export type UsuarioUpsertWithoutOrdenesInput = {
    update: XOR<
      UsuarioUpdateWithoutOrdenesInput,
      UsuarioUncheckedUpdateWithoutOrdenesInput
    >;
    create: XOR<
      UsuarioCreateWithoutOrdenesInput,
      UsuarioUncheckedCreateWithoutOrdenesInput
    >;
    where?: UsuarioWhereInput;
  };

  export type UsuarioUpdateToOneWithWhereWithoutOrdenesInput = {
    where?: UsuarioWhereInput;
    data: XOR<
      UsuarioUpdateWithoutOrdenesInput,
      UsuarioUncheckedUpdateWithoutOrdenesInput
    >;
  };

  export type UsuarioUpdateWithoutOrdenesInput = {
    email?: StringFieldUpdateOperationsInput | string;
    nombre?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    emailVerificadoEn?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    roles?: UsuarioRolUpdateManyWithoutUsuarioNestedInput;
    cursosImpartidos?: CursoUpdateManyWithoutInstructorNestedInput;
    inscripciones?: InscripcionUpdateManyWithoutUsuarioNestedInput;
    resenas?: ResenaUpdateManyWithoutUsuarioNestedInput;
    resenaRespuestas?: ResenaRespuestaUpdateManyWithoutUsuarioNestedInput;
    favoritos?: FavoritoUpdateManyWithoutUsuarioNestedInput;
    resenaLikes?: ResenaLikeUpdateManyWithoutUsuarioNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput;
    carrito?: CarritoUpdateOneWithoutUsuarioNestedInput;
    notificaciones?: NotificacionUpdateManyWithoutUsuarioNestedInput;
  };

  export type UsuarioUncheckedUpdateWithoutOrdenesInput = {
    id?: IntFieldUpdateOperationsInput | number;
    email?: StringFieldUpdateOperationsInput | string;
    nombre?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    emailVerificadoEn?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    roles?: UsuarioRolUncheckedUpdateManyWithoutUsuarioNestedInput;
    cursosImpartidos?: CursoUncheckedUpdateManyWithoutInstructorNestedInput;
    inscripciones?: InscripcionUncheckedUpdateManyWithoutUsuarioNestedInput;
    resenas?: ResenaUncheckedUpdateManyWithoutUsuarioNestedInput;
    resenaRespuestas?: ResenaRespuestaUncheckedUpdateManyWithoutUsuarioNestedInput;
    favoritos?: FavoritoUncheckedUpdateManyWithoutUsuarioNestedInput;
    resenaLikes?: ResenaLikeUncheckedUpdateManyWithoutUsuarioNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    carrito?: CarritoUncheckedUpdateOneWithoutUsuarioNestedInput;
    notificaciones?: NotificacionUncheckedUpdateManyWithoutUsuarioNestedInput;
  };

  export type DireccionUpsertWithoutOrdenesEnvioInput = {
    update: XOR<
      DireccionUpdateWithoutOrdenesEnvioInput,
      DireccionUncheckedUpdateWithoutOrdenesEnvioInput
    >;
    create: XOR<
      DireccionCreateWithoutOrdenesEnvioInput,
      DireccionUncheckedCreateWithoutOrdenesEnvioInput
    >;
    where?: DireccionWhereInput;
  };

  export type DireccionUpdateToOneWithWhereWithoutOrdenesEnvioInput = {
    where?: DireccionWhereInput;
    data: XOR<
      DireccionUpdateWithoutOrdenesEnvioInput,
      DireccionUncheckedUpdateWithoutOrdenesEnvioInput
    >;
  };

  export type DireccionUpdateWithoutOrdenesEnvioInput = {
    usuarioId?: IntFieldUpdateOperationsInput | number;
    etiqueta?: NullableStringFieldUpdateOperationsInput | string | null;
    nombre?: StringFieldUpdateOperationsInput | string;
    telefono?: NullableStringFieldUpdateOperationsInput | string | null;
    calle?: StringFieldUpdateOperationsInput | string;
    numero?: NullableStringFieldUpdateOperationsInput | string | null;
    pisoDepto?: NullableStringFieldUpdateOperationsInput | string | null;
    ciudad?: StringFieldUpdateOperationsInput | string;
    provincia?: StringFieldUpdateOperationsInput | string;
    cp?: StringFieldUpdateOperationsInput | string;
    pais?: StringFieldUpdateOperationsInput | string;
    predeterminada?: BoolFieldUpdateOperationsInput | boolean;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    ordenesFacturacion?: OrdenUpdateManyWithoutDireccionFacturacionNestedInput;
  };

  export type DireccionUncheckedUpdateWithoutOrdenesEnvioInput = {
    id?: IntFieldUpdateOperationsInput | number;
    usuarioId?: IntFieldUpdateOperationsInput | number;
    etiqueta?: NullableStringFieldUpdateOperationsInput | string | null;
    nombre?: StringFieldUpdateOperationsInput | string;
    telefono?: NullableStringFieldUpdateOperationsInput | string | null;
    calle?: StringFieldUpdateOperationsInput | string;
    numero?: NullableStringFieldUpdateOperationsInput | string | null;
    pisoDepto?: NullableStringFieldUpdateOperationsInput | string | null;
    ciudad?: StringFieldUpdateOperationsInput | string;
    provincia?: StringFieldUpdateOperationsInput | string;
    cp?: StringFieldUpdateOperationsInput | string;
    pais?: StringFieldUpdateOperationsInput | string;
    predeterminada?: BoolFieldUpdateOperationsInput | boolean;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    ordenesFacturacion?: OrdenUncheckedUpdateManyWithoutDireccionFacturacionNestedInput;
  };

  export type DireccionUpsertWithoutOrdenesFacturacionInput = {
    update: XOR<
      DireccionUpdateWithoutOrdenesFacturacionInput,
      DireccionUncheckedUpdateWithoutOrdenesFacturacionInput
    >;
    create: XOR<
      DireccionCreateWithoutOrdenesFacturacionInput,
      DireccionUncheckedCreateWithoutOrdenesFacturacionInput
    >;
    where?: DireccionWhereInput;
  };

  export type DireccionUpdateToOneWithWhereWithoutOrdenesFacturacionInput = {
    where?: DireccionWhereInput;
    data: XOR<
      DireccionUpdateWithoutOrdenesFacturacionInput,
      DireccionUncheckedUpdateWithoutOrdenesFacturacionInput
    >;
  };

  export type DireccionUpdateWithoutOrdenesFacturacionInput = {
    usuarioId?: IntFieldUpdateOperationsInput | number;
    etiqueta?: NullableStringFieldUpdateOperationsInput | string | null;
    nombre?: StringFieldUpdateOperationsInput | string;
    telefono?: NullableStringFieldUpdateOperationsInput | string | null;
    calle?: StringFieldUpdateOperationsInput | string;
    numero?: NullableStringFieldUpdateOperationsInput | string | null;
    pisoDepto?: NullableStringFieldUpdateOperationsInput | string | null;
    ciudad?: StringFieldUpdateOperationsInput | string;
    provincia?: StringFieldUpdateOperationsInput | string;
    cp?: StringFieldUpdateOperationsInput | string;
    pais?: StringFieldUpdateOperationsInput | string;
    predeterminada?: BoolFieldUpdateOperationsInput | boolean;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    ordenesEnvio?: OrdenUpdateManyWithoutDireccionEnvioNestedInput;
  };

  export type DireccionUncheckedUpdateWithoutOrdenesFacturacionInput = {
    id?: IntFieldUpdateOperationsInput | number;
    usuarioId?: IntFieldUpdateOperationsInput | number;
    etiqueta?: NullableStringFieldUpdateOperationsInput | string | null;
    nombre?: StringFieldUpdateOperationsInput | string;
    telefono?: NullableStringFieldUpdateOperationsInput | string | null;
    calle?: StringFieldUpdateOperationsInput | string;
    numero?: NullableStringFieldUpdateOperationsInput | string | null;
    pisoDepto?: NullableStringFieldUpdateOperationsInput | string | null;
    ciudad?: StringFieldUpdateOperationsInput | string;
    provincia?: StringFieldUpdateOperationsInput | string;
    cp?: StringFieldUpdateOperationsInput | string;
    pais?: StringFieldUpdateOperationsInput | string;
    predeterminada?: BoolFieldUpdateOperationsInput | boolean;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    ordenesEnvio?: OrdenUncheckedUpdateManyWithoutDireccionEnvioNestedInput;
  };

  export type ItemOrdenUpsertWithWhereUniqueWithoutOrdenInput = {
    where: ItemOrdenWhereUniqueInput;
    update: XOR<
      ItemOrdenUpdateWithoutOrdenInput,
      ItemOrdenUncheckedUpdateWithoutOrdenInput
    >;
    create: XOR<
      ItemOrdenCreateWithoutOrdenInput,
      ItemOrdenUncheckedCreateWithoutOrdenInput
    >;
  };

  export type ItemOrdenUpdateWithWhereUniqueWithoutOrdenInput = {
    where: ItemOrdenWhereUniqueInput;
    data: XOR<
      ItemOrdenUpdateWithoutOrdenInput,
      ItemOrdenUncheckedUpdateWithoutOrdenInput
    >;
  };

  export type ItemOrdenUpdateManyWithWhereWithoutOrdenInput = {
    where: ItemOrdenScalarWhereInput;
    data: XOR<
      ItemOrdenUpdateManyMutationInput,
      ItemOrdenUncheckedUpdateManyWithoutOrdenInput
    >;
  };

  export type ItemOrdenScalarWhereInput = {
    AND?: ItemOrdenScalarWhereInput | ItemOrdenScalarWhereInput[];
    OR?: ItemOrdenScalarWhereInput[];
    NOT?: ItemOrdenScalarWhereInput | ItemOrdenScalarWhereInput[];
    id?: IntFilter<'ItemOrden'> | number;
    ordenId?: IntFilter<'ItemOrden'> | number;
    tipo?: EnumTipoItemOrdenFilter<'ItemOrden'> | $Enums.TipoItemOrden;
    refId?: IntFilter<'ItemOrden'> | number;
    titulo?: StringFilter<'ItemOrden'> | string;
    cantidad?: IntFilter<'ItemOrden'> | number;
    precioUnitario?: IntFilter<'ItemOrden'> | number;
  };

  export type OrdenCreateWithoutItemsInput = {
    estado?: $Enums.EstadoOrden;
    total: number;
    moneda?: string;
    referenciaPago?: string | null;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
    esSuscripcion?: boolean;
    suscripcionActiva?: boolean | null;
    suscripcionId?: string | null;
    suscripcionFrecuencia?: number | null;
    suscripcionTipoFrecuencia?: string | null;
    metadatos?: NullableJsonNullValueInput | InputJsonValue;
    usuario: UsuarioCreateNestedOneWithoutOrdenesInput;
    direccionEnvio?: DireccionCreateNestedOneWithoutOrdenesEnvioInput;
    direccionFacturacion?: DireccionCreateNestedOneWithoutOrdenesFacturacionInput;
  };

  export type OrdenUncheckedCreateWithoutItemsInput = {
    id?: number;
    usuarioId: number;
    estado?: $Enums.EstadoOrden;
    total: number;
    moneda?: string;
    referenciaPago?: string | null;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
    esSuscripcion?: boolean;
    suscripcionActiva?: boolean | null;
    suscripcionId?: string | null;
    suscripcionFrecuencia?: number | null;
    suscripcionTipoFrecuencia?: string | null;
    metadatos?: NullableJsonNullValueInput | InputJsonValue;
    direccionEnvioId?: number | null;
    direccionFacturacionId?: number | null;
  };

  export type OrdenCreateOrConnectWithoutItemsInput = {
    where: OrdenWhereUniqueInput;
    create: XOR<
      OrdenCreateWithoutItemsInput,
      OrdenUncheckedCreateWithoutItemsInput
    >;
  };

  export type OrdenUpsertWithoutItemsInput = {
    update: XOR<
      OrdenUpdateWithoutItemsInput,
      OrdenUncheckedUpdateWithoutItemsInput
    >;
    create: XOR<
      OrdenCreateWithoutItemsInput,
      OrdenUncheckedCreateWithoutItemsInput
    >;
    where?: OrdenWhereInput;
  };

  export type OrdenUpdateToOneWithWhereWithoutItemsInput = {
    where?: OrdenWhereInput;
    data: XOR<
      OrdenUpdateWithoutItemsInput,
      OrdenUncheckedUpdateWithoutItemsInput
    >;
  };

  export type OrdenUpdateWithoutItemsInput = {
    estado?: EnumEstadoOrdenFieldUpdateOperationsInput | $Enums.EstadoOrden;
    total?: IntFieldUpdateOperationsInput | number;
    moneda?: StringFieldUpdateOperationsInput | string;
    referenciaPago?: NullableStringFieldUpdateOperationsInput | string | null;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    esSuscripcion?: BoolFieldUpdateOperationsInput | boolean;
    suscripcionActiva?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    suscripcionId?: NullableStringFieldUpdateOperationsInput | string | null;
    suscripcionFrecuencia?:
      | NullableIntFieldUpdateOperationsInput
      | number
      | null;
    suscripcionTipoFrecuencia?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    metadatos?: NullableJsonNullValueInput | InputJsonValue;
    usuario?: UsuarioUpdateOneRequiredWithoutOrdenesNestedInput;
    direccionEnvio?: DireccionUpdateOneWithoutOrdenesEnvioNestedInput;
    direccionFacturacion?: DireccionUpdateOneWithoutOrdenesFacturacionNestedInput;
  };

  export type OrdenUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number;
    usuarioId?: IntFieldUpdateOperationsInput | number;
    estado?: EnumEstadoOrdenFieldUpdateOperationsInput | $Enums.EstadoOrden;
    total?: IntFieldUpdateOperationsInput | number;
    moneda?: StringFieldUpdateOperationsInput | string;
    referenciaPago?: NullableStringFieldUpdateOperationsInput | string | null;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    esSuscripcion?: BoolFieldUpdateOperationsInput | boolean;
    suscripcionActiva?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    suscripcionId?: NullableStringFieldUpdateOperationsInput | string | null;
    suscripcionFrecuencia?:
      | NullableIntFieldUpdateOperationsInput
      | number
      | null;
    suscripcionTipoFrecuencia?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    metadatos?: NullableJsonNullValueInput | InputJsonValue;
    direccionEnvioId?: NullableIntFieldUpdateOperationsInput | number | null;
    direccionFacturacionId?:
      | NullableIntFieldUpdateOperationsInput
      | number
      | null;
  };

  export type OrdenCreateWithoutDireccionEnvioInput = {
    estado?: $Enums.EstadoOrden;
    total: number;
    moneda?: string;
    referenciaPago?: string | null;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
    esSuscripcion?: boolean;
    suscripcionActiva?: boolean | null;
    suscripcionId?: string | null;
    suscripcionFrecuencia?: number | null;
    suscripcionTipoFrecuencia?: string | null;
    metadatos?: NullableJsonNullValueInput | InputJsonValue;
    usuario: UsuarioCreateNestedOneWithoutOrdenesInput;
    direccionFacturacion?: DireccionCreateNestedOneWithoutOrdenesFacturacionInput;
    items?: ItemOrdenCreateNestedManyWithoutOrdenInput;
  };

  export type OrdenUncheckedCreateWithoutDireccionEnvioInput = {
    id?: number;
    usuarioId: number;
    estado?: $Enums.EstadoOrden;
    total: number;
    moneda?: string;
    referenciaPago?: string | null;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
    esSuscripcion?: boolean;
    suscripcionActiva?: boolean | null;
    suscripcionId?: string | null;
    suscripcionFrecuencia?: number | null;
    suscripcionTipoFrecuencia?: string | null;
    metadatos?: NullableJsonNullValueInput | InputJsonValue;
    direccionFacturacionId?: number | null;
    items?: ItemOrdenUncheckedCreateNestedManyWithoutOrdenInput;
  };

  export type OrdenCreateOrConnectWithoutDireccionEnvioInput = {
    where: OrdenWhereUniqueInput;
    create: XOR<
      OrdenCreateWithoutDireccionEnvioInput,
      OrdenUncheckedCreateWithoutDireccionEnvioInput
    >;
  };

  export type OrdenCreateManyDireccionEnvioInputEnvelope = {
    data:
      | OrdenCreateManyDireccionEnvioInput
      | OrdenCreateManyDireccionEnvioInput[];
    skipDuplicates?: boolean;
  };

  export type OrdenCreateWithoutDireccionFacturacionInput = {
    estado?: $Enums.EstadoOrden;
    total: number;
    moneda?: string;
    referenciaPago?: string | null;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
    esSuscripcion?: boolean;
    suscripcionActiva?: boolean | null;
    suscripcionId?: string | null;
    suscripcionFrecuencia?: number | null;
    suscripcionTipoFrecuencia?: string | null;
    metadatos?: NullableJsonNullValueInput | InputJsonValue;
    usuario: UsuarioCreateNestedOneWithoutOrdenesInput;
    direccionEnvio?: DireccionCreateNestedOneWithoutOrdenesEnvioInput;
    items?: ItemOrdenCreateNestedManyWithoutOrdenInput;
  };

  export type OrdenUncheckedCreateWithoutDireccionFacturacionInput = {
    id?: number;
    usuarioId: number;
    estado?: $Enums.EstadoOrden;
    total: number;
    moneda?: string;
    referenciaPago?: string | null;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
    esSuscripcion?: boolean;
    suscripcionActiva?: boolean | null;
    suscripcionId?: string | null;
    suscripcionFrecuencia?: number | null;
    suscripcionTipoFrecuencia?: string | null;
    metadatos?: NullableJsonNullValueInput | InputJsonValue;
    direccionEnvioId?: number | null;
    items?: ItemOrdenUncheckedCreateNestedManyWithoutOrdenInput;
  };

  export type OrdenCreateOrConnectWithoutDireccionFacturacionInput = {
    where: OrdenWhereUniqueInput;
    create: XOR<
      OrdenCreateWithoutDireccionFacturacionInput,
      OrdenUncheckedCreateWithoutDireccionFacturacionInput
    >;
  };

  export type OrdenCreateManyDireccionFacturacionInputEnvelope = {
    data:
      | OrdenCreateManyDireccionFacturacionInput
      | OrdenCreateManyDireccionFacturacionInput[];
    skipDuplicates?: boolean;
  };

  export type OrdenUpsertWithWhereUniqueWithoutDireccionEnvioInput = {
    where: OrdenWhereUniqueInput;
    update: XOR<
      OrdenUpdateWithoutDireccionEnvioInput,
      OrdenUncheckedUpdateWithoutDireccionEnvioInput
    >;
    create: XOR<
      OrdenCreateWithoutDireccionEnvioInput,
      OrdenUncheckedCreateWithoutDireccionEnvioInput
    >;
  };

  export type OrdenUpdateWithWhereUniqueWithoutDireccionEnvioInput = {
    where: OrdenWhereUniqueInput;
    data: XOR<
      OrdenUpdateWithoutDireccionEnvioInput,
      OrdenUncheckedUpdateWithoutDireccionEnvioInput
    >;
  };

  export type OrdenUpdateManyWithWhereWithoutDireccionEnvioInput = {
    where: OrdenScalarWhereInput;
    data: XOR<
      OrdenUpdateManyMutationInput,
      OrdenUncheckedUpdateManyWithoutDireccionEnvioInput
    >;
  };

  export type OrdenUpsertWithWhereUniqueWithoutDireccionFacturacionInput = {
    where: OrdenWhereUniqueInput;
    update: XOR<
      OrdenUpdateWithoutDireccionFacturacionInput,
      OrdenUncheckedUpdateWithoutDireccionFacturacionInput
    >;
    create: XOR<
      OrdenCreateWithoutDireccionFacturacionInput,
      OrdenUncheckedCreateWithoutDireccionFacturacionInput
    >;
  };

  export type OrdenUpdateWithWhereUniqueWithoutDireccionFacturacionInput = {
    where: OrdenWhereUniqueInput;
    data: XOR<
      OrdenUpdateWithoutDireccionFacturacionInput,
      OrdenUncheckedUpdateWithoutDireccionFacturacionInput
    >;
  };

  export type OrdenUpdateManyWithWhereWithoutDireccionFacturacionInput = {
    where: OrdenScalarWhereInput;
    data: XOR<
      OrdenUpdateManyMutationInput,
      OrdenUncheckedUpdateManyWithoutDireccionFacturacionInput
    >;
  };

  export type CursoCreateWithoutResenasInput = {
    slug: string;
    titulo: string;
    resumen?: string | null;
    descripcionMD?: string | null;
    requisitos?: string | null;
    precio: number;
    publicado?: boolean;
    nivel?: $Enums.NivelCurso;
    portada?: string | null;
    destacado?: boolean;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    ratingProm?: Decimal | DecimalJsLike | number | string | null;
    ratingConteo?: number;
    creadoEn?: Date | string;
    instructor?: UsuarioCreateNestedOneWithoutCursosImpartidosInput;
    modulos?: ModuloCreateNestedManyWithoutCursoInput;
    inscripciones?: InscripcionCreateNestedManyWithoutCursoInput;
    itemsCarrito?: ItemCarritoCreateNestedManyWithoutCursoInput;
  };

  export type CursoUncheckedCreateWithoutResenasInput = {
    id?: number;
    slug: string;
    titulo: string;
    resumen?: string | null;
    descripcionMD?: string | null;
    requisitos?: string | null;
    precio: number;
    publicado?: boolean;
    nivel?: $Enums.NivelCurso;
    portada?: string | null;
    destacado?: boolean;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    ratingProm?: Decimal | DecimalJsLike | number | string | null;
    ratingConteo?: number;
    creadoEn?: Date | string;
    instructorId?: number | null;
    modulos?: ModuloUncheckedCreateNestedManyWithoutCursoInput;
    inscripciones?: InscripcionUncheckedCreateNestedManyWithoutCursoInput;
    itemsCarrito?: ItemCarritoUncheckedCreateNestedManyWithoutCursoInput;
  };

  export type CursoCreateOrConnectWithoutResenasInput = {
    where: CursoWhereUniqueInput;
    create: XOR<
      CursoCreateWithoutResenasInput,
      CursoUncheckedCreateWithoutResenasInput
    >;
  };

  export type ProductoCreateWithoutResenasInput = {
    slug: string;
    titulo: string;
    precio: number;
    stock?: number;
    publicado?: boolean;
    destacado?: boolean;
    imagen?: string | null;
    descripcionMD?: string | null;
    precioLista?: number | null;
    ratingProm?: Decimal | DecimalJsLike | number | string | null;
    ratingConteo?: number;
    creadoEn?: Date | string;
    marca?: MarcaCreateNestedOneWithoutProductosInput;
    categoria?: CategoriaCreateNestedOneWithoutProductosInput;
    imagenes?: ProductoImagenCreateNestedManyWithoutProductoInput;
    favoritos?: FavoritoCreateNestedManyWithoutProductoInput;
    itemsCarrito?: ItemCarritoCreateNestedManyWithoutProductoInput;
  };

  export type ProductoUncheckedCreateWithoutResenasInput = {
    id?: number;
    slug: string;
    titulo: string;
    precio: number;
    stock?: number;
    publicado?: boolean;
    destacado?: boolean;
    imagen?: string | null;
    descripcionMD?: string | null;
    precioLista?: number | null;
    ratingProm?: Decimal | DecimalJsLike | number | string | null;
    ratingConteo?: number;
    creadoEn?: Date | string;
    marcaId?: number | null;
    categoriaId?: number | null;
    imagenes?: ProductoImagenUncheckedCreateNestedManyWithoutProductoInput;
    favoritos?: FavoritoUncheckedCreateNestedManyWithoutProductoInput;
    itemsCarrito?: ItemCarritoUncheckedCreateNestedManyWithoutProductoInput;
  };

  export type ProductoCreateOrConnectWithoutResenasInput = {
    where: ProductoWhereUniqueInput;
    create: XOR<
      ProductoCreateWithoutResenasInput,
      ProductoUncheckedCreateWithoutResenasInput
    >;
  };

  export type UsuarioCreateWithoutResenasInput = {
    email: string;
    nombre?: string | null;
    passwordHash: string;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
    emailVerificadoEn?: Date | string | null;
    roles?: UsuarioRolCreateNestedManyWithoutUsuarioInput;
    cursosImpartidos?: CursoCreateNestedManyWithoutInstructorInput;
    inscripciones?: InscripcionCreateNestedManyWithoutUsuarioInput;
    resenaRespuestas?: ResenaRespuestaCreateNestedManyWithoutUsuarioInput;
    favoritos?: FavoritoCreateNestedManyWithoutUsuarioInput;
    resenaLikes?: ResenaLikeCreateNestedManyWithoutUsuarioInput;
    ordenes?: OrdenCreateNestedManyWithoutUsuarioInput;
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput;
    carrito?: CarritoCreateNestedOneWithoutUsuarioInput;
    notificaciones?: NotificacionCreateNestedManyWithoutUsuarioInput;
  };

  export type UsuarioUncheckedCreateWithoutResenasInput = {
    id?: number;
    email: string;
    nombre?: string | null;
    passwordHash: string;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
    emailVerificadoEn?: Date | string | null;
    roles?: UsuarioRolUncheckedCreateNestedManyWithoutUsuarioInput;
    cursosImpartidos?: CursoUncheckedCreateNestedManyWithoutInstructorInput;
    inscripciones?: InscripcionUncheckedCreateNestedManyWithoutUsuarioInput;
    resenaRespuestas?: ResenaRespuestaUncheckedCreateNestedManyWithoutUsuarioInput;
    favoritos?: FavoritoUncheckedCreateNestedManyWithoutUsuarioInput;
    resenaLikes?: ResenaLikeUncheckedCreateNestedManyWithoutUsuarioInput;
    ordenes?: OrdenUncheckedCreateNestedManyWithoutUsuarioInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    carrito?: CarritoUncheckedCreateNestedOneWithoutUsuarioInput;
    notificaciones?: NotificacionUncheckedCreateNestedManyWithoutUsuarioInput;
  };

  export type UsuarioCreateOrConnectWithoutResenasInput = {
    where: UsuarioWhereUniqueInput;
    create: XOR<
      UsuarioCreateWithoutResenasInput,
      UsuarioUncheckedCreateWithoutResenasInput
    >;
  };

  export type ResenaRespuestaCreateWithoutResenaInput = {
    contenido: string;
    eliminado?: boolean;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
    usuario: UsuarioCreateNestedOneWithoutResenaRespuestasInput;
    parent?: ResenaRespuestaCreateNestedOneWithoutHijosInput;
    hijos?: ResenaRespuestaCreateNestedManyWithoutParentInput;
  };

  export type ResenaRespuestaUncheckedCreateWithoutResenaInput = {
    id?: number;
    usuarioId: number;
    parentId?: number | null;
    contenido: string;
    eliminado?: boolean;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
    hijos?: ResenaRespuestaUncheckedCreateNestedManyWithoutParentInput;
  };

  export type ResenaRespuestaCreateOrConnectWithoutResenaInput = {
    where: ResenaRespuestaWhereUniqueInput;
    create: XOR<
      ResenaRespuestaCreateWithoutResenaInput,
      ResenaRespuestaUncheckedCreateWithoutResenaInput
    >;
  };

  export type ResenaRespuestaCreateManyResenaInputEnvelope = {
    data:
      | ResenaRespuestaCreateManyResenaInput
      | ResenaRespuestaCreateManyResenaInput[];
    skipDuplicates?: boolean;
  };

  export type ResenaLikeCreateWithoutResenaInput = {
    tipo: $Enums.TipoLike;
    creadoEn?: Date | string;
    usuario: UsuarioCreateNestedOneWithoutResenaLikesInput;
  };

  export type ResenaLikeUncheckedCreateWithoutResenaInput = {
    id?: number;
    usuarioId: number;
    tipo: $Enums.TipoLike;
    creadoEn?: Date | string;
  };

  export type ResenaLikeCreateOrConnectWithoutResenaInput = {
    where: ResenaLikeWhereUniqueInput;
    create: XOR<
      ResenaLikeCreateWithoutResenaInput,
      ResenaLikeUncheckedCreateWithoutResenaInput
    >;
  };

  export type ResenaLikeCreateManyResenaInputEnvelope = {
    data: ResenaLikeCreateManyResenaInput | ResenaLikeCreateManyResenaInput[];
    skipDuplicates?: boolean;
  };

  export type CursoUpsertWithoutResenasInput = {
    update: XOR<
      CursoUpdateWithoutResenasInput,
      CursoUncheckedUpdateWithoutResenasInput
    >;
    create: XOR<
      CursoCreateWithoutResenasInput,
      CursoUncheckedCreateWithoutResenasInput
    >;
    where?: CursoWhereInput;
  };

  export type CursoUpdateToOneWithWhereWithoutResenasInput = {
    where?: CursoWhereInput;
    data: XOR<
      CursoUpdateWithoutResenasInput,
      CursoUncheckedUpdateWithoutResenasInput
    >;
  };

  export type CursoUpdateWithoutResenasInput = {
    slug?: StringFieldUpdateOperationsInput | string;
    titulo?: StringFieldUpdateOperationsInput | string;
    resumen?: NullableStringFieldUpdateOperationsInput | string | null;
    descripcionMD?: NullableStringFieldUpdateOperationsInput | string | null;
    requisitos?: NullableStringFieldUpdateOperationsInput | string | null;
    precio?: IntFieldUpdateOperationsInput | number;
    publicado?: BoolFieldUpdateOperationsInput | boolean;
    nivel?: EnumNivelCursoFieldUpdateOperationsInput | $Enums.NivelCurso;
    portada?: NullableStringFieldUpdateOperationsInput | string | null;
    destacado?: BoolFieldUpdateOperationsInput | boolean;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    ratingProm?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    ratingConteo?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    instructor?: UsuarioUpdateOneWithoutCursosImpartidosNestedInput;
    modulos?: ModuloUpdateManyWithoutCursoNestedInput;
    inscripciones?: InscripcionUpdateManyWithoutCursoNestedInput;
    itemsCarrito?: ItemCarritoUpdateManyWithoutCursoNestedInput;
  };

  export type CursoUncheckedUpdateWithoutResenasInput = {
    id?: IntFieldUpdateOperationsInput | number;
    slug?: StringFieldUpdateOperationsInput | string;
    titulo?: StringFieldUpdateOperationsInput | string;
    resumen?: NullableStringFieldUpdateOperationsInput | string | null;
    descripcionMD?: NullableStringFieldUpdateOperationsInput | string | null;
    requisitos?: NullableStringFieldUpdateOperationsInput | string | null;
    precio?: IntFieldUpdateOperationsInput | number;
    publicado?: BoolFieldUpdateOperationsInput | boolean;
    nivel?: EnumNivelCursoFieldUpdateOperationsInput | $Enums.NivelCurso;
    portada?: NullableStringFieldUpdateOperationsInput | string | null;
    destacado?: BoolFieldUpdateOperationsInput | boolean;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    ratingProm?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    ratingConteo?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    instructorId?: NullableIntFieldUpdateOperationsInput | number | null;
    modulos?: ModuloUncheckedUpdateManyWithoutCursoNestedInput;
    inscripciones?: InscripcionUncheckedUpdateManyWithoutCursoNestedInput;
    itemsCarrito?: ItemCarritoUncheckedUpdateManyWithoutCursoNestedInput;
  };

  export type ProductoUpsertWithoutResenasInput = {
    update: XOR<
      ProductoUpdateWithoutResenasInput,
      ProductoUncheckedUpdateWithoutResenasInput
    >;
    create: XOR<
      ProductoCreateWithoutResenasInput,
      ProductoUncheckedCreateWithoutResenasInput
    >;
    where?: ProductoWhereInput;
  };

  export type ProductoUpdateToOneWithWhereWithoutResenasInput = {
    where?: ProductoWhereInput;
    data: XOR<
      ProductoUpdateWithoutResenasInput,
      ProductoUncheckedUpdateWithoutResenasInput
    >;
  };

  export type ProductoUpdateWithoutResenasInput = {
    slug?: StringFieldUpdateOperationsInput | string;
    titulo?: StringFieldUpdateOperationsInput | string;
    precio?: IntFieldUpdateOperationsInput | number;
    stock?: IntFieldUpdateOperationsInput | number;
    publicado?: BoolFieldUpdateOperationsInput | boolean;
    destacado?: BoolFieldUpdateOperationsInput | boolean;
    imagen?: NullableStringFieldUpdateOperationsInput | string | null;
    descripcionMD?: NullableStringFieldUpdateOperationsInput | string | null;
    precioLista?: NullableIntFieldUpdateOperationsInput | number | null;
    ratingProm?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    ratingConteo?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    marca?: MarcaUpdateOneWithoutProductosNestedInput;
    categoria?: CategoriaUpdateOneWithoutProductosNestedInput;
    imagenes?: ProductoImagenUpdateManyWithoutProductoNestedInput;
    favoritos?: FavoritoUpdateManyWithoutProductoNestedInput;
    itemsCarrito?: ItemCarritoUpdateManyWithoutProductoNestedInput;
  };

  export type ProductoUncheckedUpdateWithoutResenasInput = {
    id?: IntFieldUpdateOperationsInput | number;
    slug?: StringFieldUpdateOperationsInput | string;
    titulo?: StringFieldUpdateOperationsInput | string;
    precio?: IntFieldUpdateOperationsInput | number;
    stock?: IntFieldUpdateOperationsInput | number;
    publicado?: BoolFieldUpdateOperationsInput | boolean;
    destacado?: BoolFieldUpdateOperationsInput | boolean;
    imagen?: NullableStringFieldUpdateOperationsInput | string | null;
    descripcionMD?: NullableStringFieldUpdateOperationsInput | string | null;
    precioLista?: NullableIntFieldUpdateOperationsInput | number | null;
    ratingProm?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    ratingConteo?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    marcaId?: NullableIntFieldUpdateOperationsInput | number | null;
    categoriaId?: NullableIntFieldUpdateOperationsInput | number | null;
    imagenes?: ProductoImagenUncheckedUpdateManyWithoutProductoNestedInput;
    favoritos?: FavoritoUncheckedUpdateManyWithoutProductoNestedInput;
    itemsCarrito?: ItemCarritoUncheckedUpdateManyWithoutProductoNestedInput;
  };

  export type UsuarioUpsertWithoutResenasInput = {
    update: XOR<
      UsuarioUpdateWithoutResenasInput,
      UsuarioUncheckedUpdateWithoutResenasInput
    >;
    create: XOR<
      UsuarioCreateWithoutResenasInput,
      UsuarioUncheckedCreateWithoutResenasInput
    >;
    where?: UsuarioWhereInput;
  };

  export type UsuarioUpdateToOneWithWhereWithoutResenasInput = {
    where?: UsuarioWhereInput;
    data: XOR<
      UsuarioUpdateWithoutResenasInput,
      UsuarioUncheckedUpdateWithoutResenasInput
    >;
  };

  export type UsuarioUpdateWithoutResenasInput = {
    email?: StringFieldUpdateOperationsInput | string;
    nombre?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    emailVerificadoEn?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    roles?: UsuarioRolUpdateManyWithoutUsuarioNestedInput;
    cursosImpartidos?: CursoUpdateManyWithoutInstructorNestedInput;
    inscripciones?: InscripcionUpdateManyWithoutUsuarioNestedInput;
    resenaRespuestas?: ResenaRespuestaUpdateManyWithoutUsuarioNestedInput;
    favoritos?: FavoritoUpdateManyWithoutUsuarioNestedInput;
    resenaLikes?: ResenaLikeUpdateManyWithoutUsuarioNestedInput;
    ordenes?: OrdenUpdateManyWithoutUsuarioNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput;
    carrito?: CarritoUpdateOneWithoutUsuarioNestedInput;
    notificaciones?: NotificacionUpdateManyWithoutUsuarioNestedInput;
  };

  export type UsuarioUncheckedUpdateWithoutResenasInput = {
    id?: IntFieldUpdateOperationsInput | number;
    email?: StringFieldUpdateOperationsInput | string;
    nombre?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    emailVerificadoEn?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    roles?: UsuarioRolUncheckedUpdateManyWithoutUsuarioNestedInput;
    cursosImpartidos?: CursoUncheckedUpdateManyWithoutInstructorNestedInput;
    inscripciones?: InscripcionUncheckedUpdateManyWithoutUsuarioNestedInput;
    resenaRespuestas?: ResenaRespuestaUncheckedUpdateManyWithoutUsuarioNestedInput;
    favoritos?: FavoritoUncheckedUpdateManyWithoutUsuarioNestedInput;
    resenaLikes?: ResenaLikeUncheckedUpdateManyWithoutUsuarioNestedInput;
    ordenes?: OrdenUncheckedUpdateManyWithoutUsuarioNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    carrito?: CarritoUncheckedUpdateOneWithoutUsuarioNestedInput;
    notificaciones?: NotificacionUncheckedUpdateManyWithoutUsuarioNestedInput;
  };

  export type ResenaRespuestaUpsertWithWhereUniqueWithoutResenaInput = {
    where: ResenaRespuestaWhereUniqueInput;
    update: XOR<
      ResenaRespuestaUpdateWithoutResenaInput,
      ResenaRespuestaUncheckedUpdateWithoutResenaInput
    >;
    create: XOR<
      ResenaRespuestaCreateWithoutResenaInput,
      ResenaRespuestaUncheckedCreateWithoutResenaInput
    >;
  };

  export type ResenaRespuestaUpdateWithWhereUniqueWithoutResenaInput = {
    where: ResenaRespuestaWhereUniqueInput;
    data: XOR<
      ResenaRespuestaUpdateWithoutResenaInput,
      ResenaRespuestaUncheckedUpdateWithoutResenaInput
    >;
  };

  export type ResenaRespuestaUpdateManyWithWhereWithoutResenaInput = {
    where: ResenaRespuestaScalarWhereInput;
    data: XOR<
      ResenaRespuestaUpdateManyMutationInput,
      ResenaRespuestaUncheckedUpdateManyWithoutResenaInput
    >;
  };

  export type ResenaLikeUpsertWithWhereUniqueWithoutResenaInput = {
    where: ResenaLikeWhereUniqueInput;
    update: XOR<
      ResenaLikeUpdateWithoutResenaInput,
      ResenaLikeUncheckedUpdateWithoutResenaInput
    >;
    create: XOR<
      ResenaLikeCreateWithoutResenaInput,
      ResenaLikeUncheckedCreateWithoutResenaInput
    >;
  };

  export type ResenaLikeUpdateWithWhereUniqueWithoutResenaInput = {
    where: ResenaLikeWhereUniqueInput;
    data: XOR<
      ResenaLikeUpdateWithoutResenaInput,
      ResenaLikeUncheckedUpdateWithoutResenaInput
    >;
  };

  export type ResenaLikeUpdateManyWithWhereWithoutResenaInput = {
    where: ResenaLikeScalarWhereInput;
    data: XOR<
      ResenaLikeUpdateManyMutationInput,
      ResenaLikeUncheckedUpdateManyWithoutResenaInput
    >;
  };

  export type ResenaCreateWithoutLikesInput = {
    puntaje: number;
    comentario?: string | null;
    creadoEn?: Date | string;
    curso?: CursoCreateNestedOneWithoutResenasInput;
    producto?: ProductoCreateNestedOneWithoutResenasInput;
    usuario: UsuarioCreateNestedOneWithoutResenasInput;
    respuestas?: ResenaRespuestaCreateNestedManyWithoutResenaInput;
  };

  export type ResenaUncheckedCreateWithoutLikesInput = {
    id?: number;
    cursoId?: number | null;
    productoId?: number | null;
    usuarioId: number;
    puntaje: number;
    comentario?: string | null;
    creadoEn?: Date | string;
    respuestas?: ResenaRespuestaUncheckedCreateNestedManyWithoutResenaInput;
  };

  export type ResenaCreateOrConnectWithoutLikesInput = {
    where: ResenaWhereUniqueInput;
    create: XOR<
      ResenaCreateWithoutLikesInput,
      ResenaUncheckedCreateWithoutLikesInput
    >;
  };

  export type UsuarioCreateWithoutResenaLikesInput = {
    email: string;
    nombre?: string | null;
    passwordHash: string;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
    emailVerificadoEn?: Date | string | null;
    roles?: UsuarioRolCreateNestedManyWithoutUsuarioInput;
    cursosImpartidos?: CursoCreateNestedManyWithoutInstructorInput;
    inscripciones?: InscripcionCreateNestedManyWithoutUsuarioInput;
    resenas?: ResenaCreateNestedManyWithoutUsuarioInput;
    resenaRespuestas?: ResenaRespuestaCreateNestedManyWithoutUsuarioInput;
    favoritos?: FavoritoCreateNestedManyWithoutUsuarioInput;
    ordenes?: OrdenCreateNestedManyWithoutUsuarioInput;
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput;
    carrito?: CarritoCreateNestedOneWithoutUsuarioInput;
    notificaciones?: NotificacionCreateNestedManyWithoutUsuarioInput;
  };

  export type UsuarioUncheckedCreateWithoutResenaLikesInput = {
    id?: number;
    email: string;
    nombre?: string | null;
    passwordHash: string;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
    emailVerificadoEn?: Date | string | null;
    roles?: UsuarioRolUncheckedCreateNestedManyWithoutUsuarioInput;
    cursosImpartidos?: CursoUncheckedCreateNestedManyWithoutInstructorInput;
    inscripciones?: InscripcionUncheckedCreateNestedManyWithoutUsuarioInput;
    resenas?: ResenaUncheckedCreateNestedManyWithoutUsuarioInput;
    resenaRespuestas?: ResenaRespuestaUncheckedCreateNestedManyWithoutUsuarioInput;
    favoritos?: FavoritoUncheckedCreateNestedManyWithoutUsuarioInput;
    ordenes?: OrdenUncheckedCreateNestedManyWithoutUsuarioInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    carrito?: CarritoUncheckedCreateNestedOneWithoutUsuarioInput;
    notificaciones?: NotificacionUncheckedCreateNestedManyWithoutUsuarioInput;
  };

  export type UsuarioCreateOrConnectWithoutResenaLikesInput = {
    where: UsuarioWhereUniqueInput;
    create: XOR<
      UsuarioCreateWithoutResenaLikesInput,
      UsuarioUncheckedCreateWithoutResenaLikesInput
    >;
  };

  export type ResenaUpsertWithoutLikesInput = {
    update: XOR<
      ResenaUpdateWithoutLikesInput,
      ResenaUncheckedUpdateWithoutLikesInput
    >;
    create: XOR<
      ResenaCreateWithoutLikesInput,
      ResenaUncheckedCreateWithoutLikesInput
    >;
    where?: ResenaWhereInput;
  };

  export type ResenaUpdateToOneWithWhereWithoutLikesInput = {
    where?: ResenaWhereInput;
    data: XOR<
      ResenaUpdateWithoutLikesInput,
      ResenaUncheckedUpdateWithoutLikesInput
    >;
  };

  export type ResenaUpdateWithoutLikesInput = {
    puntaje?: IntFieldUpdateOperationsInput | number;
    comentario?: NullableStringFieldUpdateOperationsInput | string | null;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    curso?: CursoUpdateOneWithoutResenasNestedInput;
    producto?: ProductoUpdateOneWithoutResenasNestedInput;
    usuario?: UsuarioUpdateOneRequiredWithoutResenasNestedInput;
    respuestas?: ResenaRespuestaUpdateManyWithoutResenaNestedInput;
  };

  export type ResenaUncheckedUpdateWithoutLikesInput = {
    id?: IntFieldUpdateOperationsInput | number;
    cursoId?: NullableIntFieldUpdateOperationsInput | number | null;
    productoId?: NullableIntFieldUpdateOperationsInput | number | null;
    usuarioId?: IntFieldUpdateOperationsInput | number;
    puntaje?: IntFieldUpdateOperationsInput | number;
    comentario?: NullableStringFieldUpdateOperationsInput | string | null;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    respuestas?: ResenaRespuestaUncheckedUpdateManyWithoutResenaNestedInput;
  };

  export type UsuarioUpsertWithoutResenaLikesInput = {
    update: XOR<
      UsuarioUpdateWithoutResenaLikesInput,
      UsuarioUncheckedUpdateWithoutResenaLikesInput
    >;
    create: XOR<
      UsuarioCreateWithoutResenaLikesInput,
      UsuarioUncheckedCreateWithoutResenaLikesInput
    >;
    where?: UsuarioWhereInput;
  };

  export type UsuarioUpdateToOneWithWhereWithoutResenaLikesInput = {
    where?: UsuarioWhereInput;
    data: XOR<
      UsuarioUpdateWithoutResenaLikesInput,
      UsuarioUncheckedUpdateWithoutResenaLikesInput
    >;
  };

  export type UsuarioUpdateWithoutResenaLikesInput = {
    email?: StringFieldUpdateOperationsInput | string;
    nombre?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    emailVerificadoEn?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    roles?: UsuarioRolUpdateManyWithoutUsuarioNestedInput;
    cursosImpartidos?: CursoUpdateManyWithoutInstructorNestedInput;
    inscripciones?: InscripcionUpdateManyWithoutUsuarioNestedInput;
    resenas?: ResenaUpdateManyWithoutUsuarioNestedInput;
    resenaRespuestas?: ResenaRespuestaUpdateManyWithoutUsuarioNestedInput;
    favoritos?: FavoritoUpdateManyWithoutUsuarioNestedInput;
    ordenes?: OrdenUpdateManyWithoutUsuarioNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput;
    carrito?: CarritoUpdateOneWithoutUsuarioNestedInput;
    notificaciones?: NotificacionUpdateManyWithoutUsuarioNestedInput;
  };

  export type UsuarioUncheckedUpdateWithoutResenaLikesInput = {
    id?: IntFieldUpdateOperationsInput | number;
    email?: StringFieldUpdateOperationsInput | string;
    nombre?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    emailVerificadoEn?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    roles?: UsuarioRolUncheckedUpdateManyWithoutUsuarioNestedInput;
    cursosImpartidos?: CursoUncheckedUpdateManyWithoutInstructorNestedInput;
    inscripciones?: InscripcionUncheckedUpdateManyWithoutUsuarioNestedInput;
    resenas?: ResenaUncheckedUpdateManyWithoutUsuarioNestedInput;
    resenaRespuestas?: ResenaRespuestaUncheckedUpdateManyWithoutUsuarioNestedInput;
    favoritos?: FavoritoUncheckedUpdateManyWithoutUsuarioNestedInput;
    ordenes?: OrdenUncheckedUpdateManyWithoutUsuarioNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    carrito?: CarritoUncheckedUpdateOneWithoutUsuarioNestedInput;
    notificaciones?: NotificacionUncheckedUpdateManyWithoutUsuarioNestedInput;
  };

  export type ResenaCreateWithoutRespuestasInput = {
    puntaje: number;
    comentario?: string | null;
    creadoEn?: Date | string;
    curso?: CursoCreateNestedOneWithoutResenasInput;
    producto?: ProductoCreateNestedOneWithoutResenasInput;
    usuario: UsuarioCreateNestedOneWithoutResenasInput;
    likes?: ResenaLikeCreateNestedManyWithoutResenaInput;
  };

  export type ResenaUncheckedCreateWithoutRespuestasInput = {
    id?: number;
    cursoId?: number | null;
    productoId?: number | null;
    usuarioId: number;
    puntaje: number;
    comentario?: string | null;
    creadoEn?: Date | string;
    likes?: ResenaLikeUncheckedCreateNestedManyWithoutResenaInput;
  };

  export type ResenaCreateOrConnectWithoutRespuestasInput = {
    where: ResenaWhereUniqueInput;
    create: XOR<
      ResenaCreateWithoutRespuestasInput,
      ResenaUncheckedCreateWithoutRespuestasInput
    >;
  };

  export type UsuarioCreateWithoutResenaRespuestasInput = {
    email: string;
    nombre?: string | null;
    passwordHash: string;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
    emailVerificadoEn?: Date | string | null;
    roles?: UsuarioRolCreateNestedManyWithoutUsuarioInput;
    cursosImpartidos?: CursoCreateNestedManyWithoutInstructorInput;
    inscripciones?: InscripcionCreateNestedManyWithoutUsuarioInput;
    resenas?: ResenaCreateNestedManyWithoutUsuarioInput;
    favoritos?: FavoritoCreateNestedManyWithoutUsuarioInput;
    resenaLikes?: ResenaLikeCreateNestedManyWithoutUsuarioInput;
    ordenes?: OrdenCreateNestedManyWithoutUsuarioInput;
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput;
    carrito?: CarritoCreateNestedOneWithoutUsuarioInput;
    notificaciones?: NotificacionCreateNestedManyWithoutUsuarioInput;
  };

  export type UsuarioUncheckedCreateWithoutResenaRespuestasInput = {
    id?: number;
    email: string;
    nombre?: string | null;
    passwordHash: string;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
    emailVerificadoEn?: Date | string | null;
    roles?: UsuarioRolUncheckedCreateNestedManyWithoutUsuarioInput;
    cursosImpartidos?: CursoUncheckedCreateNestedManyWithoutInstructorInput;
    inscripciones?: InscripcionUncheckedCreateNestedManyWithoutUsuarioInput;
    resenas?: ResenaUncheckedCreateNestedManyWithoutUsuarioInput;
    favoritos?: FavoritoUncheckedCreateNestedManyWithoutUsuarioInput;
    resenaLikes?: ResenaLikeUncheckedCreateNestedManyWithoutUsuarioInput;
    ordenes?: OrdenUncheckedCreateNestedManyWithoutUsuarioInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    carrito?: CarritoUncheckedCreateNestedOneWithoutUsuarioInput;
    notificaciones?: NotificacionUncheckedCreateNestedManyWithoutUsuarioInput;
  };

  export type UsuarioCreateOrConnectWithoutResenaRespuestasInput = {
    where: UsuarioWhereUniqueInput;
    create: XOR<
      UsuarioCreateWithoutResenaRespuestasInput,
      UsuarioUncheckedCreateWithoutResenaRespuestasInput
    >;
  };

  export type ResenaRespuestaCreateWithoutHijosInput = {
    contenido: string;
    eliminado?: boolean;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
    resena: ResenaCreateNestedOneWithoutRespuestasInput;
    usuario: UsuarioCreateNestedOneWithoutResenaRespuestasInput;
    parent?: ResenaRespuestaCreateNestedOneWithoutHijosInput;
  };

  export type ResenaRespuestaUncheckedCreateWithoutHijosInput = {
    id?: number;
    resenaId: number;
    usuarioId: number;
    parentId?: number | null;
    contenido: string;
    eliminado?: boolean;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
  };

  export type ResenaRespuestaCreateOrConnectWithoutHijosInput = {
    where: ResenaRespuestaWhereUniqueInput;
    create: XOR<
      ResenaRespuestaCreateWithoutHijosInput,
      ResenaRespuestaUncheckedCreateWithoutHijosInput
    >;
  };

  export type ResenaRespuestaCreateWithoutParentInput = {
    contenido: string;
    eliminado?: boolean;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
    resena: ResenaCreateNestedOneWithoutRespuestasInput;
    usuario: UsuarioCreateNestedOneWithoutResenaRespuestasInput;
    hijos?: ResenaRespuestaCreateNestedManyWithoutParentInput;
  };

  export type ResenaRespuestaUncheckedCreateWithoutParentInput = {
    id?: number;
    resenaId: number;
    usuarioId: number;
    contenido: string;
    eliminado?: boolean;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
    hijos?: ResenaRespuestaUncheckedCreateNestedManyWithoutParentInput;
  };

  export type ResenaRespuestaCreateOrConnectWithoutParentInput = {
    where: ResenaRespuestaWhereUniqueInput;
    create: XOR<
      ResenaRespuestaCreateWithoutParentInput,
      ResenaRespuestaUncheckedCreateWithoutParentInput
    >;
  };

  export type ResenaRespuestaCreateManyParentInputEnvelope = {
    data:
      | ResenaRespuestaCreateManyParentInput
      | ResenaRespuestaCreateManyParentInput[];
    skipDuplicates?: boolean;
  };

  export type ResenaUpsertWithoutRespuestasInput = {
    update: XOR<
      ResenaUpdateWithoutRespuestasInput,
      ResenaUncheckedUpdateWithoutRespuestasInput
    >;
    create: XOR<
      ResenaCreateWithoutRespuestasInput,
      ResenaUncheckedCreateWithoutRespuestasInput
    >;
    where?: ResenaWhereInput;
  };

  export type ResenaUpdateToOneWithWhereWithoutRespuestasInput = {
    where?: ResenaWhereInput;
    data: XOR<
      ResenaUpdateWithoutRespuestasInput,
      ResenaUncheckedUpdateWithoutRespuestasInput
    >;
  };

  export type ResenaUpdateWithoutRespuestasInput = {
    puntaje?: IntFieldUpdateOperationsInput | number;
    comentario?: NullableStringFieldUpdateOperationsInput | string | null;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    curso?: CursoUpdateOneWithoutResenasNestedInput;
    producto?: ProductoUpdateOneWithoutResenasNestedInput;
    usuario?: UsuarioUpdateOneRequiredWithoutResenasNestedInput;
    likes?: ResenaLikeUpdateManyWithoutResenaNestedInput;
  };

  export type ResenaUncheckedUpdateWithoutRespuestasInput = {
    id?: IntFieldUpdateOperationsInput | number;
    cursoId?: NullableIntFieldUpdateOperationsInput | number | null;
    productoId?: NullableIntFieldUpdateOperationsInput | number | null;
    usuarioId?: IntFieldUpdateOperationsInput | number;
    puntaje?: IntFieldUpdateOperationsInput | number;
    comentario?: NullableStringFieldUpdateOperationsInput | string | null;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    likes?: ResenaLikeUncheckedUpdateManyWithoutResenaNestedInput;
  };

  export type UsuarioUpsertWithoutResenaRespuestasInput = {
    update: XOR<
      UsuarioUpdateWithoutResenaRespuestasInput,
      UsuarioUncheckedUpdateWithoutResenaRespuestasInput
    >;
    create: XOR<
      UsuarioCreateWithoutResenaRespuestasInput,
      UsuarioUncheckedCreateWithoutResenaRespuestasInput
    >;
    where?: UsuarioWhereInput;
  };

  export type UsuarioUpdateToOneWithWhereWithoutResenaRespuestasInput = {
    where?: UsuarioWhereInput;
    data: XOR<
      UsuarioUpdateWithoutResenaRespuestasInput,
      UsuarioUncheckedUpdateWithoutResenaRespuestasInput
    >;
  };

  export type UsuarioUpdateWithoutResenaRespuestasInput = {
    email?: StringFieldUpdateOperationsInput | string;
    nombre?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    emailVerificadoEn?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    roles?: UsuarioRolUpdateManyWithoutUsuarioNestedInput;
    cursosImpartidos?: CursoUpdateManyWithoutInstructorNestedInput;
    inscripciones?: InscripcionUpdateManyWithoutUsuarioNestedInput;
    resenas?: ResenaUpdateManyWithoutUsuarioNestedInput;
    favoritos?: FavoritoUpdateManyWithoutUsuarioNestedInput;
    resenaLikes?: ResenaLikeUpdateManyWithoutUsuarioNestedInput;
    ordenes?: OrdenUpdateManyWithoutUsuarioNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput;
    carrito?: CarritoUpdateOneWithoutUsuarioNestedInput;
    notificaciones?: NotificacionUpdateManyWithoutUsuarioNestedInput;
  };

  export type UsuarioUncheckedUpdateWithoutResenaRespuestasInput = {
    id?: IntFieldUpdateOperationsInput | number;
    email?: StringFieldUpdateOperationsInput | string;
    nombre?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    emailVerificadoEn?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    roles?: UsuarioRolUncheckedUpdateManyWithoutUsuarioNestedInput;
    cursosImpartidos?: CursoUncheckedUpdateManyWithoutInstructorNestedInput;
    inscripciones?: InscripcionUncheckedUpdateManyWithoutUsuarioNestedInput;
    resenas?: ResenaUncheckedUpdateManyWithoutUsuarioNestedInput;
    favoritos?: FavoritoUncheckedUpdateManyWithoutUsuarioNestedInput;
    resenaLikes?: ResenaLikeUncheckedUpdateManyWithoutUsuarioNestedInput;
    ordenes?: OrdenUncheckedUpdateManyWithoutUsuarioNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    carrito?: CarritoUncheckedUpdateOneWithoutUsuarioNestedInput;
    notificaciones?: NotificacionUncheckedUpdateManyWithoutUsuarioNestedInput;
  };

  export type ResenaRespuestaUpsertWithoutHijosInput = {
    update: XOR<
      ResenaRespuestaUpdateWithoutHijosInput,
      ResenaRespuestaUncheckedUpdateWithoutHijosInput
    >;
    create: XOR<
      ResenaRespuestaCreateWithoutHijosInput,
      ResenaRespuestaUncheckedCreateWithoutHijosInput
    >;
    where?: ResenaRespuestaWhereInput;
  };

  export type ResenaRespuestaUpdateToOneWithWhereWithoutHijosInput = {
    where?: ResenaRespuestaWhereInput;
    data: XOR<
      ResenaRespuestaUpdateWithoutHijosInput,
      ResenaRespuestaUncheckedUpdateWithoutHijosInput
    >;
  };

  export type ResenaRespuestaUpdateWithoutHijosInput = {
    contenido?: StringFieldUpdateOperationsInput | string;
    eliminado?: BoolFieldUpdateOperationsInput | boolean;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    resena?: ResenaUpdateOneRequiredWithoutRespuestasNestedInput;
    usuario?: UsuarioUpdateOneRequiredWithoutResenaRespuestasNestedInput;
    parent?: ResenaRespuestaUpdateOneWithoutHijosNestedInput;
  };

  export type ResenaRespuestaUncheckedUpdateWithoutHijosInput = {
    id?: IntFieldUpdateOperationsInput | number;
    resenaId?: IntFieldUpdateOperationsInput | number;
    usuarioId?: IntFieldUpdateOperationsInput | number;
    parentId?: NullableIntFieldUpdateOperationsInput | number | null;
    contenido?: StringFieldUpdateOperationsInput | string;
    eliminado?: BoolFieldUpdateOperationsInput | boolean;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ResenaRespuestaUpsertWithWhereUniqueWithoutParentInput = {
    where: ResenaRespuestaWhereUniqueInput;
    update: XOR<
      ResenaRespuestaUpdateWithoutParentInput,
      ResenaRespuestaUncheckedUpdateWithoutParentInput
    >;
    create: XOR<
      ResenaRespuestaCreateWithoutParentInput,
      ResenaRespuestaUncheckedCreateWithoutParentInput
    >;
  };

  export type ResenaRespuestaUpdateWithWhereUniqueWithoutParentInput = {
    where: ResenaRespuestaWhereUniqueInput;
    data: XOR<
      ResenaRespuestaUpdateWithoutParentInput,
      ResenaRespuestaUncheckedUpdateWithoutParentInput
    >;
  };

  export type ResenaRespuestaUpdateManyWithWhereWithoutParentInput = {
    where: ResenaRespuestaScalarWhereInput;
    data: XOR<
      ResenaRespuestaUpdateManyMutationInput,
      ResenaRespuestaUncheckedUpdateManyWithoutParentInput
    >;
  };

  export type UsuarioCreateWithoutNotificacionesInput = {
    email: string;
    nombre?: string | null;
    passwordHash: string;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
    emailVerificadoEn?: Date | string | null;
    roles?: UsuarioRolCreateNestedManyWithoutUsuarioInput;
    cursosImpartidos?: CursoCreateNestedManyWithoutInstructorInput;
    inscripciones?: InscripcionCreateNestedManyWithoutUsuarioInput;
    resenas?: ResenaCreateNestedManyWithoutUsuarioInput;
    resenaRespuestas?: ResenaRespuestaCreateNestedManyWithoutUsuarioInput;
    favoritos?: FavoritoCreateNestedManyWithoutUsuarioInput;
    resenaLikes?: ResenaLikeCreateNestedManyWithoutUsuarioInput;
    ordenes?: OrdenCreateNestedManyWithoutUsuarioInput;
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput;
    carrito?: CarritoCreateNestedOneWithoutUsuarioInput;
  };

  export type UsuarioUncheckedCreateWithoutNotificacionesInput = {
    id?: number;
    email: string;
    nombre?: string | null;
    passwordHash: string;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
    emailVerificadoEn?: Date | string | null;
    roles?: UsuarioRolUncheckedCreateNestedManyWithoutUsuarioInput;
    cursosImpartidos?: CursoUncheckedCreateNestedManyWithoutInstructorInput;
    inscripciones?: InscripcionUncheckedCreateNestedManyWithoutUsuarioInput;
    resenas?: ResenaUncheckedCreateNestedManyWithoutUsuarioInput;
    resenaRespuestas?: ResenaRespuestaUncheckedCreateNestedManyWithoutUsuarioInput;
    favoritos?: FavoritoUncheckedCreateNestedManyWithoutUsuarioInput;
    resenaLikes?: ResenaLikeUncheckedCreateNestedManyWithoutUsuarioInput;
    ordenes?: OrdenUncheckedCreateNestedManyWithoutUsuarioInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    carrito?: CarritoUncheckedCreateNestedOneWithoutUsuarioInput;
  };

  export type UsuarioCreateOrConnectWithoutNotificacionesInput = {
    where: UsuarioWhereUniqueInput;
    create: XOR<
      UsuarioCreateWithoutNotificacionesInput,
      UsuarioUncheckedCreateWithoutNotificacionesInput
    >;
  };

  export type UsuarioUpsertWithoutNotificacionesInput = {
    update: XOR<
      UsuarioUpdateWithoutNotificacionesInput,
      UsuarioUncheckedUpdateWithoutNotificacionesInput
    >;
    create: XOR<
      UsuarioCreateWithoutNotificacionesInput,
      UsuarioUncheckedCreateWithoutNotificacionesInput
    >;
    where?: UsuarioWhereInput;
  };

  export type UsuarioUpdateToOneWithWhereWithoutNotificacionesInput = {
    where?: UsuarioWhereInput;
    data: XOR<
      UsuarioUpdateWithoutNotificacionesInput,
      UsuarioUncheckedUpdateWithoutNotificacionesInput
    >;
  };

  export type UsuarioUpdateWithoutNotificacionesInput = {
    email?: StringFieldUpdateOperationsInput | string;
    nombre?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    emailVerificadoEn?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    roles?: UsuarioRolUpdateManyWithoutUsuarioNestedInput;
    cursosImpartidos?: CursoUpdateManyWithoutInstructorNestedInput;
    inscripciones?: InscripcionUpdateManyWithoutUsuarioNestedInput;
    resenas?: ResenaUpdateManyWithoutUsuarioNestedInput;
    resenaRespuestas?: ResenaRespuestaUpdateManyWithoutUsuarioNestedInput;
    favoritos?: FavoritoUpdateManyWithoutUsuarioNestedInput;
    resenaLikes?: ResenaLikeUpdateManyWithoutUsuarioNestedInput;
    ordenes?: OrdenUpdateManyWithoutUsuarioNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput;
    carrito?: CarritoUpdateOneWithoutUsuarioNestedInput;
  };

  export type UsuarioUncheckedUpdateWithoutNotificacionesInput = {
    id?: IntFieldUpdateOperationsInput | number;
    email?: StringFieldUpdateOperationsInput | string;
    nombre?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    emailVerificadoEn?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    roles?: UsuarioRolUncheckedUpdateManyWithoutUsuarioNestedInput;
    cursosImpartidos?: CursoUncheckedUpdateManyWithoutInstructorNestedInput;
    inscripciones?: InscripcionUncheckedUpdateManyWithoutUsuarioNestedInput;
    resenas?: ResenaUncheckedUpdateManyWithoutUsuarioNestedInput;
    resenaRespuestas?: ResenaRespuestaUncheckedUpdateManyWithoutUsuarioNestedInput;
    favoritos?: FavoritoUncheckedUpdateManyWithoutUsuarioNestedInput;
    resenaLikes?: ResenaLikeUncheckedUpdateManyWithoutUsuarioNestedInput;
    ordenes?: OrdenUncheckedUpdateManyWithoutUsuarioNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    carrito?: CarritoUncheckedUpdateOneWithoutUsuarioNestedInput;
  };

  export type UsuarioCreateWithoutAuditLogsInput = {
    email: string;
    nombre?: string | null;
    passwordHash: string;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
    emailVerificadoEn?: Date | string | null;
    roles?: UsuarioRolCreateNestedManyWithoutUsuarioInput;
    cursosImpartidos?: CursoCreateNestedManyWithoutInstructorInput;
    inscripciones?: InscripcionCreateNestedManyWithoutUsuarioInput;
    resenas?: ResenaCreateNestedManyWithoutUsuarioInput;
    resenaRespuestas?: ResenaRespuestaCreateNestedManyWithoutUsuarioInput;
    favoritos?: FavoritoCreateNestedManyWithoutUsuarioInput;
    resenaLikes?: ResenaLikeCreateNestedManyWithoutUsuarioInput;
    ordenes?: OrdenCreateNestedManyWithoutUsuarioInput;
    carrito?: CarritoCreateNestedOneWithoutUsuarioInput;
    notificaciones?: NotificacionCreateNestedManyWithoutUsuarioInput;
  };

  export type UsuarioUncheckedCreateWithoutAuditLogsInput = {
    id?: number;
    email: string;
    nombre?: string | null;
    passwordHash: string;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
    emailVerificadoEn?: Date | string | null;
    roles?: UsuarioRolUncheckedCreateNestedManyWithoutUsuarioInput;
    cursosImpartidos?: CursoUncheckedCreateNestedManyWithoutInstructorInput;
    inscripciones?: InscripcionUncheckedCreateNestedManyWithoutUsuarioInput;
    resenas?: ResenaUncheckedCreateNestedManyWithoutUsuarioInput;
    resenaRespuestas?: ResenaRespuestaUncheckedCreateNestedManyWithoutUsuarioInput;
    favoritos?: FavoritoUncheckedCreateNestedManyWithoutUsuarioInput;
    resenaLikes?: ResenaLikeUncheckedCreateNestedManyWithoutUsuarioInput;
    ordenes?: OrdenUncheckedCreateNestedManyWithoutUsuarioInput;
    carrito?: CarritoUncheckedCreateNestedOneWithoutUsuarioInput;
    notificaciones?: NotificacionUncheckedCreateNestedManyWithoutUsuarioInput;
  };

  export type UsuarioCreateOrConnectWithoutAuditLogsInput = {
    where: UsuarioWhereUniqueInput;
    create: XOR<
      UsuarioCreateWithoutAuditLogsInput,
      UsuarioUncheckedCreateWithoutAuditLogsInput
    >;
  };

  export type UsuarioUpsertWithoutAuditLogsInput = {
    update: XOR<
      UsuarioUpdateWithoutAuditLogsInput,
      UsuarioUncheckedUpdateWithoutAuditLogsInput
    >;
    create: XOR<
      UsuarioCreateWithoutAuditLogsInput,
      UsuarioUncheckedCreateWithoutAuditLogsInput
    >;
    where?: UsuarioWhereInput;
  };

  export type UsuarioUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UsuarioWhereInput;
    data: XOR<
      UsuarioUpdateWithoutAuditLogsInput,
      UsuarioUncheckedUpdateWithoutAuditLogsInput
    >;
  };

  export type UsuarioUpdateWithoutAuditLogsInput = {
    email?: StringFieldUpdateOperationsInput | string;
    nombre?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    emailVerificadoEn?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    roles?: UsuarioRolUpdateManyWithoutUsuarioNestedInput;
    cursosImpartidos?: CursoUpdateManyWithoutInstructorNestedInput;
    inscripciones?: InscripcionUpdateManyWithoutUsuarioNestedInput;
    resenas?: ResenaUpdateManyWithoutUsuarioNestedInput;
    resenaRespuestas?: ResenaRespuestaUpdateManyWithoutUsuarioNestedInput;
    favoritos?: FavoritoUpdateManyWithoutUsuarioNestedInput;
    resenaLikes?: ResenaLikeUpdateManyWithoutUsuarioNestedInput;
    ordenes?: OrdenUpdateManyWithoutUsuarioNestedInput;
    carrito?: CarritoUpdateOneWithoutUsuarioNestedInput;
    notificaciones?: NotificacionUpdateManyWithoutUsuarioNestedInput;
  };

  export type UsuarioUncheckedUpdateWithoutAuditLogsInput = {
    id?: IntFieldUpdateOperationsInput | number;
    email?: StringFieldUpdateOperationsInput | string;
    nombre?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    emailVerificadoEn?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    roles?: UsuarioRolUncheckedUpdateManyWithoutUsuarioNestedInput;
    cursosImpartidos?: CursoUncheckedUpdateManyWithoutInstructorNestedInput;
    inscripciones?: InscripcionUncheckedUpdateManyWithoutUsuarioNestedInput;
    resenas?: ResenaUncheckedUpdateManyWithoutUsuarioNestedInput;
    resenaRespuestas?: ResenaRespuestaUncheckedUpdateManyWithoutUsuarioNestedInput;
    favoritos?: FavoritoUncheckedUpdateManyWithoutUsuarioNestedInput;
    resenaLikes?: ResenaLikeUncheckedUpdateManyWithoutUsuarioNestedInput;
    ordenes?: OrdenUncheckedUpdateManyWithoutUsuarioNestedInput;
    carrito?: CarritoUncheckedUpdateOneWithoutUsuarioNestedInput;
    notificaciones?: NotificacionUncheckedUpdateManyWithoutUsuarioNestedInput;
  };

  export type UsuarioCreateWithoutCarritoInput = {
    email: string;
    nombre?: string | null;
    passwordHash: string;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
    emailVerificadoEn?: Date | string | null;
    roles?: UsuarioRolCreateNestedManyWithoutUsuarioInput;
    cursosImpartidos?: CursoCreateNestedManyWithoutInstructorInput;
    inscripciones?: InscripcionCreateNestedManyWithoutUsuarioInput;
    resenas?: ResenaCreateNestedManyWithoutUsuarioInput;
    resenaRespuestas?: ResenaRespuestaCreateNestedManyWithoutUsuarioInput;
    favoritos?: FavoritoCreateNestedManyWithoutUsuarioInput;
    resenaLikes?: ResenaLikeCreateNestedManyWithoutUsuarioInput;
    ordenes?: OrdenCreateNestedManyWithoutUsuarioInput;
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput;
    notificaciones?: NotificacionCreateNestedManyWithoutUsuarioInput;
  };

  export type UsuarioUncheckedCreateWithoutCarritoInput = {
    id?: number;
    email: string;
    nombre?: string | null;
    passwordHash: string;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
    emailVerificadoEn?: Date | string | null;
    roles?: UsuarioRolUncheckedCreateNestedManyWithoutUsuarioInput;
    cursosImpartidos?: CursoUncheckedCreateNestedManyWithoutInstructorInput;
    inscripciones?: InscripcionUncheckedCreateNestedManyWithoutUsuarioInput;
    resenas?: ResenaUncheckedCreateNestedManyWithoutUsuarioInput;
    resenaRespuestas?: ResenaRespuestaUncheckedCreateNestedManyWithoutUsuarioInput;
    favoritos?: FavoritoUncheckedCreateNestedManyWithoutUsuarioInput;
    resenaLikes?: ResenaLikeUncheckedCreateNestedManyWithoutUsuarioInput;
    ordenes?: OrdenUncheckedCreateNestedManyWithoutUsuarioInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    notificaciones?: NotificacionUncheckedCreateNestedManyWithoutUsuarioInput;
  };

  export type UsuarioCreateOrConnectWithoutCarritoInput = {
    where: UsuarioWhereUniqueInput;
    create: XOR<
      UsuarioCreateWithoutCarritoInput,
      UsuarioUncheckedCreateWithoutCarritoInput
    >;
  };

  export type ItemCarritoCreateWithoutCarritoInput = {
    tipo: $Enums.TipoItemOrden;
    cantidad?: number;
    creadoEn?: Date | string;
    producto?: ProductoCreateNestedOneWithoutItemsCarritoInput;
    curso?: CursoCreateNestedOneWithoutItemsCarritoInput;
  };

  export type ItemCarritoUncheckedCreateWithoutCarritoInput = {
    id?: number;
    tipo: $Enums.TipoItemOrden;
    productoId?: number | null;
    cursoId?: number | null;
    cantidad?: number;
    creadoEn?: Date | string;
  };

  export type ItemCarritoCreateOrConnectWithoutCarritoInput = {
    where: ItemCarritoWhereUniqueInput;
    create: XOR<
      ItemCarritoCreateWithoutCarritoInput,
      ItemCarritoUncheckedCreateWithoutCarritoInput
    >;
  };

  export type ItemCarritoCreateManyCarritoInputEnvelope = {
    data:
      | ItemCarritoCreateManyCarritoInput
      | ItemCarritoCreateManyCarritoInput[];
    skipDuplicates?: boolean;
  };

  export type UsuarioUpsertWithoutCarritoInput = {
    update: XOR<
      UsuarioUpdateWithoutCarritoInput,
      UsuarioUncheckedUpdateWithoutCarritoInput
    >;
    create: XOR<
      UsuarioCreateWithoutCarritoInput,
      UsuarioUncheckedCreateWithoutCarritoInput
    >;
    where?: UsuarioWhereInput;
  };

  export type UsuarioUpdateToOneWithWhereWithoutCarritoInput = {
    where?: UsuarioWhereInput;
    data: XOR<
      UsuarioUpdateWithoutCarritoInput,
      UsuarioUncheckedUpdateWithoutCarritoInput
    >;
  };

  export type UsuarioUpdateWithoutCarritoInput = {
    email?: StringFieldUpdateOperationsInput | string;
    nombre?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    emailVerificadoEn?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    roles?: UsuarioRolUpdateManyWithoutUsuarioNestedInput;
    cursosImpartidos?: CursoUpdateManyWithoutInstructorNestedInput;
    inscripciones?: InscripcionUpdateManyWithoutUsuarioNestedInput;
    resenas?: ResenaUpdateManyWithoutUsuarioNestedInput;
    resenaRespuestas?: ResenaRespuestaUpdateManyWithoutUsuarioNestedInput;
    favoritos?: FavoritoUpdateManyWithoutUsuarioNestedInput;
    resenaLikes?: ResenaLikeUpdateManyWithoutUsuarioNestedInput;
    ordenes?: OrdenUpdateManyWithoutUsuarioNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput;
    notificaciones?: NotificacionUpdateManyWithoutUsuarioNestedInput;
  };

  export type UsuarioUncheckedUpdateWithoutCarritoInput = {
    id?: IntFieldUpdateOperationsInput | number;
    email?: StringFieldUpdateOperationsInput | string;
    nombre?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    emailVerificadoEn?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    roles?: UsuarioRolUncheckedUpdateManyWithoutUsuarioNestedInput;
    cursosImpartidos?: CursoUncheckedUpdateManyWithoutInstructorNestedInput;
    inscripciones?: InscripcionUncheckedUpdateManyWithoutUsuarioNestedInput;
    resenas?: ResenaUncheckedUpdateManyWithoutUsuarioNestedInput;
    resenaRespuestas?: ResenaRespuestaUncheckedUpdateManyWithoutUsuarioNestedInput;
    favoritos?: FavoritoUncheckedUpdateManyWithoutUsuarioNestedInput;
    resenaLikes?: ResenaLikeUncheckedUpdateManyWithoutUsuarioNestedInput;
    ordenes?: OrdenUncheckedUpdateManyWithoutUsuarioNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    notificaciones?: NotificacionUncheckedUpdateManyWithoutUsuarioNestedInput;
  };

  export type ItemCarritoUpsertWithWhereUniqueWithoutCarritoInput = {
    where: ItemCarritoWhereUniqueInput;
    update: XOR<
      ItemCarritoUpdateWithoutCarritoInput,
      ItemCarritoUncheckedUpdateWithoutCarritoInput
    >;
    create: XOR<
      ItemCarritoCreateWithoutCarritoInput,
      ItemCarritoUncheckedCreateWithoutCarritoInput
    >;
  };

  export type ItemCarritoUpdateWithWhereUniqueWithoutCarritoInput = {
    where: ItemCarritoWhereUniqueInput;
    data: XOR<
      ItemCarritoUpdateWithoutCarritoInput,
      ItemCarritoUncheckedUpdateWithoutCarritoInput
    >;
  };

  export type ItemCarritoUpdateManyWithWhereWithoutCarritoInput = {
    where: ItemCarritoScalarWhereInput;
    data: XOR<
      ItemCarritoUpdateManyMutationInput,
      ItemCarritoUncheckedUpdateManyWithoutCarritoInput
    >;
  };

  export type CarritoCreateWithoutItemsInput = {
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
    usuario: UsuarioCreateNestedOneWithoutCarritoInput;
  };

  export type CarritoUncheckedCreateWithoutItemsInput = {
    id?: number;
    usuarioId: number;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
  };

  export type CarritoCreateOrConnectWithoutItemsInput = {
    where: CarritoWhereUniqueInput;
    create: XOR<
      CarritoCreateWithoutItemsInput,
      CarritoUncheckedCreateWithoutItemsInput
    >;
  };

  export type ProductoCreateWithoutItemsCarritoInput = {
    slug: string;
    titulo: string;
    precio: number;
    stock?: number;
    publicado?: boolean;
    destacado?: boolean;
    imagen?: string | null;
    descripcionMD?: string | null;
    precioLista?: number | null;
    ratingProm?: Decimal | DecimalJsLike | number | string | null;
    ratingConteo?: number;
    creadoEn?: Date | string;
    marca?: MarcaCreateNestedOneWithoutProductosInput;
    categoria?: CategoriaCreateNestedOneWithoutProductosInput;
    imagenes?: ProductoImagenCreateNestedManyWithoutProductoInput;
    resenas?: ResenaCreateNestedManyWithoutProductoInput;
    favoritos?: FavoritoCreateNestedManyWithoutProductoInput;
  };

  export type ProductoUncheckedCreateWithoutItemsCarritoInput = {
    id?: number;
    slug: string;
    titulo: string;
    precio: number;
    stock?: number;
    publicado?: boolean;
    destacado?: boolean;
    imagen?: string | null;
    descripcionMD?: string | null;
    precioLista?: number | null;
    ratingProm?: Decimal | DecimalJsLike | number | string | null;
    ratingConteo?: number;
    creadoEn?: Date | string;
    marcaId?: number | null;
    categoriaId?: number | null;
    imagenes?: ProductoImagenUncheckedCreateNestedManyWithoutProductoInput;
    resenas?: ResenaUncheckedCreateNestedManyWithoutProductoInput;
    favoritos?: FavoritoUncheckedCreateNestedManyWithoutProductoInput;
  };

  export type ProductoCreateOrConnectWithoutItemsCarritoInput = {
    where: ProductoWhereUniqueInput;
    create: XOR<
      ProductoCreateWithoutItemsCarritoInput,
      ProductoUncheckedCreateWithoutItemsCarritoInput
    >;
  };

  export type CursoCreateWithoutItemsCarritoInput = {
    slug: string;
    titulo: string;
    resumen?: string | null;
    descripcionMD?: string | null;
    requisitos?: string | null;
    precio: number;
    publicado?: boolean;
    nivel?: $Enums.NivelCurso;
    portada?: string | null;
    destacado?: boolean;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    ratingProm?: Decimal | DecimalJsLike | number | string | null;
    ratingConteo?: number;
    creadoEn?: Date | string;
    instructor?: UsuarioCreateNestedOneWithoutCursosImpartidosInput;
    modulos?: ModuloCreateNestedManyWithoutCursoInput;
    resenas?: ResenaCreateNestedManyWithoutCursoInput;
    inscripciones?: InscripcionCreateNestedManyWithoutCursoInput;
  };

  export type CursoUncheckedCreateWithoutItemsCarritoInput = {
    id?: number;
    slug: string;
    titulo: string;
    resumen?: string | null;
    descripcionMD?: string | null;
    requisitos?: string | null;
    precio: number;
    publicado?: boolean;
    nivel?: $Enums.NivelCurso;
    portada?: string | null;
    destacado?: boolean;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    ratingProm?: Decimal | DecimalJsLike | number | string | null;
    ratingConteo?: number;
    creadoEn?: Date | string;
    instructorId?: number | null;
    modulos?: ModuloUncheckedCreateNestedManyWithoutCursoInput;
    resenas?: ResenaUncheckedCreateNestedManyWithoutCursoInput;
    inscripciones?: InscripcionUncheckedCreateNestedManyWithoutCursoInput;
  };

  export type CursoCreateOrConnectWithoutItemsCarritoInput = {
    where: CursoWhereUniqueInput;
    create: XOR<
      CursoCreateWithoutItemsCarritoInput,
      CursoUncheckedCreateWithoutItemsCarritoInput
    >;
  };

  export type CarritoUpsertWithoutItemsInput = {
    update: XOR<
      CarritoUpdateWithoutItemsInput,
      CarritoUncheckedUpdateWithoutItemsInput
    >;
    create: XOR<
      CarritoCreateWithoutItemsInput,
      CarritoUncheckedCreateWithoutItemsInput
    >;
    where?: CarritoWhereInput;
  };

  export type CarritoUpdateToOneWithWhereWithoutItemsInput = {
    where?: CarritoWhereInput;
    data: XOR<
      CarritoUpdateWithoutItemsInput,
      CarritoUncheckedUpdateWithoutItemsInput
    >;
  };

  export type CarritoUpdateWithoutItemsInput = {
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    usuario?: UsuarioUpdateOneRequiredWithoutCarritoNestedInput;
  };

  export type CarritoUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number;
    usuarioId?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ProductoUpsertWithoutItemsCarritoInput = {
    update: XOR<
      ProductoUpdateWithoutItemsCarritoInput,
      ProductoUncheckedUpdateWithoutItemsCarritoInput
    >;
    create: XOR<
      ProductoCreateWithoutItemsCarritoInput,
      ProductoUncheckedCreateWithoutItemsCarritoInput
    >;
    where?: ProductoWhereInput;
  };

  export type ProductoUpdateToOneWithWhereWithoutItemsCarritoInput = {
    where?: ProductoWhereInput;
    data: XOR<
      ProductoUpdateWithoutItemsCarritoInput,
      ProductoUncheckedUpdateWithoutItemsCarritoInput
    >;
  };

  export type ProductoUpdateWithoutItemsCarritoInput = {
    slug?: StringFieldUpdateOperationsInput | string;
    titulo?: StringFieldUpdateOperationsInput | string;
    precio?: IntFieldUpdateOperationsInput | number;
    stock?: IntFieldUpdateOperationsInput | number;
    publicado?: BoolFieldUpdateOperationsInput | boolean;
    destacado?: BoolFieldUpdateOperationsInput | boolean;
    imagen?: NullableStringFieldUpdateOperationsInput | string | null;
    descripcionMD?: NullableStringFieldUpdateOperationsInput | string | null;
    precioLista?: NullableIntFieldUpdateOperationsInput | number | null;
    ratingProm?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    ratingConteo?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    marca?: MarcaUpdateOneWithoutProductosNestedInput;
    categoria?: CategoriaUpdateOneWithoutProductosNestedInput;
    imagenes?: ProductoImagenUpdateManyWithoutProductoNestedInput;
    resenas?: ResenaUpdateManyWithoutProductoNestedInput;
    favoritos?: FavoritoUpdateManyWithoutProductoNestedInput;
  };

  export type ProductoUncheckedUpdateWithoutItemsCarritoInput = {
    id?: IntFieldUpdateOperationsInput | number;
    slug?: StringFieldUpdateOperationsInput | string;
    titulo?: StringFieldUpdateOperationsInput | string;
    precio?: IntFieldUpdateOperationsInput | number;
    stock?: IntFieldUpdateOperationsInput | number;
    publicado?: BoolFieldUpdateOperationsInput | boolean;
    destacado?: BoolFieldUpdateOperationsInput | boolean;
    imagen?: NullableStringFieldUpdateOperationsInput | string | null;
    descripcionMD?: NullableStringFieldUpdateOperationsInput | string | null;
    precioLista?: NullableIntFieldUpdateOperationsInput | number | null;
    ratingProm?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    ratingConteo?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    marcaId?: NullableIntFieldUpdateOperationsInput | number | null;
    categoriaId?: NullableIntFieldUpdateOperationsInput | number | null;
    imagenes?: ProductoImagenUncheckedUpdateManyWithoutProductoNestedInput;
    resenas?: ResenaUncheckedUpdateManyWithoutProductoNestedInput;
    favoritos?: FavoritoUncheckedUpdateManyWithoutProductoNestedInput;
  };

  export type CursoUpsertWithoutItemsCarritoInput = {
    update: XOR<
      CursoUpdateWithoutItemsCarritoInput,
      CursoUncheckedUpdateWithoutItemsCarritoInput
    >;
    create: XOR<
      CursoCreateWithoutItemsCarritoInput,
      CursoUncheckedCreateWithoutItemsCarritoInput
    >;
    where?: CursoWhereInput;
  };

  export type CursoUpdateToOneWithWhereWithoutItemsCarritoInput = {
    where?: CursoWhereInput;
    data: XOR<
      CursoUpdateWithoutItemsCarritoInput,
      CursoUncheckedUpdateWithoutItemsCarritoInput
    >;
  };

  export type CursoUpdateWithoutItemsCarritoInput = {
    slug?: StringFieldUpdateOperationsInput | string;
    titulo?: StringFieldUpdateOperationsInput | string;
    resumen?: NullableStringFieldUpdateOperationsInput | string | null;
    descripcionMD?: NullableStringFieldUpdateOperationsInput | string | null;
    requisitos?: NullableStringFieldUpdateOperationsInput | string | null;
    precio?: IntFieldUpdateOperationsInput | number;
    publicado?: BoolFieldUpdateOperationsInput | boolean;
    nivel?: EnumNivelCursoFieldUpdateOperationsInput | $Enums.NivelCurso;
    portada?: NullableStringFieldUpdateOperationsInput | string | null;
    destacado?: BoolFieldUpdateOperationsInput | boolean;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    ratingProm?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    ratingConteo?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    instructor?: UsuarioUpdateOneWithoutCursosImpartidosNestedInput;
    modulos?: ModuloUpdateManyWithoutCursoNestedInput;
    resenas?: ResenaUpdateManyWithoutCursoNestedInput;
    inscripciones?: InscripcionUpdateManyWithoutCursoNestedInput;
  };

  export type CursoUncheckedUpdateWithoutItemsCarritoInput = {
    id?: IntFieldUpdateOperationsInput | number;
    slug?: StringFieldUpdateOperationsInput | string;
    titulo?: StringFieldUpdateOperationsInput | string;
    resumen?: NullableStringFieldUpdateOperationsInput | string | null;
    descripcionMD?: NullableStringFieldUpdateOperationsInput | string | null;
    requisitos?: NullableStringFieldUpdateOperationsInput | string | null;
    precio?: IntFieldUpdateOperationsInput | number;
    publicado?: BoolFieldUpdateOperationsInput | boolean;
    nivel?: EnumNivelCursoFieldUpdateOperationsInput | $Enums.NivelCurso;
    portada?: NullableStringFieldUpdateOperationsInput | string | null;
    destacado?: BoolFieldUpdateOperationsInput | boolean;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    ratingProm?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    ratingConteo?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    instructorId?: NullableIntFieldUpdateOperationsInput | number | null;
    modulos?: ModuloUncheckedUpdateManyWithoutCursoNestedInput;
    resenas?: ResenaUncheckedUpdateManyWithoutCursoNestedInput;
    inscripciones?: InscripcionUncheckedUpdateManyWithoutCursoNestedInput;
  };

  export type UsuarioRolCreateManyUsuarioInput = {
    roleId: number;
  };

  export type CursoCreateManyInstructorInput = {
    id?: number;
    slug: string;
    titulo: string;
    resumen?: string | null;
    descripcionMD?: string | null;
    requisitos?: string | null;
    precio: number;
    publicado?: boolean;
    nivel?: $Enums.NivelCurso;
    portada?: string | null;
    destacado?: boolean;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    ratingProm?: Decimal | DecimalJsLike | number | string | null;
    ratingConteo?: number;
    creadoEn?: Date | string;
  };

  export type InscripcionCreateManyUsuarioInput = {
    id?: number;
    cursoId: number;
    estado?: $Enums.EstadoInscripcion;
    progreso: JsonNullValueInput | InputJsonValue;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
  };

  export type ResenaCreateManyUsuarioInput = {
    id?: number;
    cursoId?: number | null;
    productoId?: number | null;
    puntaje: number;
    comentario?: string | null;
    creadoEn?: Date | string;
  };

  export type ResenaRespuestaCreateManyUsuarioInput = {
    id?: number;
    resenaId: number;
    parentId?: number | null;
    contenido: string;
    eliminado?: boolean;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
  };

  export type FavoritoCreateManyUsuarioInput = {
    id?: number;
    productoId: number;
    creadoEn?: Date | string;
  };

  export type ResenaLikeCreateManyUsuarioInput = {
    id?: number;
    resenaId: number;
    tipo: $Enums.TipoLike;
    creadoEn?: Date | string;
  };

  export type OrdenCreateManyUsuarioInput = {
    id?: number;
    estado?: $Enums.EstadoOrden;
    total: number;
    moneda?: string;
    referenciaPago?: string | null;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
    esSuscripcion?: boolean;
    suscripcionActiva?: boolean | null;
    suscripcionId?: string | null;
    suscripcionFrecuencia?: number | null;
    suscripcionTipoFrecuencia?: string | null;
    metadatos?: NullableJsonNullValueInput | InputJsonValue;
    direccionEnvioId?: number | null;
    direccionFacturacionId?: number | null;
  };

  export type AuditLogCreateManyUserInput = {
    id?: number;
    tableName: string;
    recordId: string;
    action: string;
    oldData?: NullableJsonNullValueInput | InputJsonValue;
    newData?: NullableJsonNullValueInput | InputJsonValue;
    userAgent?: string | null;
    ipAddress?: string | null;
    endpoint?: string | null;
    timestamp?: Date | string;
  };

  export type NotificacionCreateManyUsuarioInput = {
    id?: number;
    tipo: $Enums.TipoNotificacion;
    titulo: string;
    mensaje: string;
    leida?: boolean;
    url?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    creadoEn?: Date | string;
  };

  export type UsuarioRolUpdateWithoutUsuarioInput = {
    role?: RoleUpdateOneRequiredWithoutUsuariosNestedInput;
  };

  export type UsuarioRolUncheckedUpdateWithoutUsuarioInput = {
    roleId?: IntFieldUpdateOperationsInput | number;
  };

  export type UsuarioRolUncheckedUpdateManyWithoutUsuarioInput = {
    roleId?: IntFieldUpdateOperationsInput | number;
  };

  export type CursoUpdateWithoutInstructorInput = {
    slug?: StringFieldUpdateOperationsInput | string;
    titulo?: StringFieldUpdateOperationsInput | string;
    resumen?: NullableStringFieldUpdateOperationsInput | string | null;
    descripcionMD?: NullableStringFieldUpdateOperationsInput | string | null;
    requisitos?: NullableStringFieldUpdateOperationsInput | string | null;
    precio?: IntFieldUpdateOperationsInput | number;
    publicado?: BoolFieldUpdateOperationsInput | boolean;
    nivel?: EnumNivelCursoFieldUpdateOperationsInput | $Enums.NivelCurso;
    portada?: NullableStringFieldUpdateOperationsInput | string | null;
    destacado?: BoolFieldUpdateOperationsInput | boolean;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    ratingProm?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    ratingConteo?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    modulos?: ModuloUpdateManyWithoutCursoNestedInput;
    resenas?: ResenaUpdateManyWithoutCursoNestedInput;
    inscripciones?: InscripcionUpdateManyWithoutCursoNestedInput;
    itemsCarrito?: ItemCarritoUpdateManyWithoutCursoNestedInput;
  };

  export type CursoUncheckedUpdateWithoutInstructorInput = {
    id?: IntFieldUpdateOperationsInput | number;
    slug?: StringFieldUpdateOperationsInput | string;
    titulo?: StringFieldUpdateOperationsInput | string;
    resumen?: NullableStringFieldUpdateOperationsInput | string | null;
    descripcionMD?: NullableStringFieldUpdateOperationsInput | string | null;
    requisitos?: NullableStringFieldUpdateOperationsInput | string | null;
    precio?: IntFieldUpdateOperationsInput | number;
    publicado?: BoolFieldUpdateOperationsInput | boolean;
    nivel?: EnumNivelCursoFieldUpdateOperationsInput | $Enums.NivelCurso;
    portada?: NullableStringFieldUpdateOperationsInput | string | null;
    destacado?: BoolFieldUpdateOperationsInput | boolean;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    ratingProm?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    ratingConteo?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    modulos?: ModuloUncheckedUpdateManyWithoutCursoNestedInput;
    resenas?: ResenaUncheckedUpdateManyWithoutCursoNestedInput;
    inscripciones?: InscripcionUncheckedUpdateManyWithoutCursoNestedInput;
    itemsCarrito?: ItemCarritoUncheckedUpdateManyWithoutCursoNestedInput;
  };

  export type CursoUncheckedUpdateManyWithoutInstructorInput = {
    id?: IntFieldUpdateOperationsInput | number;
    slug?: StringFieldUpdateOperationsInput | string;
    titulo?: StringFieldUpdateOperationsInput | string;
    resumen?: NullableStringFieldUpdateOperationsInput | string | null;
    descripcionMD?: NullableStringFieldUpdateOperationsInput | string | null;
    requisitos?: NullableStringFieldUpdateOperationsInput | string | null;
    precio?: IntFieldUpdateOperationsInput | number;
    publicado?: BoolFieldUpdateOperationsInput | boolean;
    nivel?: EnumNivelCursoFieldUpdateOperationsInput | $Enums.NivelCurso;
    portada?: NullableStringFieldUpdateOperationsInput | string | null;
    destacado?: BoolFieldUpdateOperationsInput | boolean;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    ratingProm?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    ratingConteo?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type InscripcionUpdateWithoutUsuarioInput = {
    estado?:
      | EnumEstadoInscripcionFieldUpdateOperationsInput
      | $Enums.EstadoInscripcion;
    progreso?: JsonNullValueInput | InputJsonValue;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    curso?: CursoUpdateOneRequiredWithoutInscripcionesNestedInput;
  };

  export type InscripcionUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number;
    cursoId?: IntFieldUpdateOperationsInput | number;
    estado?:
      | EnumEstadoInscripcionFieldUpdateOperationsInput
      | $Enums.EstadoInscripcion;
    progreso?: JsonNullValueInput | InputJsonValue;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type InscripcionUncheckedUpdateManyWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number;
    cursoId?: IntFieldUpdateOperationsInput | number;
    estado?:
      | EnumEstadoInscripcionFieldUpdateOperationsInput
      | $Enums.EstadoInscripcion;
    progreso?: JsonNullValueInput | InputJsonValue;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ResenaUpdateWithoutUsuarioInput = {
    puntaje?: IntFieldUpdateOperationsInput | number;
    comentario?: NullableStringFieldUpdateOperationsInput | string | null;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    curso?: CursoUpdateOneWithoutResenasNestedInput;
    producto?: ProductoUpdateOneWithoutResenasNestedInput;
    respuestas?: ResenaRespuestaUpdateManyWithoutResenaNestedInput;
    likes?: ResenaLikeUpdateManyWithoutResenaNestedInput;
  };

  export type ResenaUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number;
    cursoId?: NullableIntFieldUpdateOperationsInput | number | null;
    productoId?: NullableIntFieldUpdateOperationsInput | number | null;
    puntaje?: IntFieldUpdateOperationsInput | number;
    comentario?: NullableStringFieldUpdateOperationsInput | string | null;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    respuestas?: ResenaRespuestaUncheckedUpdateManyWithoutResenaNestedInput;
    likes?: ResenaLikeUncheckedUpdateManyWithoutResenaNestedInput;
  };

  export type ResenaUncheckedUpdateManyWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number;
    cursoId?: NullableIntFieldUpdateOperationsInput | number | null;
    productoId?: NullableIntFieldUpdateOperationsInput | number | null;
    puntaje?: IntFieldUpdateOperationsInput | number;
    comentario?: NullableStringFieldUpdateOperationsInput | string | null;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ResenaRespuestaUpdateWithoutUsuarioInput = {
    contenido?: StringFieldUpdateOperationsInput | string;
    eliminado?: BoolFieldUpdateOperationsInput | boolean;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    resena?: ResenaUpdateOneRequiredWithoutRespuestasNestedInput;
    parent?: ResenaRespuestaUpdateOneWithoutHijosNestedInput;
    hijos?: ResenaRespuestaUpdateManyWithoutParentNestedInput;
  };

  export type ResenaRespuestaUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number;
    resenaId?: IntFieldUpdateOperationsInput | number;
    parentId?: NullableIntFieldUpdateOperationsInput | number | null;
    contenido?: StringFieldUpdateOperationsInput | string;
    eliminado?: BoolFieldUpdateOperationsInput | boolean;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    hijos?: ResenaRespuestaUncheckedUpdateManyWithoutParentNestedInput;
  };

  export type ResenaRespuestaUncheckedUpdateManyWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number;
    resenaId?: IntFieldUpdateOperationsInput | number;
    parentId?: NullableIntFieldUpdateOperationsInput | number | null;
    contenido?: StringFieldUpdateOperationsInput | string;
    eliminado?: BoolFieldUpdateOperationsInput | boolean;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FavoritoUpdateWithoutUsuarioInput = {
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    producto?: ProductoUpdateOneRequiredWithoutFavoritosNestedInput;
  };

  export type FavoritoUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number;
    productoId?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FavoritoUncheckedUpdateManyWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number;
    productoId?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ResenaLikeUpdateWithoutUsuarioInput = {
    tipo?: EnumTipoLikeFieldUpdateOperationsInput | $Enums.TipoLike;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    resena?: ResenaUpdateOneRequiredWithoutLikesNestedInput;
  };

  export type ResenaLikeUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number;
    resenaId?: IntFieldUpdateOperationsInput | number;
    tipo?: EnumTipoLikeFieldUpdateOperationsInput | $Enums.TipoLike;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ResenaLikeUncheckedUpdateManyWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number;
    resenaId?: IntFieldUpdateOperationsInput | number;
    tipo?: EnumTipoLikeFieldUpdateOperationsInput | $Enums.TipoLike;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type OrdenUpdateWithoutUsuarioInput = {
    estado?: EnumEstadoOrdenFieldUpdateOperationsInput | $Enums.EstadoOrden;
    total?: IntFieldUpdateOperationsInput | number;
    moneda?: StringFieldUpdateOperationsInput | string;
    referenciaPago?: NullableStringFieldUpdateOperationsInput | string | null;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    esSuscripcion?: BoolFieldUpdateOperationsInput | boolean;
    suscripcionActiva?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    suscripcionId?: NullableStringFieldUpdateOperationsInput | string | null;
    suscripcionFrecuencia?:
      | NullableIntFieldUpdateOperationsInput
      | number
      | null;
    suscripcionTipoFrecuencia?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    metadatos?: NullableJsonNullValueInput | InputJsonValue;
    direccionEnvio?: DireccionUpdateOneWithoutOrdenesEnvioNestedInput;
    direccionFacturacion?: DireccionUpdateOneWithoutOrdenesFacturacionNestedInput;
    items?: ItemOrdenUpdateManyWithoutOrdenNestedInput;
  };

  export type OrdenUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number;
    estado?: EnumEstadoOrdenFieldUpdateOperationsInput | $Enums.EstadoOrden;
    total?: IntFieldUpdateOperationsInput | number;
    moneda?: StringFieldUpdateOperationsInput | string;
    referenciaPago?: NullableStringFieldUpdateOperationsInput | string | null;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    esSuscripcion?: BoolFieldUpdateOperationsInput | boolean;
    suscripcionActiva?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    suscripcionId?: NullableStringFieldUpdateOperationsInput | string | null;
    suscripcionFrecuencia?:
      | NullableIntFieldUpdateOperationsInput
      | number
      | null;
    suscripcionTipoFrecuencia?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    metadatos?: NullableJsonNullValueInput | InputJsonValue;
    direccionEnvioId?: NullableIntFieldUpdateOperationsInput | number | null;
    direccionFacturacionId?:
      | NullableIntFieldUpdateOperationsInput
      | number
      | null;
    items?: ItemOrdenUncheckedUpdateManyWithoutOrdenNestedInput;
  };

  export type OrdenUncheckedUpdateManyWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number;
    estado?: EnumEstadoOrdenFieldUpdateOperationsInput | $Enums.EstadoOrden;
    total?: IntFieldUpdateOperationsInput | number;
    moneda?: StringFieldUpdateOperationsInput | string;
    referenciaPago?: NullableStringFieldUpdateOperationsInput | string | null;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    esSuscripcion?: BoolFieldUpdateOperationsInput | boolean;
    suscripcionActiva?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    suscripcionId?: NullableStringFieldUpdateOperationsInput | string | null;
    suscripcionFrecuencia?:
      | NullableIntFieldUpdateOperationsInput
      | number
      | null;
    suscripcionTipoFrecuencia?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    metadatos?: NullableJsonNullValueInput | InputJsonValue;
    direccionEnvioId?: NullableIntFieldUpdateOperationsInput | number | null;
    direccionFacturacionId?:
      | NullableIntFieldUpdateOperationsInput
      | number
      | null;
  };

  export type AuditLogUpdateWithoutUserInput = {
    tableName?: StringFieldUpdateOperationsInput | string;
    recordId?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    oldData?: NullableJsonNullValueInput | InputJsonValue;
    newData?: NullableJsonNullValueInput | InputJsonValue;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number;
    tableName?: StringFieldUpdateOperationsInput | string;
    recordId?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    oldData?: NullableJsonNullValueInput | InputJsonValue;
    newData?: NullableJsonNullValueInput | InputJsonValue;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number;
    tableName?: StringFieldUpdateOperationsInput | string;
    recordId?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    oldData?: NullableJsonNullValueInput | InputJsonValue;
    newData?: NullableJsonNullValueInput | InputJsonValue;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificacionUpdateWithoutUsuarioInput = {
    tipo?:
      | EnumTipoNotificacionFieldUpdateOperationsInput
      | $Enums.TipoNotificacion;
    titulo?: StringFieldUpdateOperationsInput | string;
    mensaje?: StringFieldUpdateOperationsInput | string;
    leida?: BoolFieldUpdateOperationsInput | boolean;
    url?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificacionUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number;
    tipo?:
      | EnumTipoNotificacionFieldUpdateOperationsInput
      | $Enums.TipoNotificacion;
    titulo?: StringFieldUpdateOperationsInput | string;
    mensaje?: StringFieldUpdateOperationsInput | string;
    leida?: BoolFieldUpdateOperationsInput | boolean;
    url?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificacionUncheckedUpdateManyWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number;
    tipo?:
      | EnumTipoNotificacionFieldUpdateOperationsInput
      | $Enums.TipoNotificacion;
    titulo?: StringFieldUpdateOperationsInput | string;
    mensaje?: StringFieldUpdateOperationsInput | string;
    leida?: BoolFieldUpdateOperationsInput | boolean;
    url?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UsuarioRolCreateManyRoleInput = {
    usuarioId: number;
  };

  export type UsuarioRolUpdateWithoutRoleInput = {
    usuario?: UsuarioUpdateOneRequiredWithoutRolesNestedInput;
  };

  export type UsuarioRolUncheckedUpdateWithoutRoleInput = {
    usuarioId?: IntFieldUpdateOperationsInput | number;
  };

  export type UsuarioRolUncheckedUpdateManyWithoutRoleInput = {
    usuarioId?: IntFieldUpdateOperationsInput | number;
  };

  export type ModuloCreateManyCursoInput = {
    id?: number;
    titulo: string;
    orden: number;
    parentId?: number | null;
  };

  export type ResenaCreateManyCursoInput = {
    id?: number;
    productoId?: number | null;
    usuarioId: number;
    puntaje: number;
    comentario?: string | null;
    creadoEn?: Date | string;
  };

  export type InscripcionCreateManyCursoInput = {
    id?: number;
    usuarioId: number;
    estado?: $Enums.EstadoInscripcion;
    progreso: JsonNullValueInput | InputJsonValue;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
  };

  export type ItemCarritoCreateManyCursoInput = {
    id?: number;
    carritoId: number;
    tipo: $Enums.TipoItemOrden;
    productoId?: number | null;
    cantidad?: number;
    creadoEn?: Date | string;
  };

  export type ModuloUpdateWithoutCursoInput = {
    titulo?: StringFieldUpdateOperationsInput | string;
    orden?: IntFieldUpdateOperationsInput | number;
    parentId?: NullableIntFieldUpdateOperationsInput | number | null;
    lecciones?: LeccionUpdateManyWithoutModuloNestedInput;
  };

  export type ModuloUncheckedUpdateWithoutCursoInput = {
    id?: IntFieldUpdateOperationsInput | number;
    titulo?: StringFieldUpdateOperationsInput | string;
    orden?: IntFieldUpdateOperationsInput | number;
    parentId?: NullableIntFieldUpdateOperationsInput | number | null;
    lecciones?: LeccionUncheckedUpdateManyWithoutModuloNestedInput;
  };

  export type ModuloUncheckedUpdateManyWithoutCursoInput = {
    id?: IntFieldUpdateOperationsInput | number;
    titulo?: StringFieldUpdateOperationsInput | string;
    orden?: IntFieldUpdateOperationsInput | number;
    parentId?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type ResenaUpdateWithoutCursoInput = {
    puntaje?: IntFieldUpdateOperationsInput | number;
    comentario?: NullableStringFieldUpdateOperationsInput | string | null;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    producto?: ProductoUpdateOneWithoutResenasNestedInput;
    usuario?: UsuarioUpdateOneRequiredWithoutResenasNestedInput;
    respuestas?: ResenaRespuestaUpdateManyWithoutResenaNestedInput;
    likes?: ResenaLikeUpdateManyWithoutResenaNestedInput;
  };

  export type ResenaUncheckedUpdateWithoutCursoInput = {
    id?: IntFieldUpdateOperationsInput | number;
    productoId?: NullableIntFieldUpdateOperationsInput | number | null;
    usuarioId?: IntFieldUpdateOperationsInput | number;
    puntaje?: IntFieldUpdateOperationsInput | number;
    comentario?: NullableStringFieldUpdateOperationsInput | string | null;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    respuestas?: ResenaRespuestaUncheckedUpdateManyWithoutResenaNestedInput;
    likes?: ResenaLikeUncheckedUpdateManyWithoutResenaNestedInput;
  };

  export type ResenaUncheckedUpdateManyWithoutCursoInput = {
    id?: IntFieldUpdateOperationsInput | number;
    productoId?: NullableIntFieldUpdateOperationsInput | number | null;
    usuarioId?: IntFieldUpdateOperationsInput | number;
    puntaje?: IntFieldUpdateOperationsInput | number;
    comentario?: NullableStringFieldUpdateOperationsInput | string | null;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type InscripcionUpdateWithoutCursoInput = {
    estado?:
      | EnumEstadoInscripcionFieldUpdateOperationsInput
      | $Enums.EstadoInscripcion;
    progreso?: JsonNullValueInput | InputJsonValue;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    usuario?: UsuarioUpdateOneRequiredWithoutInscripcionesNestedInput;
  };

  export type InscripcionUncheckedUpdateWithoutCursoInput = {
    id?: IntFieldUpdateOperationsInput | number;
    usuarioId?: IntFieldUpdateOperationsInput | number;
    estado?:
      | EnumEstadoInscripcionFieldUpdateOperationsInput
      | $Enums.EstadoInscripcion;
    progreso?: JsonNullValueInput | InputJsonValue;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type InscripcionUncheckedUpdateManyWithoutCursoInput = {
    id?: IntFieldUpdateOperationsInput | number;
    usuarioId?: IntFieldUpdateOperationsInput | number;
    estado?:
      | EnumEstadoInscripcionFieldUpdateOperationsInput
      | $Enums.EstadoInscripcion;
    progreso?: JsonNullValueInput | InputJsonValue;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ItemCarritoUpdateWithoutCursoInput = {
    tipo?: EnumTipoItemOrdenFieldUpdateOperationsInput | $Enums.TipoItemOrden;
    cantidad?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    carrito?: CarritoUpdateOneRequiredWithoutItemsNestedInput;
    producto?: ProductoUpdateOneWithoutItemsCarritoNestedInput;
  };

  export type ItemCarritoUncheckedUpdateWithoutCursoInput = {
    id?: IntFieldUpdateOperationsInput | number;
    carritoId?: IntFieldUpdateOperationsInput | number;
    tipo?: EnumTipoItemOrdenFieldUpdateOperationsInput | $Enums.TipoItemOrden;
    productoId?: NullableIntFieldUpdateOperationsInput | number | null;
    cantidad?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ItemCarritoUncheckedUpdateManyWithoutCursoInput = {
    id?: IntFieldUpdateOperationsInput | number;
    carritoId?: IntFieldUpdateOperationsInput | number;
    tipo?: EnumTipoItemOrdenFieldUpdateOperationsInput | $Enums.TipoItemOrden;
    productoId?: NullableIntFieldUpdateOperationsInput | number | null;
    cantidad?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type LeccionCreateManyModuloInput = {
    id?: number;
    titulo: string;
    rutaSrc?: string | null;
    orden: number;
    tipo?: $Enums.TipoLeccion;
    descripcion?: string | null;
    contenido?: NullableJsonNullValueInput | InputJsonValue;
    previewUrl?: string | null;
    duracion?: number;
  };

  export type LeccionUpdateWithoutModuloInput = {
    titulo?: StringFieldUpdateOperationsInput | string;
    rutaSrc?: NullableStringFieldUpdateOperationsInput | string | null;
    orden?: IntFieldUpdateOperationsInput | number;
    tipo?: EnumTipoLeccionFieldUpdateOperationsInput | $Enums.TipoLeccion;
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null;
    contenido?: NullableJsonNullValueInput | InputJsonValue;
    previewUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    duracion?: FloatFieldUpdateOperationsInput | number;
  };

  export type LeccionUncheckedUpdateWithoutModuloInput = {
    id?: IntFieldUpdateOperationsInput | number;
    titulo?: StringFieldUpdateOperationsInput | string;
    rutaSrc?: NullableStringFieldUpdateOperationsInput | string | null;
    orden?: IntFieldUpdateOperationsInput | number;
    tipo?: EnumTipoLeccionFieldUpdateOperationsInput | $Enums.TipoLeccion;
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null;
    contenido?: NullableJsonNullValueInput | InputJsonValue;
    previewUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    duracion?: FloatFieldUpdateOperationsInput | number;
  };

  export type LeccionUncheckedUpdateManyWithoutModuloInput = {
    id?: IntFieldUpdateOperationsInput | number;
    titulo?: StringFieldUpdateOperationsInput | string;
    rutaSrc?: NullableStringFieldUpdateOperationsInput | string | null;
    orden?: IntFieldUpdateOperationsInput | number;
    tipo?: EnumTipoLeccionFieldUpdateOperationsInput | $Enums.TipoLeccion;
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null;
    contenido?: NullableJsonNullValueInput | InputJsonValue;
    previewUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    duracion?: FloatFieldUpdateOperationsInput | number;
  };

  export type ProductoImagenCreateManyProductoInput = {
    id?: number;
    archivo: string;
    alt?: string | null;
    orden?: number;
  };

  export type ResenaCreateManyProductoInput = {
    id?: number;
    cursoId?: number | null;
    usuarioId: number;
    puntaje: number;
    comentario?: string | null;
    creadoEn?: Date | string;
  };

  export type FavoritoCreateManyProductoInput = {
    id?: number;
    usuarioId: number;
    creadoEn?: Date | string;
  };

  export type ItemCarritoCreateManyProductoInput = {
    id?: number;
    carritoId: number;
    tipo: $Enums.TipoItemOrden;
    cursoId?: number | null;
    cantidad?: number;
    creadoEn?: Date | string;
  };

  export type ProductoImagenUpdateWithoutProductoInput = {
    archivo?: StringFieldUpdateOperationsInput | string;
    alt?: NullableStringFieldUpdateOperationsInput | string | null;
    orden?: IntFieldUpdateOperationsInput | number;
  };

  export type ProductoImagenUncheckedUpdateWithoutProductoInput = {
    id?: IntFieldUpdateOperationsInput | number;
    archivo?: StringFieldUpdateOperationsInput | string;
    alt?: NullableStringFieldUpdateOperationsInput | string | null;
    orden?: IntFieldUpdateOperationsInput | number;
  };

  export type ProductoImagenUncheckedUpdateManyWithoutProductoInput = {
    id?: IntFieldUpdateOperationsInput | number;
    archivo?: StringFieldUpdateOperationsInput | string;
    alt?: NullableStringFieldUpdateOperationsInput | string | null;
    orden?: IntFieldUpdateOperationsInput | number;
  };

  export type ResenaUpdateWithoutProductoInput = {
    puntaje?: IntFieldUpdateOperationsInput | number;
    comentario?: NullableStringFieldUpdateOperationsInput | string | null;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    curso?: CursoUpdateOneWithoutResenasNestedInput;
    usuario?: UsuarioUpdateOneRequiredWithoutResenasNestedInput;
    respuestas?: ResenaRespuestaUpdateManyWithoutResenaNestedInput;
    likes?: ResenaLikeUpdateManyWithoutResenaNestedInput;
  };

  export type ResenaUncheckedUpdateWithoutProductoInput = {
    id?: IntFieldUpdateOperationsInput | number;
    cursoId?: NullableIntFieldUpdateOperationsInput | number | null;
    usuarioId?: IntFieldUpdateOperationsInput | number;
    puntaje?: IntFieldUpdateOperationsInput | number;
    comentario?: NullableStringFieldUpdateOperationsInput | string | null;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    respuestas?: ResenaRespuestaUncheckedUpdateManyWithoutResenaNestedInput;
    likes?: ResenaLikeUncheckedUpdateManyWithoutResenaNestedInput;
  };

  export type ResenaUncheckedUpdateManyWithoutProductoInput = {
    id?: IntFieldUpdateOperationsInput | number;
    cursoId?: NullableIntFieldUpdateOperationsInput | number | null;
    usuarioId?: IntFieldUpdateOperationsInput | number;
    puntaje?: IntFieldUpdateOperationsInput | number;
    comentario?: NullableStringFieldUpdateOperationsInput | string | null;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FavoritoUpdateWithoutProductoInput = {
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    usuario?: UsuarioUpdateOneRequiredWithoutFavoritosNestedInput;
  };

  export type FavoritoUncheckedUpdateWithoutProductoInput = {
    id?: IntFieldUpdateOperationsInput | number;
    usuarioId?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FavoritoUncheckedUpdateManyWithoutProductoInput = {
    id?: IntFieldUpdateOperationsInput | number;
    usuarioId?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ItemCarritoUpdateWithoutProductoInput = {
    tipo?: EnumTipoItemOrdenFieldUpdateOperationsInput | $Enums.TipoItemOrden;
    cantidad?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    carrito?: CarritoUpdateOneRequiredWithoutItemsNestedInput;
    curso?: CursoUpdateOneWithoutItemsCarritoNestedInput;
  };

  export type ItemCarritoUncheckedUpdateWithoutProductoInput = {
    id?: IntFieldUpdateOperationsInput | number;
    carritoId?: IntFieldUpdateOperationsInput | number;
    tipo?: EnumTipoItemOrdenFieldUpdateOperationsInput | $Enums.TipoItemOrden;
    cursoId?: NullableIntFieldUpdateOperationsInput | number | null;
    cantidad?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ItemCarritoUncheckedUpdateManyWithoutProductoInput = {
    id?: IntFieldUpdateOperationsInput | number;
    carritoId?: IntFieldUpdateOperationsInput | number;
    tipo?: EnumTipoItemOrdenFieldUpdateOperationsInput | $Enums.TipoItemOrden;
    cursoId?: NullableIntFieldUpdateOperationsInput | number | null;
    cantidad?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ProductoCreateManyMarcaInput = {
    id?: number;
    slug: string;
    titulo: string;
    precio: number;
    stock?: number;
    publicado?: boolean;
    destacado?: boolean;
    imagen?: string | null;
    descripcionMD?: string | null;
    precioLista?: number | null;
    ratingProm?: Decimal | DecimalJsLike | number | string | null;
    ratingConteo?: number;
    creadoEn?: Date | string;
    categoriaId?: number | null;
  };

  export type ProductoUpdateWithoutMarcaInput = {
    slug?: StringFieldUpdateOperationsInput | string;
    titulo?: StringFieldUpdateOperationsInput | string;
    precio?: IntFieldUpdateOperationsInput | number;
    stock?: IntFieldUpdateOperationsInput | number;
    publicado?: BoolFieldUpdateOperationsInput | boolean;
    destacado?: BoolFieldUpdateOperationsInput | boolean;
    imagen?: NullableStringFieldUpdateOperationsInput | string | null;
    descripcionMD?: NullableStringFieldUpdateOperationsInput | string | null;
    precioLista?: NullableIntFieldUpdateOperationsInput | number | null;
    ratingProm?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    ratingConteo?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    categoria?: CategoriaUpdateOneWithoutProductosNestedInput;
    imagenes?: ProductoImagenUpdateManyWithoutProductoNestedInput;
    resenas?: ResenaUpdateManyWithoutProductoNestedInput;
    favoritos?: FavoritoUpdateManyWithoutProductoNestedInput;
    itemsCarrito?: ItemCarritoUpdateManyWithoutProductoNestedInput;
  };

  export type ProductoUncheckedUpdateWithoutMarcaInput = {
    id?: IntFieldUpdateOperationsInput | number;
    slug?: StringFieldUpdateOperationsInput | string;
    titulo?: StringFieldUpdateOperationsInput | string;
    precio?: IntFieldUpdateOperationsInput | number;
    stock?: IntFieldUpdateOperationsInput | number;
    publicado?: BoolFieldUpdateOperationsInput | boolean;
    destacado?: BoolFieldUpdateOperationsInput | boolean;
    imagen?: NullableStringFieldUpdateOperationsInput | string | null;
    descripcionMD?: NullableStringFieldUpdateOperationsInput | string | null;
    precioLista?: NullableIntFieldUpdateOperationsInput | number | null;
    ratingProm?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    ratingConteo?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    categoriaId?: NullableIntFieldUpdateOperationsInput | number | null;
    imagenes?: ProductoImagenUncheckedUpdateManyWithoutProductoNestedInput;
    resenas?: ResenaUncheckedUpdateManyWithoutProductoNestedInput;
    favoritos?: FavoritoUncheckedUpdateManyWithoutProductoNestedInput;
    itemsCarrito?: ItemCarritoUncheckedUpdateManyWithoutProductoNestedInput;
  };

  export type ProductoUncheckedUpdateManyWithoutMarcaInput = {
    id?: IntFieldUpdateOperationsInput | number;
    slug?: StringFieldUpdateOperationsInput | string;
    titulo?: StringFieldUpdateOperationsInput | string;
    precio?: IntFieldUpdateOperationsInput | number;
    stock?: IntFieldUpdateOperationsInput | number;
    publicado?: BoolFieldUpdateOperationsInput | boolean;
    destacado?: BoolFieldUpdateOperationsInput | boolean;
    imagen?: NullableStringFieldUpdateOperationsInput | string | null;
    descripcionMD?: NullableStringFieldUpdateOperationsInput | string | null;
    precioLista?: NullableIntFieldUpdateOperationsInput | number | null;
    ratingProm?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    ratingConteo?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    categoriaId?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type CategoriaCreateManyParentInput = {
    id?: number;
    slug: string;
    nombre: string;
    descripcion?: string | null;
    imagen?: string | null;
    activa?: boolean;
    orden?: number;
    creadoEn?: Date | string;
  };

  export type ProductoCreateManyCategoriaInput = {
    id?: number;
    slug: string;
    titulo: string;
    precio: number;
    stock?: number;
    publicado?: boolean;
    destacado?: boolean;
    imagen?: string | null;
    descripcionMD?: string | null;
    precioLista?: number | null;
    ratingProm?: Decimal | DecimalJsLike | number | string | null;
    ratingConteo?: number;
    creadoEn?: Date | string;
    marcaId?: number | null;
  };

  export type CategoriaUpdateWithoutParentInput = {
    slug?: StringFieldUpdateOperationsInput | string;
    nombre?: StringFieldUpdateOperationsInput | string;
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null;
    imagen?: NullableStringFieldUpdateOperationsInput | string | null;
    activa?: BoolFieldUpdateOperationsInput | boolean;
    orden?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    hijos?: CategoriaUpdateManyWithoutParentNestedInput;
    productos?: ProductoUpdateManyWithoutCategoriaNestedInput;
  };

  export type CategoriaUncheckedUpdateWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number;
    slug?: StringFieldUpdateOperationsInput | string;
    nombre?: StringFieldUpdateOperationsInput | string;
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null;
    imagen?: NullableStringFieldUpdateOperationsInput | string | null;
    activa?: BoolFieldUpdateOperationsInput | boolean;
    orden?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    hijos?: CategoriaUncheckedUpdateManyWithoutParentNestedInput;
    productos?: ProductoUncheckedUpdateManyWithoutCategoriaNestedInput;
  };

  export type CategoriaUncheckedUpdateManyWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number;
    slug?: StringFieldUpdateOperationsInput | string;
    nombre?: StringFieldUpdateOperationsInput | string;
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null;
    imagen?: NullableStringFieldUpdateOperationsInput | string | null;
    activa?: BoolFieldUpdateOperationsInput | boolean;
    orden?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ProductoUpdateWithoutCategoriaInput = {
    slug?: StringFieldUpdateOperationsInput | string;
    titulo?: StringFieldUpdateOperationsInput | string;
    precio?: IntFieldUpdateOperationsInput | number;
    stock?: IntFieldUpdateOperationsInput | number;
    publicado?: BoolFieldUpdateOperationsInput | boolean;
    destacado?: BoolFieldUpdateOperationsInput | boolean;
    imagen?: NullableStringFieldUpdateOperationsInput | string | null;
    descripcionMD?: NullableStringFieldUpdateOperationsInput | string | null;
    precioLista?: NullableIntFieldUpdateOperationsInput | number | null;
    ratingProm?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    ratingConteo?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    marca?: MarcaUpdateOneWithoutProductosNestedInput;
    imagenes?: ProductoImagenUpdateManyWithoutProductoNestedInput;
    resenas?: ResenaUpdateManyWithoutProductoNestedInput;
    favoritos?: FavoritoUpdateManyWithoutProductoNestedInput;
    itemsCarrito?: ItemCarritoUpdateManyWithoutProductoNestedInput;
  };

  export type ProductoUncheckedUpdateWithoutCategoriaInput = {
    id?: IntFieldUpdateOperationsInput | number;
    slug?: StringFieldUpdateOperationsInput | string;
    titulo?: StringFieldUpdateOperationsInput | string;
    precio?: IntFieldUpdateOperationsInput | number;
    stock?: IntFieldUpdateOperationsInput | number;
    publicado?: BoolFieldUpdateOperationsInput | boolean;
    destacado?: BoolFieldUpdateOperationsInput | boolean;
    imagen?: NullableStringFieldUpdateOperationsInput | string | null;
    descripcionMD?: NullableStringFieldUpdateOperationsInput | string | null;
    precioLista?: NullableIntFieldUpdateOperationsInput | number | null;
    ratingProm?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    ratingConteo?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    marcaId?: NullableIntFieldUpdateOperationsInput | number | null;
    imagenes?: ProductoImagenUncheckedUpdateManyWithoutProductoNestedInput;
    resenas?: ResenaUncheckedUpdateManyWithoutProductoNestedInput;
    favoritos?: FavoritoUncheckedUpdateManyWithoutProductoNestedInput;
    itemsCarrito?: ItemCarritoUncheckedUpdateManyWithoutProductoNestedInput;
  };

  export type ProductoUncheckedUpdateManyWithoutCategoriaInput = {
    id?: IntFieldUpdateOperationsInput | number;
    slug?: StringFieldUpdateOperationsInput | string;
    titulo?: StringFieldUpdateOperationsInput | string;
    precio?: IntFieldUpdateOperationsInput | number;
    stock?: IntFieldUpdateOperationsInput | number;
    publicado?: BoolFieldUpdateOperationsInput | boolean;
    destacado?: BoolFieldUpdateOperationsInput | boolean;
    imagen?: NullableStringFieldUpdateOperationsInput | string | null;
    descripcionMD?: NullableStringFieldUpdateOperationsInput | string | null;
    precioLista?: NullableIntFieldUpdateOperationsInput | number | null;
    ratingProm?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    ratingConteo?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    marcaId?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type ItemOrdenCreateManyOrdenInput = {
    id?: number;
    tipo: $Enums.TipoItemOrden;
    refId: number;
    titulo: string;
    cantidad?: number;
    precioUnitario: number;
  };

  export type ItemOrdenUpdateWithoutOrdenInput = {
    tipo?: EnumTipoItemOrdenFieldUpdateOperationsInput | $Enums.TipoItemOrden;
    refId?: IntFieldUpdateOperationsInput | number;
    titulo?: StringFieldUpdateOperationsInput | string;
    cantidad?: IntFieldUpdateOperationsInput | number;
    precioUnitario?: IntFieldUpdateOperationsInput | number;
  };

  export type ItemOrdenUncheckedUpdateWithoutOrdenInput = {
    id?: IntFieldUpdateOperationsInput | number;
    tipo?: EnumTipoItemOrdenFieldUpdateOperationsInput | $Enums.TipoItemOrden;
    refId?: IntFieldUpdateOperationsInput | number;
    titulo?: StringFieldUpdateOperationsInput | string;
    cantidad?: IntFieldUpdateOperationsInput | number;
    precioUnitario?: IntFieldUpdateOperationsInput | number;
  };

  export type ItemOrdenUncheckedUpdateManyWithoutOrdenInput = {
    id?: IntFieldUpdateOperationsInput | number;
    tipo?: EnumTipoItemOrdenFieldUpdateOperationsInput | $Enums.TipoItemOrden;
    refId?: IntFieldUpdateOperationsInput | number;
    titulo?: StringFieldUpdateOperationsInput | string;
    cantidad?: IntFieldUpdateOperationsInput | number;
    precioUnitario?: IntFieldUpdateOperationsInput | number;
  };

  export type OrdenCreateManyDireccionEnvioInput = {
    id?: number;
    usuarioId: number;
    estado?: $Enums.EstadoOrden;
    total: number;
    moneda?: string;
    referenciaPago?: string | null;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
    esSuscripcion?: boolean;
    suscripcionActiva?: boolean | null;
    suscripcionId?: string | null;
    suscripcionFrecuencia?: number | null;
    suscripcionTipoFrecuencia?: string | null;
    metadatos?: NullableJsonNullValueInput | InputJsonValue;
    direccionFacturacionId?: number | null;
  };

  export type OrdenCreateManyDireccionFacturacionInput = {
    id?: number;
    usuarioId: number;
    estado?: $Enums.EstadoOrden;
    total: number;
    moneda?: string;
    referenciaPago?: string | null;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
    esSuscripcion?: boolean;
    suscripcionActiva?: boolean | null;
    suscripcionId?: string | null;
    suscripcionFrecuencia?: number | null;
    suscripcionTipoFrecuencia?: string | null;
    metadatos?: NullableJsonNullValueInput | InputJsonValue;
    direccionEnvioId?: number | null;
  };

  export type OrdenUpdateWithoutDireccionEnvioInput = {
    estado?: EnumEstadoOrdenFieldUpdateOperationsInput | $Enums.EstadoOrden;
    total?: IntFieldUpdateOperationsInput | number;
    moneda?: StringFieldUpdateOperationsInput | string;
    referenciaPago?: NullableStringFieldUpdateOperationsInput | string | null;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    esSuscripcion?: BoolFieldUpdateOperationsInput | boolean;
    suscripcionActiva?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    suscripcionId?: NullableStringFieldUpdateOperationsInput | string | null;
    suscripcionFrecuencia?:
      | NullableIntFieldUpdateOperationsInput
      | number
      | null;
    suscripcionTipoFrecuencia?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    metadatos?: NullableJsonNullValueInput | InputJsonValue;
    usuario?: UsuarioUpdateOneRequiredWithoutOrdenesNestedInput;
    direccionFacturacion?: DireccionUpdateOneWithoutOrdenesFacturacionNestedInput;
    items?: ItemOrdenUpdateManyWithoutOrdenNestedInput;
  };

  export type OrdenUncheckedUpdateWithoutDireccionEnvioInput = {
    id?: IntFieldUpdateOperationsInput | number;
    usuarioId?: IntFieldUpdateOperationsInput | number;
    estado?: EnumEstadoOrdenFieldUpdateOperationsInput | $Enums.EstadoOrden;
    total?: IntFieldUpdateOperationsInput | number;
    moneda?: StringFieldUpdateOperationsInput | string;
    referenciaPago?: NullableStringFieldUpdateOperationsInput | string | null;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    esSuscripcion?: BoolFieldUpdateOperationsInput | boolean;
    suscripcionActiva?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    suscripcionId?: NullableStringFieldUpdateOperationsInput | string | null;
    suscripcionFrecuencia?:
      | NullableIntFieldUpdateOperationsInput
      | number
      | null;
    suscripcionTipoFrecuencia?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    metadatos?: NullableJsonNullValueInput | InputJsonValue;
    direccionFacturacionId?:
      | NullableIntFieldUpdateOperationsInput
      | number
      | null;
    items?: ItemOrdenUncheckedUpdateManyWithoutOrdenNestedInput;
  };

  export type OrdenUncheckedUpdateManyWithoutDireccionEnvioInput = {
    id?: IntFieldUpdateOperationsInput | number;
    usuarioId?: IntFieldUpdateOperationsInput | number;
    estado?: EnumEstadoOrdenFieldUpdateOperationsInput | $Enums.EstadoOrden;
    total?: IntFieldUpdateOperationsInput | number;
    moneda?: StringFieldUpdateOperationsInput | string;
    referenciaPago?: NullableStringFieldUpdateOperationsInput | string | null;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    esSuscripcion?: BoolFieldUpdateOperationsInput | boolean;
    suscripcionActiva?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    suscripcionId?: NullableStringFieldUpdateOperationsInput | string | null;
    suscripcionFrecuencia?:
      | NullableIntFieldUpdateOperationsInput
      | number
      | null;
    suscripcionTipoFrecuencia?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    metadatos?: NullableJsonNullValueInput | InputJsonValue;
    direccionFacturacionId?:
      | NullableIntFieldUpdateOperationsInput
      | number
      | null;
  };

  export type OrdenUpdateWithoutDireccionFacturacionInput = {
    estado?: EnumEstadoOrdenFieldUpdateOperationsInput | $Enums.EstadoOrden;
    total?: IntFieldUpdateOperationsInput | number;
    moneda?: StringFieldUpdateOperationsInput | string;
    referenciaPago?: NullableStringFieldUpdateOperationsInput | string | null;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    esSuscripcion?: BoolFieldUpdateOperationsInput | boolean;
    suscripcionActiva?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    suscripcionId?: NullableStringFieldUpdateOperationsInput | string | null;
    suscripcionFrecuencia?:
      | NullableIntFieldUpdateOperationsInput
      | number
      | null;
    suscripcionTipoFrecuencia?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    metadatos?: NullableJsonNullValueInput | InputJsonValue;
    usuario?: UsuarioUpdateOneRequiredWithoutOrdenesNestedInput;
    direccionEnvio?: DireccionUpdateOneWithoutOrdenesEnvioNestedInput;
    items?: ItemOrdenUpdateManyWithoutOrdenNestedInput;
  };

  export type OrdenUncheckedUpdateWithoutDireccionFacturacionInput = {
    id?: IntFieldUpdateOperationsInput | number;
    usuarioId?: IntFieldUpdateOperationsInput | number;
    estado?: EnumEstadoOrdenFieldUpdateOperationsInput | $Enums.EstadoOrden;
    total?: IntFieldUpdateOperationsInput | number;
    moneda?: StringFieldUpdateOperationsInput | string;
    referenciaPago?: NullableStringFieldUpdateOperationsInput | string | null;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    esSuscripcion?: BoolFieldUpdateOperationsInput | boolean;
    suscripcionActiva?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    suscripcionId?: NullableStringFieldUpdateOperationsInput | string | null;
    suscripcionFrecuencia?:
      | NullableIntFieldUpdateOperationsInput
      | number
      | null;
    suscripcionTipoFrecuencia?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    metadatos?: NullableJsonNullValueInput | InputJsonValue;
    direccionEnvioId?: NullableIntFieldUpdateOperationsInput | number | null;
    items?: ItemOrdenUncheckedUpdateManyWithoutOrdenNestedInput;
  };

  export type OrdenUncheckedUpdateManyWithoutDireccionFacturacionInput = {
    id?: IntFieldUpdateOperationsInput | number;
    usuarioId?: IntFieldUpdateOperationsInput | number;
    estado?: EnumEstadoOrdenFieldUpdateOperationsInput | $Enums.EstadoOrden;
    total?: IntFieldUpdateOperationsInput | number;
    moneda?: StringFieldUpdateOperationsInput | string;
    referenciaPago?: NullableStringFieldUpdateOperationsInput | string | null;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    esSuscripcion?: BoolFieldUpdateOperationsInput | boolean;
    suscripcionActiva?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    suscripcionId?: NullableStringFieldUpdateOperationsInput | string | null;
    suscripcionFrecuencia?:
      | NullableIntFieldUpdateOperationsInput
      | number
      | null;
    suscripcionTipoFrecuencia?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    metadatos?: NullableJsonNullValueInput | InputJsonValue;
    direccionEnvioId?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type ResenaRespuestaCreateManyResenaInput = {
    id?: number;
    usuarioId: number;
    parentId?: number | null;
    contenido: string;
    eliminado?: boolean;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
  };

  export type ResenaLikeCreateManyResenaInput = {
    id?: number;
    usuarioId: number;
    tipo: $Enums.TipoLike;
    creadoEn?: Date | string;
  };

  export type ResenaRespuestaUpdateWithoutResenaInput = {
    contenido?: StringFieldUpdateOperationsInput | string;
    eliminado?: BoolFieldUpdateOperationsInput | boolean;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    usuario?: UsuarioUpdateOneRequiredWithoutResenaRespuestasNestedInput;
    parent?: ResenaRespuestaUpdateOneWithoutHijosNestedInput;
    hijos?: ResenaRespuestaUpdateManyWithoutParentNestedInput;
  };

  export type ResenaRespuestaUncheckedUpdateWithoutResenaInput = {
    id?: IntFieldUpdateOperationsInput | number;
    usuarioId?: IntFieldUpdateOperationsInput | number;
    parentId?: NullableIntFieldUpdateOperationsInput | number | null;
    contenido?: StringFieldUpdateOperationsInput | string;
    eliminado?: BoolFieldUpdateOperationsInput | boolean;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    hijos?: ResenaRespuestaUncheckedUpdateManyWithoutParentNestedInput;
  };

  export type ResenaRespuestaUncheckedUpdateManyWithoutResenaInput = {
    id?: IntFieldUpdateOperationsInput | number;
    usuarioId?: IntFieldUpdateOperationsInput | number;
    parentId?: NullableIntFieldUpdateOperationsInput | number | null;
    contenido?: StringFieldUpdateOperationsInput | string;
    eliminado?: BoolFieldUpdateOperationsInput | boolean;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ResenaLikeUpdateWithoutResenaInput = {
    tipo?: EnumTipoLikeFieldUpdateOperationsInput | $Enums.TipoLike;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    usuario?: UsuarioUpdateOneRequiredWithoutResenaLikesNestedInput;
  };

  export type ResenaLikeUncheckedUpdateWithoutResenaInput = {
    id?: IntFieldUpdateOperationsInput | number;
    usuarioId?: IntFieldUpdateOperationsInput | number;
    tipo?: EnumTipoLikeFieldUpdateOperationsInput | $Enums.TipoLike;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ResenaLikeUncheckedUpdateManyWithoutResenaInput = {
    id?: IntFieldUpdateOperationsInput | number;
    usuarioId?: IntFieldUpdateOperationsInput | number;
    tipo?: EnumTipoLikeFieldUpdateOperationsInput | $Enums.TipoLike;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ResenaRespuestaCreateManyParentInput = {
    id?: number;
    resenaId: number;
    usuarioId: number;
    contenido: string;
    eliminado?: boolean;
    creadoEn?: Date | string;
    actualizadoEn?: Date | string;
  };

  export type ResenaRespuestaUpdateWithoutParentInput = {
    contenido?: StringFieldUpdateOperationsInput | string;
    eliminado?: BoolFieldUpdateOperationsInput | boolean;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    resena?: ResenaUpdateOneRequiredWithoutRespuestasNestedInput;
    usuario?: UsuarioUpdateOneRequiredWithoutResenaRespuestasNestedInput;
    hijos?: ResenaRespuestaUpdateManyWithoutParentNestedInput;
  };

  export type ResenaRespuestaUncheckedUpdateWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number;
    resenaId?: IntFieldUpdateOperationsInput | number;
    usuarioId?: IntFieldUpdateOperationsInput | number;
    contenido?: StringFieldUpdateOperationsInput | string;
    eliminado?: BoolFieldUpdateOperationsInput | boolean;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    hijos?: ResenaRespuestaUncheckedUpdateManyWithoutParentNestedInput;
  };

  export type ResenaRespuestaUncheckedUpdateManyWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number;
    resenaId?: IntFieldUpdateOperationsInput | number;
    usuarioId?: IntFieldUpdateOperationsInput | number;
    contenido?: StringFieldUpdateOperationsInput | string;
    eliminado?: BoolFieldUpdateOperationsInput | boolean;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ItemCarritoCreateManyCarritoInput = {
    id?: number;
    tipo: $Enums.TipoItemOrden;
    productoId?: number | null;
    cursoId?: number | null;
    cantidad?: number;
    creadoEn?: Date | string;
  };

  export type ItemCarritoUpdateWithoutCarritoInput = {
    tipo?: EnumTipoItemOrdenFieldUpdateOperationsInput | $Enums.TipoItemOrden;
    cantidad?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
    producto?: ProductoUpdateOneWithoutItemsCarritoNestedInput;
    curso?: CursoUpdateOneWithoutItemsCarritoNestedInput;
  };

  export type ItemCarritoUncheckedUpdateWithoutCarritoInput = {
    id?: IntFieldUpdateOperationsInput | number;
    tipo?: EnumTipoItemOrdenFieldUpdateOperationsInput | $Enums.TipoItemOrden;
    productoId?: NullableIntFieldUpdateOperationsInput | number | null;
    cursoId?: NullableIntFieldUpdateOperationsInput | number | null;
    cantidad?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ItemCarritoUncheckedUpdateManyWithoutCarritoInput = {
    id?: IntFieldUpdateOperationsInput | number;
    tipo?: EnumTipoItemOrdenFieldUpdateOperationsInput | $Enums.TipoItemOrden;
    productoId?: NullableIntFieldUpdateOperationsInput | number | null;
    cursoId?: NullableIntFieldUpdateOperationsInput | number | null;
    cantidad?: IntFieldUpdateOperationsInput | number;
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number;
  };

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF;
}
